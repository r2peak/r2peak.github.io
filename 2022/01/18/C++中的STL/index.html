<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++中的STL | Road To Peak</title><meta name="keywords" content="STL"><meta name="author" content="马厚煜"><meta name="copyright" content="马厚煜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="vector&amp;emsp;&amp;emsp;vector翻译为向量，但是这里使用“变长数组”的叫法更容易理解，也即“长度根据需要而自动改变的数组”。在考试题中，有时会碰到只用普通数组会超内存的情况，这种情况使用 vector会让问题的解决便捷许多。另外， vector还可以用来以邻接表的方式储存图，这对无法使用邻接矩阵的题目（结点数太多）、又害怕使用指针实现邻接表的读者是非常友好的，写法也非常简洁。 常">
<meta property="og:type" content="article">
<meta property="og:title" content="C++中的STL">
<meta property="og:url" content="http://example.com/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/index.html">
<meta property="og:site_name" content="Road To Peak">
<meta property="og:description" content="vector&amp;emsp;&amp;emsp;vector翻译为向量，但是这里使用“变长数组”的叫法更容易理解，也即“长度根据需要而自动改变的数组”。在考试题中，有时会碰到只用普通数组会超内存的情况，这种情况使用 vector会让问题的解决便捷许多。另外， vector还可以用来以邻接表的方式储存图，这对无法使用邻接矩阵的题目（结点数太多）、又害怕使用指针实现邻接表的读者是非常友好的，写法也非常简洁。 常">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/zj.png">
<meta property="article:published_time" content="2022-01-18T04:27:31.000Z">
<meta property="article:modified_time" content="2022-01-18T12:19:52.639Z">
<meta property="article:author" content="马厚煜">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/zj.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++中的STL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-18 20:19:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Road To Peak" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/zj.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Road To Peak</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++中的STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-18T04:27:31.000Z" title="发表于 2022-01-18 12:27:31">2022-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-18T12:19:52.639Z" title="更新于 2022-01-18 20:19:52">2022-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++中的STL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-18/1642504703480-image.png"></p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>&emsp;&emsp;vector翻译为向量，但是这里使用“<strong>变长数组</strong>”的叫法更容易理解，也即“长度根据需要而自动改变的数组”。在考试题中，有时会碰到只用普通数组会超内存的情况，这种情况使用 vector会让问题的解决便捷许多。另外， vector还可以用来以邻接表的方式储存图，这对无法使用邻接矩阵的题目（结点数太多）、又害怕使用指针实现邻接表的读者是非常友好的，写法也非常简洁。</p>
<p><strong>常见用途：</strong></p>
<p><em>1. 储存数据</em></p>
<p><em>① vector本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。</em></p>
<p><em>② 有些场合需要根据一些条件把部分数据输出在同一行，数据中间用空格隔开。由于输出数据的个数是不确定的，为了更方便地处理最后一个满足条件的数据，后面不输出额外的空格，可以先用 vector记录所有需要输出的数据，然后一次性输出。</em></p>
<p><em>2. 用邻接表存储图</em></p>
<p><em>使用 vector实现邻接表可以让一些对指针不太熟悉的读者有一个比较方便的写法。具体见《算法笔记》10.2.2节。</em></p>
<p><strong>vector常用函数概览：</strong></p>
<ol>
<li>push_back()：在vector后面添加一个元素，O(1) </li>
<li>size()：用于获取vector中元素个数，O(1)</li>
<li>pop_back()：删除vector尾部元素，O(1) </li>
<li>insert(it, x)：用于向vector的任意迭代器it处插入一个元素，O(N)</li>
<li>erase()：删除单个元素 / 一个区间内所有元素，均为O(N)。① 删除单个元素 vi.erase(vi.begin() + 2); 即删除第三个位置上的元素；② erase(first, last) 即删除 [first, last)内所有元素</li>
<li>clear()：用于清空vector中所有元素，O(N) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// push_back()：在vector后面添加一个元素，O(1) </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//size()：用于获取vector中元素个数，O(1)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;  </span><br><span class="line">		cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// pop_back()：删除vector尾部元素，O(1) </span></span><br><span class="line">	vi.<span class="built_in">pop_back</span>(); <span class="comment">// 删除vi尾元素 9 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert(it, x)：用于向vector的任意迭代器it处插入一个元素，O(N)</span></span><br><span class="line">	vi.<span class="built_in">insert</span>(vi.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">-1</span>); <span class="comment">// 将-1插入到vi[2]的位置 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 -1 2 3 4 5 6 7 8</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// erase()：删除单个元素 / 一个区间内所有元素，均为O(N) </span></span><br><span class="line">	<span class="comment">// 1、删除单个元素</span></span><br><span class="line">	vi.<span class="built_in">erase</span>(vi.<span class="built_in">begin</span>() + <span class="number">2</span>); </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 2、erase(first, last) 即删除 [first, last)内所有元素 </span></span><br><span class="line">	vi.<span class="built_in">erase</span>(vi.<span class="built_in">begin</span>() + <span class="number">1</span>, vi.<span class="built_in">end</span>() - <span class="number">3</span>);  <span class="comment">// 0 6 7 8</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear()：用于清空vector中所有元素，O(N) </span></span><br><span class="line">	vi.<span class="built_in">clear</span>();</span><br><span class="line">	cout &lt;&lt; vi.<span class="built_in">size</span>();  <span class="comment">// 0</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set翻译为集合，是一个<strong>内部自动有序（递增排序）</strong>且<strong>不含重复元素</strong>的容器。</p>
<p>需要注意的是，<strong>除了 vector和 string 之外的STL容器都不支持*(it+i)的访问方式。</strong></p>
<p><em><strong>常见用途：</strong></em></p>
<p><em>set最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用set解决。</em></p>
<p><em>延伸：set中元素是唯一的，如果需要处理不唯一的情况，则需要使用 multiset。另外，C++11标准中还增加了<strong>unordered_set</strong>，以散列代替set内部的红黑树（ Red Black Tree，一种自平衡二叉査找树）实现，使其可以用来处理<strong>只去重但不排序</strong>的需求，速度比set要快得多。</em></p>
<p><strong>set常用函数概览：</strong></p>
<ol>
<li>insert() O(logN) N为set内元素个数 </li>
<li>find() O(logN) </li>
<li>erase()① 删除单个元素。方式一：通过迭代器，时间复杂度为：O(1)。方式二：通过 value ，时间复杂度为：O(logN)。 ② 删除区间元素 （通过迭代器确定删除位置）</li>
<li>size() O(1)</li>
<li>clear O(N) 清空set</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// insert O(logN) N为set内元素个数 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">		st.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//find O(logN) </span></span><br><span class="line">	<span class="comment">// set&lt;int&gt;::iterator it = st.find(2); // 在set中查找2，返回其迭代器</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; *it &lt;&lt;endl; </span></span><br><span class="line">	cout&lt;&lt;*(st.<span class="built_in">find</span>(<span class="number">2</span>))&lt;&lt;endl; <span class="comment">// 等价于上面两句  // 2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// erase </span></span><br><span class="line">	<span class="comment">// 1、删除单个元素 </span></span><br><span class="line">	st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(<span class="number">3</span>)); <span class="comment">// 通过迭代器 O(1)</span></span><br><span class="line">	st.<span class="built_in">erase</span>(<span class="number">4</span>); <span class="comment">// 通过 value O(logN)</span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++) &#123; <span class="comment">// 遍历 </span></span><br><span class="line">		cout &lt;&lt;*(it)&lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 5 6 7 8 9</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 2、删除区间元素 </span></span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">find</span>(<span class="number">6</span>);</span><br><span class="line">	st.<span class="built_in">erase</span>(it, st.<span class="built_in">end</span>()); <span class="comment">// 删除6~9区间元素 </span></span><br><span class="line">	<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt;*(it)&lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 5</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// size O(1)</span></span><br><span class="line">	cout &lt;&lt; st.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear O(N) 清空set</span></span><br><span class="line">	st.<span class="built_in">clear</span>();</span><br><span class="line">	cout &lt;&lt; st.<span class="built_in">size</span>(); <span class="comment">// 0</span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>&emsp;&emsp;在C语言中，一般使用字符数组 char strl来存放字符串，但是使用字符数组有时会显得操作麻烦，而且容易因经验不足而产生一些错误。为了使编程者可以更方便地对字符串进行操作，C++在STL中加入了 string类型，对字符串常用的需求功能进行了封装，使得操作起来更方便，且不易出错。</p>
<p>string函数概述：</p>
<ol>
<li><p>string的定义 </p>
</li>
<li><p>string中内容的访问<br>（1）通过下标访问（可直接像字符数组那样去访问string）<br>（2）通过迭代器访问<br>注意：若要读入和输出整个字符串，只能用 cin 和 cout </p>
</li>
</ol>
<p><strong>3. string常用函数</strong></p>
<p>（1）operator+=  这是string的加法，可将string直接拼接起来 </p>
<p>（2）compare operator  两个string类型可使用== != &lt; &lt;= &gt; &gt;=比较大小 （字典序）</p>
<p>（3）length() / size() length()返回string长度，即存放的字符数，O(1)，二者基本相同 </p>
<p>（4）insert()  两个常用写法，均O(N) </p>
<ul>
<li>insert(pos, string)，在pos号位置插入字符串string。</li>
<li>insert(it, it2, it3)，it为原字符串的欲插入位置，it2和it3为待插字符串的首尾迭代器，用来表示串[it2,it3)将被插在it的位置上。 </li>
</ul>
<p>（5） erase() 删除单个元素 / 删除区间元素（两种方法） </p>
<ul>
<li>方法一： 迭代器方式 </li>
<li>方法二： str.erase(pos, length) 需要开始删除的起始位置下标，删除字符个数</li>
</ul>
<p>（6）clear() 清空string中的数据，O(1)</p>
<p>（7）substr(pos, len) 返回从pos号位开始，长度为len的子串，O(len)</p>
<p>（8）string::npos 这是个常数，值为-1 但由于是unsigned_int类型 ，因此也可以认为是unsigned_int类型的最大值。string::npos用以作为find函数失配时的返回值。<br>可以认为string::npos等于-1或4294967295 </p>
<p><em>注：4294967295是计算机程序设计里面的一个值，表示32位无符号整数的十进制最大值。如果是16进制，那么是0xFFFFFFFF。也可以解释为一个IP地址(V4) 255.255.255.255</em></p>
<p> （9）find()  O(nm) 其中n和m分别是str和str2的长度。 </p>
<ul>
<li>str.find(str2)  当str2是str1的子串时，返回其在str中第一次出现的位置；若str2不是str1子串，返回string::npos </li>
<li>str.find(str2, pos)  从str的pos号位开始匹配str2， 返回值与上相同。</li>
</ul>
<p>（10）replace()  O(str.length())</p>
<ul>
<li>str.replace(pos, len, str2)把str从pos号位开始、长度为len的子串替换为str2。</li>
<li>str.replace(it1, it2, str2)把str的迭代器[it1,it2)范围的子串替换为str2 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、string的定义  </span></span><br><span class="line">	string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2、string中内容的访问</span></span><br><span class="line">	<span class="comment">// （1）通过下标访问（可直接像字符数组那样去访问string）</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125; <span class="comment">// a b c d e f g</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 注意：若要读入和输出整个字符串，只能用 cin 和 cout </span></span><br><span class="line">	<span class="comment">//string str1;</span></span><br><span class="line">	<span class="comment">//cin &gt;&gt; str1; // ahhh</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; str1 &lt;&lt;endl; // ahhh</span></span><br><span class="line">	<span class="comment">// （2）通过迭代器访问 </span></span><br><span class="line">	<span class="comment">// string不像其它STL容器那样需要参数，可以直接如下定义：</span></span><br><span class="line">	<span class="keyword">for</span> (string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 通过*it来访问string里的每一位</span></span><br><span class="line">	&#125; <span class="comment">// a b c d e f g</span></span><br><span class="line">	cout &lt;&lt; endl; </span><br><span class="line">	<span class="comment">// string和 vector一样，支持直接对迭代器进行加减某个数字，如str. begin()+3的写法是可行的。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 3、string常用函数</span></span><br><span class="line">	<span class="comment">// （1）operator+=  这是string的加法，可将string直接拼接起来 </span></span><br><span class="line">	string str1 = <span class="string">&quot;aaa&quot;</span>, str2 = <span class="string">&quot;bbb&quot;</span>, str3;</span><br><span class="line">	str3 = str1 + str2; <span class="comment">// 将str1和str2拼接，赋值给str3</span></span><br><span class="line">	str1 += str2; <span class="comment">// 将str2直接拼接到str1上</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt;endl; <span class="comment">// str3 = aaabbb</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt;endl; <span class="comment">// str1 = aaabbb</span></span><br><span class="line">	<span class="comment">// （2）compare operator  两个string类型可使用== != &lt; &lt;= &gt; &gt;=比较大小 </span></span><br><span class="line">	string s1 = <span class="string">&quot;aa&quot;</span>, s2 = <span class="string">&quot;aaa&quot;</span>, s3 = <span class="string">&quot;abc&quot;</span>, s4 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (s1 &lt; s2) cout &lt;&lt; <span class="string">&quot;ok1&quot;</span> &lt;&lt; endl; <span class="comment">// 如果s1字典序小于s2，输出ok1 // ok1</span></span><br><span class="line">	<span class="keyword">if</span> (s1 != s3) cout &lt;&lt; <span class="string">&quot;ok2&quot;</span> &lt;&lt;endl; <span class="comment">// 如果s1和s3不等，输出ok2  // ok2</span></span><br><span class="line">	<span class="keyword">if</span> (s4 &gt; s3) cout &lt;&lt; <span class="string">&quot;ok3&quot;</span> &lt;&lt;endl; <span class="comment">// 如果s4字典序大于等于s3，输出ok3  // ok3</span></span><br><span class="line">	<span class="comment">// （3）length() / size() length()返回string长度，即存放的字符数，O(1)，二者基本相同 </span></span><br><span class="line">	cout &lt;&lt; s1.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">	cout &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;	<span class="comment">// 2</span></span><br><span class="line">	<span class="comment">// （4）insert()  两个常用写法，均O(N) </span></span><br><span class="line">	<span class="comment">// 1）、insert(pos, string)，在pos号位置插入字符串string。</span></span><br><span class="line">	string s = <span class="string">&quot;ad&quot;</span>, ss = <span class="string">&quot;bc&quot;</span>;</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">1</span>, ss); <span class="comment">//  在s[1]处插入bc，这里ss位置直接写&quot;bc&quot;也可以 </span></span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl; <span class="comment">// abcd </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2）、insert(it, it2, it3) </span></span><br><span class="line">	<span class="comment">// it为原字符串的欲插入位置，it2和it3为待插字符串的首尾</span></span><br><span class="line">	<span class="comment">// 迭代器，用来表示串[it2,it3)将被插在it的位置上。 </span></span><br><span class="line">	string ss1 = <span class="string">&quot;1245&quot;</span>, ss2 = <span class="string">&quot;3&quot;</span>; <span class="comment">// ss1是原字符串，ss2 是待插字符串</span></span><br><span class="line">	<span class="comment">// 在ss1的2号位（即2和4之间）插入 ss2</span></span><br><span class="line">	ss1.<span class="built_in">insert</span>(ss1.<span class="built_in">begin</span>() + <span class="number">2</span>, ss2.<span class="built_in">begin</span>(), ss2.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; ss1 &lt;&lt;endl; <span class="comment">// 12345</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （5） erase() 删除单个元素 / 删除区间元素（两种方法） </span></span><br><span class="line">	ss1.<span class="built_in">erase</span>(ss1.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 删除1号位（即2）</span></span><br><span class="line">	cout &lt;&lt; ss1 &lt;&lt; endl; <span class="comment">// 1345</span></span><br><span class="line">	<span class="comment">// 方法一： 迭代器方式 </span></span><br><span class="line">	ss1.<span class="built_in">erase</span>(ss1.<span class="built_in">begin</span>() + <span class="number">1</span>, ss1.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 删除[3,5)</span></span><br><span class="line">	cout &lt;&lt; ss1 &lt;&lt; endl; <span class="comment">// 15</span></span><br><span class="line">	<span class="comment">// 方法二： str.erase(pos, length) 需要开始删除的起始位置下标，删除字符个数 </span></span><br><span class="line">	ss1.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; ss1 &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// （6）clear() 清空string中的数据，O(1)</span></span><br><span class="line">	ss1.<span class="built_in">clear</span>();</span><br><span class="line">	cout &lt;&lt; ss1.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （7）substr(pos, len) 返回从pos号位开始，长度为len的子串，O(len)</span></span><br><span class="line">	string sss1 =  <span class="string">&quot;I love you&quot;</span>;</span><br><span class="line">	cout &lt;&lt; sss1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// I</span></span><br><span class="line">	cout &lt;&lt; sss1.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// love</span></span><br><span class="line">	cout &lt;&lt; sss1.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// you</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （8）string::npos 是个常数，值为-1 但由于是unsigned_int类型 ，因此也可以</span></span><br><span class="line">	<span class="comment">// 认为是unsigned_int类型的最大值。string::npos用以作为find函数失配时的返回值。</span></span><br><span class="line">	<span class="comment">// 可以认为string::npos等于-1或4294967295 </span></span><br><span class="line">	<span class="comment">// 4294967295：这是计算机程序设计里面的一个值，表示32位无符号整数的十进制最大值。</span></span><br><span class="line">	<span class="comment">// 如果是16进制，那么是0xFFFFFFFF。也可以解释为一个IP地址(V4) 255.255.255.255</span></span><br><span class="line">	<span class="keyword">if</span> (string::npos == <span class="number">-1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-1 is true.&quot;</span> &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (string::npos == <span class="number">4294967295</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;4294967295 is true.&quot;</span> &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （9）find()  O(nm) 其中n和m分别是str和str2的长度。 </span></span><br><span class="line">	<span class="comment">// str.find(str2)  当str2是str1的子串时，返回其在str中第一次出现的位置；</span></span><br><span class="line">	<span class="comment">// 若str2不是str1子串，返回string::npos </span></span><br><span class="line">	<span class="comment">// str.find(str2, pos)  从str的pos号位开始匹配str2， 返回值与上相同。</span></span><br><span class="line">	string st1 = <span class="string">&quot;Lonely noodle shop&quot;</span>; </span><br><span class="line">	string st2 = <span class="string">&quot;Lonely&quot;</span>; </span><br><span class="line">	string st3 = <span class="string">&quot;Lovely&quot;</span>; </span><br><span class="line">	<span class="keyword">if</span> (st1.<span class="built_in">find</span>(st2) != string::npos) &#123;</span><br><span class="line">		cout &lt;&lt; st1.<span class="built_in">find</span>(st2) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (st1.<span class="built_in">find</span>(st3) == string::npos) &#123;</span><br><span class="line">		cout &lt;&lt; st1.<span class="built_in">find</span>(st3) &lt;&lt; endl; <span class="comment">// 4294967295</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (st1.<span class="built_in">find</span>(st2, <span class="number">0</span>) != string::npos) &#123;</span><br><span class="line">		cout &lt;&lt; st1.<span class="built_in">find</span>(st2, <span class="number">0</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// （10）replace()  O(str.length())</span></span><br><span class="line">	<span class="comment">// str.replace(pos, len, str2)把str从pos号位开始、长度为len的子串替换为str2。</span></span><br><span class="line">	<span class="comment">// str.replace(it1, it2, str2)把str的迭代器[it1,it2)范围的子串替换为str2 </span></span><br><span class="line">	string ssss1 = <span class="string">&quot;Lovely duck shop&quot;</span>;</span><br><span class="line">	string ssss2 = <span class="string">&quot;Lonely&quot;</span>;</span><br><span class="line">	string ssss3 = <span class="string">&quot;noodle&quot;</span>;</span><br><span class="line">	cout &lt;&lt; ssss1.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">6</span>, ssss2) &lt;&lt; endl; <span class="comment">// Lonely duck shop</span></span><br><span class="line">	cout &lt;&lt; ssss1.<span class="built_in">replace</span>(ssss1.<span class="built_in">begin</span>() + <span class="number">7</span>,ssss1.<span class="built_in">begin</span>() + <span class="number">11</span>, ssss3); <span class="comment">// Lonely noodle shop</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-18/1642496633843-image.png"></p>
<p><strong>1.map的定义</strong></p>
<p>单独定义一个map:</p>
<blockquote>
<p>map&lt;typename1, typename2&gt; mp;</p>
</blockquote>
<p>map和其他STL容器在定义上有点不一样，因为map需要确定<strong>映射前类型（键key）和映射后类型（值 value）</strong>，所以需要在&lt; &gt;内填写两个类型，其中第一个是键的类型，第二个是值的类型。<strong>如果是int型映射到int型，就相当于是普通的int型数组。</strong></p>
<p>而如果是字符串到整型的映射，<strong>必须使用 string而不能用char数组:</strong></p>
<blockquote>
<p>map&lt;string, int&gt; mp;</p>
</blockquote>
<p>这是因为char数组作为数组，是不能被作为键值的。如果想用字符串做映射，必须用string。<br>前面也说到，map的键和值也可以是STL容器，例如可以将一个<strong>set容器映射到一个字符串</strong>：</p>
<blockquote>
<p>map&lt;set<int>, string&gt; mp:</p>
</blockquote>
<p><strong>2.map容器内元素的访问</strong></p>
<p>&emsp;&emsp;map一般有两种访问方式：通过下标访问或通过迭代器访问。下面分别讨论这两种访问方式。</p>
<p><strong>(1) 通过下标访问</strong></p>
<p>&emsp;&emsp;和访问普通的数组是一样的，例如对一个定义为 map&lt;char, int&gt; mp 的map来说，就可以直接使用mp[‘c’]的方式来访问它对应的整数。于是，当建立映射时，就可以直接使用mp[‘c’] = 20这样和普通数组一样的方式。但是要注意的是，<strong>map中的键是唯一的</strong>，也就是说，下面的代码将输出30：</p>
<blockquote>
<p>map&lt;char, int&gt; mp;<br>mp[‘c’]=20;<br>mp[‘c’]=30; // 20被覆盖</p>
</blockquote>
<p><strong>(2)通过迭代器访问</strong></p>
<p>map迭代器的定义和其他STL容器迭代器定义的方式相同：</p>
<blockquote>
<p>map&lt;typenamel, typename2&gt;::iterator it;</p>
</blockquote>
<p>typenamel和 typename2就是定义map时填写的类型，这样就得到了迭代器it。</p>
<p><strong>map迭代器的使用方式和其他STL容器的迭代器不同</strong>，因为map的每一对映射都有两个typename，这决定了必须能通过一个it来同时访问键和值。事实上，<strong>map可以使用it&gt;first来访问键，使用it-&gt; second来访问值。</strong></p>
<p>来看下面这个示例:</p>
<blockquote>
<p>map&lt;char, int&gt; mp;<br>mp[‘m’]=20<br>mp[‘r’]=30;<br>mp[‘a’]=40;<br>for (map&lt;char, int&gt;::iterator it = mp.begin&gt;();  it != mp.end();  it++) {<br>cout&lt;&lt; it -&gt; first &lt;&lt; “ “ &lt;&lt; it -&gt; second &lt;&lt; endl;<br>}</p>
</blockquote>
<p>在上面这个例子中，it-&gt;first是当前映射的键，it-&gt;second是当前映射的值。程序输出如下</p>
<blockquote>
<p>a 40<br>m 20<br>r 30</p>
</blockquote>
<p>接下来似乎发现了一个很有意思的现象：<strong>map会以键从小到大的顺序自动排序</strong>，即按 a &lt; m &lt; r 的顺序排列这三对映射。这是由于map内部是使用红黑树实现的(set也是)，在建立映射的过程中会自动实现从小到大的排序功能。</p>
<p><strong>3. map的常用函数</strong></p>
<ul>
<li>find(key) 返回键为key的映射的迭代器，O(logN)，N为map中映射的个数。</li>
<li> erase() </li>
</ul>
<p> &emsp;&emsp;（1）删除单个元素有两种方法：</p>
<p>  &emsp;&emsp;mp.erase(it)  it为需要删除的元素的迭代器，O(1)</p>
<p>  &emsp;&emsp;mp.erase(key) key为欲删除的映射的键。O(logN)，N为map内元素的个数。 </p>
<p>   &emsp;&emsp;（2）删除一个区间内的所有元素<br>   &emsp;&emsp;mp.erase(first, last),其中first为需要删除的区间的起始迭代器，而last则为需要删除的区间的末尾迭代器的下一个地址，也即为删除左闭右开的区间[first, last) 时间复杂度为O(last - first)</p>
<ul>
<li>size() 用来获得map中映射的对数</li>
<li>clear()用来清空map中的所有元素  O(N)，N为map中元素的个数</li>
</ul>
<p><strong>4.map的常见用途</strong></p>
<p>① 需要建立字符（或字符串）与整数之间映射的题目，使用map可以减少代码量</p>
<p>② 判断大整数或者其他类型数据是否存在的题目，可以把map当bol数组用</p>
<p>③ 字符串和字符串的映射也有可能会遇到。</p>
<p><em>延伸：map的键和值是唯一的，而如果一个键需要对应多个值，就只能用 multimap。另外，C+11标准中还增加了 unordered_map，以散列代替map内部的红黑树实现，使其可以用来处理只映射而不按key排序的需求，速度比map要快得多。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">	mp[<span class="string">&#x27;m&#x27;</span>] = <span class="number">20</span>; <span class="comment">// a 40</span></span><br><span class="line">	mp[<span class="string">&#x27;r&#x27;</span>] = <span class="number">30</span>; <span class="comment">// m 20</span></span><br><span class="line">	mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">40</span>; <span class="comment">// r 30</span></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (1)find(key) 返回键为key的映射的迭代器，O(logN)，N为map中映射的个数。</span></span><br><span class="line">	map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// r 30</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (2)erase() </span></span><br><span class="line">	<span class="comment">// 1）删除单个元素有两种方法</span></span><br><span class="line">	<span class="comment">// mp.erase(it)  it为需要删除的元素的迭代器，O(1)</span></span><br><span class="line">	mp.<span class="built_in">erase</span>(it); <span class="comment">// 删除 r 30 </span></span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// a 40 </span></span><br><span class="line">	&#125;<span class="comment">// m 20</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// mp.erase(key) key为欲删除的映射的键。O(logN)，N为map内元素的个数。 </span></span><br><span class="line">	mp.<span class="built_in">erase</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span> (map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// m 20</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2）删除一个区间内的所有元素 O(last - first)</span></span><br><span class="line">	<span class="comment">// mp.erase(first, last),其中first为需要删除的区间的起始迭代器，而last则为需要</span></span><br><span class="line">	<span class="comment">// 删除的区间的末尾迭代器的下一个地址，也即为删除左闭右开的区间[first, last) </span></span><br><span class="line">	 map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it1= mp.<span class="built_in">find</span>(<span class="string">&#x27;m&#x27;</span>); </span><br><span class="line">	 mp.<span class="built_in">erase</span>(it1, mp.<span class="built_in">end</span>()); <span class="comment">// 删除it之后的所有映射</span></span><br><span class="line">	 cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (3)size() 用来获得map中映射的对数 O(1)如上所示 </span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (4)clear()用来清空map中的所有元素  O(N)，N为map中元素的个数</span></span><br><span class="line">	mp[<span class="string">&#x27;h&#x27;</span>] = <span class="number">66</span>;</span><br><span class="line">	map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it2 = mp.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; it2-&gt;second&lt;&lt;endl; <span class="comment">// 66</span></span><br><span class="line">	mp.<span class="built_in">clear</span>();</span><br><span class="line">	cout &lt;&lt; mp.<span class="built_in">size</span>(); <span class="comment">// 0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>queue翻译为队列，在STL中主要则是实现了一个先进先出的容器。</p>
<p><strong>1.queue的定义</strong></p>
<p>添加头文件#include <queue>，其定义的写法和其他STL容器相同， typename可以是<strong>任意基本数据类型</strong>或<strong>容器</strong>：</p>
<blockquote>
<p>queue&lt; typename&gt; name;</p>
</blockquote>
<p><strong>2.queue容器内元素的访问</strong></p>
<p>由于队列( queue)本身就是一种先进先出的限制性数据结构，因此在<strong>STL中只能通过front()来访问队首元素，或是通过 back()来访问队尾元素。</strong></p>
<p><strong>3.queue常用函数</strong></p>
<ul>
<li>push()</li>
</ul>
<p>push(x)将x进行入队，时间复杂度O(1)。</p>
<ul>
<li>front(),back()</li>
</ul>
<p>分别获得队首元素和队尾元素，时间复杂度O(1)。</p>
<ul>
<li>pop()</li>
</ul>
<p>令队首元素出队，时间复杂度为O(1)。</p>
<ul>
<li>empty()</li>
</ul>
<p>检测queue是否为空，返回true则空，返回false则非空。时间复杂度为O(1)。</p>
<ul>
<li>size()</li>
</ul>
<p>返回queue内元素的个数，时间复杂度为O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">		q.<span class="built_in">push</span>(i); <span class="comment">// push(i)用以将i压入队列，因此依次入队1 2 3 4 5 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 1 5</span></span><br><span class="line">	</span><br><span class="line">	q.<span class="built_in">pop</span>(); <span class="comment">// 将队首元素1出队 </span></span><br><span class="line">	cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(q.<span class="built_in">empty</span>() == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;Empty!&quot;</span> &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Not Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt;endl; <span class="comment">// 4</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.queue的常见用途</strong></p>
<p>当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用 queue作为代替，以提高程序的准确性。</p>
<p>另外有一点注意的是，<strong>使用 front()和pop()函数前，必须用 empty()判断队列是否为空</strong>，否则可能因为队空而出现错误。</p>
<p>延伸：STL的容器中还有两种容器跟队列有关，分别是双端队列( deque)和优先队列( priority_queue)，前者是首尾皆可插入和删除的队列，后者是使用堆实现的默认将当前队列最大元素置于队首的容器。</p>
<p>​                                          </p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STL/">STL</a></div><div class="post_share"><div class="social-share" data-image="/img/zj.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/01/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2021%E7%9C%81%E8%B5%9B/"><img class="next-cover" src="/img/fh.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">蓝桥杯2021省赛</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">马厚煜</div><div class="author-info__description">为者常成，行者常至</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/r2peak"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/r2peak" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Start it from the bottom</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vector"><span class="toc-number">1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set"><span class="toc-number">2.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string"><span class="toc-number">3.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map"><span class="toc-number">4.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#queue"><span class="toc-number">5.</span> <span class="toc-text">queue</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/" title="C++中的STL"><img src="/img/zj.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++中的STL"/></a><div class="content"><a class="title" href="/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/" title="C++中的STL">C++中的STL</a><time datetime="2022-01-18T04:27:31.000Z" title="发表于 2022-01-18 12:27:31">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2021%E7%9C%81%E8%B5%9B/" title="蓝桥杯2021省赛"><img src="/img/fh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝桥杯2021省赛"/></a><div class="content"><a class="title" href="/2022/01/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2021%E7%9C%81%E8%B5%9B/" title="蓝桥杯2021省赛">蓝桥杯2021省赛</a><time datetime="2022-01-17T06:27:31.000Z" title="发表于 2022-01-17 14:27:31">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表"><img src="/img/xxjzt.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="哈希表"/></a><div class="content"><a class="title" href="/2022/01/15/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表">哈希表</a><time datetime="2022-01-15T03:27:31.000Z" title="发表于 2022-01-15 11:27:31">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2/" title="递归三部曲"><img src="/img/kuko.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="递归三部曲"/></a><div class="content"><a class="title" href="/2022/01/14/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2/" title="递归三部曲">递归三部曲</a><time datetime="2022-01-13T23:58:31.000Z" title="发表于 2022-01-14 07:58:31">2022-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/%E9%93%BE%E8%A1%A8/" title="链表"><img src="/img/hm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表"/></a><div class="content"><a class="title" href="/2022/01/13/%E9%93%BE%E8%A1%A8/" title="链表">链表</a><time datetime="2022-01-13T01:58:31.000Z" title="发表于 2022-01-13 09:58:31">2022-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 马厚煜</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>