<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Road To Peak</title>
  
  <subtitle>R2Peak</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-23T13:57:32.205Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>马厚煜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Acwing 第一讲 递推与递归</title>
    <link href="http://example.com/2022/03/21/C++%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AB%9E%E8%B5%9B%E5%A4%87%E5%BF%98/"/>
    <id>http://example.com/2022/03/21/C++%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AB%9E%E8%B5%9B%E5%A4%87%E5%BF%98/</id>
    <published>2022-03-21T05:58:31.000Z</published>
    <updated>2022-03-23T13:57:32.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何准备蓝桥杯比赛"><a href="#如何准备蓝桥杯比赛" class="headerlink" title="如何准备蓝桥杯比赛"></a>如何准备蓝桥杯比赛</h1><ul><li><p>要有一定刷题量<br>若想在省赛中取得较好成绩，建议做200题左右。<br>若想在国赛中取得较好成绩，建议做300题左右。<br>本课程约讲解100题左右。</p></li><li><p>要重视调试<br>有思路得前提下，若调试不过，不要立马问别人。要自己努力解决问题。</p></li><li><p>比赛时比的并不是去发明或者去创造某一个思路，比赛比的是熟练度。</p></li></ul><h1 id="做题的套路"><a href="#做题的套路" class="headerlink" title="做题的套路"></a>做题的套路</h1><p>算法题特点：<br>1、与数学、物理等学科相比，算法题的模型相对较少。<br>2、思维量高<br>3、编写编程能力 。要用理论去指导实践。数学题想出来就能做出来，但是算法题能想出来不一定能实现出来。</p><p>做题过程<br>1、看题目描述<br>2、分析，抽象出来它考什么模型。分析出题人是想问什么。<br>3、回忆之前学过的算法或做过的题目能不能解决这个问题。若不能，再去回溯。解决方案是平时多去积累一些题目，多去刷一些题目。只有平时积累的多了，考试的时候才能学以致用。</p><p>如何判断一个算法能不能用？<br>1、首先看正确性<br>2、再看时间是否超限制。<br>C++ 评测机一秒约运行一亿次。若算法的的时间复杂度超过10^8,则可能会超时。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-21/1647848006913-image.png"></p><p>做题时，先看数据范围，排除不能使用的算法。找到题目数据范围区间之内的算法。这样做题思路会更明确。<br>数据范围可以带给我们非常多的信息。</p><p>学算法一定要落实到代码上</p><p>若输入输出 范围 小于 10^5 推荐用 cin / cout 否则用 scanf / printf 输入时间会快一倍左右。</p><h1 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h1><ul><li>时间统计：</li></ul><p><code>clock（）</code>：该函数返回程序目前为止运行的时间。这样，在程序结束之前调用此函数，便可获得整个程序的运行时间。这个时间除以 常数CLOCKS_PER_SEC之后得到的值以“秒”为单位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Time used = %.2f\n&quot;, (double)clock() / CLOCKS_PER_SEC);</span><br></pre></td></tr></table></figure><blockquote><p>可以使用time.h和clock（）函数获得程序运行时间。常数<br>CLOCKS_PER_SEC和操作系统相关，请不要直接使用clock（）的返回值，而应总是除以<br>CLOCKS_PER_SEC。</p></blockquote><ul><li>pi</li></ul><p>M_PI（math.h中定义的常量）</p><p>或者</p><p><code>const double pi = acos(-1.0);</code></p><ul><li>获取数组长度<br>sizeof(arr)/sizeof(arr[0])</li></ul><h1 id="第一讲-递推与递归"><a href="#第一讲-递推与递归" class="headerlink" title="第一讲 递推与递归"></a>第一讲 递推与递归</h1><p>所谓递归,就是自己调用自己。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归计算斐波那契数列"><a href="#递归计算斐波那契数列" class="headerlink" title="递归计算斐波那契数列"></a>递归计算斐波那契数列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(n - <span class="number">1</span>) + <span class="built_in">f</span>(n - <span class="number">2</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ; </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何分析判断,递归的执行顺序呢?</p><p>所有递归都可以转化为一颗递归搜索树!</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647951499778-image.png"></p><p>记忆几个比较常用的数据</p><p>2^1 = 2<br>2^2 = 4<br>2^3 = 8<br>2^4 = 16<br>2^5 = 32<br>2^6 = 64<br>2^7 = 128<br>2^8 = 256<br>2^9 = 512<br>2^10 = 1024<br>2^15 = 32768<br>2^16 = 65536<br>2^20 约等于10^6<br>2^63 约等于 10^8</p><h3 id="92-递归实现指数型枚举"><a href="#92-递归实现指数型枚举" class="headerlink" title="92. 递归实现指数型枚举"></a>92. 递归实现指数型枚举</h3><p><a href="https://www.acwing.com/problem/content/description/94/">题目传送门</a></p><p>int st[10]; 数组初始默认值为0<br>f<br><em>注：st为state状态的缩写！cnt为count记数的缩写</em></p><p>答案输出格式中，每个数字之间有空格别忘了！</p><p>图解：<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-21/1647841910233-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> st[N]; <span class="comment">// 状态，记录每个位置当前的状态，0表示还没考虑，1表示选它，2表示不选</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 输出</span></span><br><span class="line">            <span class="keyword">if</span> ( st[i] == <span class="number">1</span>) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>; </span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>);<span class="comment">// 第一个分支:不选</span></span><br><span class="line">    st[u] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>); <span class="comment">// 第二个分支:选</span></span><br><span class="line">    st[u] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>变形 ：如何输出所有方案？</strong></p><p>开一个二维数组来记录，</p><p>★1 &lt;&lt; 15表示2的15次方</p><p>★<code>puts(&quot;&quot;)</code>:输出一个字符串 + 一个回车。这里字符串为空，等价于只输出一个回车。</p><p>每一个分支都要恢复现场！！！<br>st[u] = 0;会被覆盖掉，但这里为了更好的还原算法思想，写出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> st[N]; <span class="comment">// 状态，记录每个位置当前的状态，0表示还没考虑，1表示选它，2表示不选</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; ways; <span class="comment">// 记录方案 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n) </span><br><span class="line">    &#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; way; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 记录方案 </span></span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="number">1</span>) </span><br><span class="line">              way.<span class="built_in">push_back</span>(i);</span><br><span class="line">        ways.<span class="built_in">push_back</span>(way);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>; </span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>);<span class="comment">// 第一个分支:不选</span></span><br><span class="line">    st[u] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>); <span class="comment">// 第二个分支:选</span></span><br><span class="line">    st[u] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ways.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways[i].<span class="built_in">size</span>(); j ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ways[i][j]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>优点使用vector二维数组记录很精妙，在每一个方案内部选择vector一维数组记录，完了再把一维数组push_back到二维数组中。</p><p>缺点是使用vector速度慢了一倍多。</p><h3 id="94-递归实现排列型枚举"><a href="#94-递归实现排列型枚举" class="headerlink" title="94. 递归实现排列型枚举"></a>94. 递归实现排列型枚举</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-21/1647847729613-%5DW%60UZ%7D%5DUY6BJK9Q@I%7BT8JHE.png"></p><p><a href="https://www.acwing.com/problem/content/96/">题目传送门</a></p><p>一个萝卜一个坑</p><p><strong>当u&gt;n时，坑都被萝卜填满了，只需要输出出来就行了。</strong></p><p>小知识:<br><strong>全局变量初始值为0,局部变量初始值为随机值.</strong></p><p>所谓<strong>恢复现场</strong>,就是去的时候是什么样,回来的时候你再给我变成什么样.好比跟人借书,借的时候什么样,还的时候也得什么样,好借好还,再借不难.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> state[N]; <span class="comment">// 0表示还没放数,1~n表示放了哪个数</span></span><br><span class="line"><span class="keyword">bool</span> used[N]; <span class="comment">// true表示用过,false表示还未用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, state[i]); <span class="comment">// 打印方案</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次枚举每个分支,即当前位置可以填哪些数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) <span class="comment">// 如果数字i还没被用过</span></span><br><span class="line">        &#123;</span><br><span class="line">            state[u] = i; <span class="comment">// 在坑位u上放了萝卜(数字i)</span></span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// ★数字i被用过了★</span></span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            state[u] = <span class="number">0</span>;</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度估算:</strong></p><p>第一层,u = 1时,有一个分支,有一个O(n)的for循环<br>第二层,u = 2时,有n个分支,每个分支都有一个for循环:O(n<em>n)<br>第三层,有n(n-1)个分支,每个分支都有一个for循环:O(n</em>(n-1)*n)</p><p>…</p><p>最后一层叶节点,有n!个分支,都有一个for循环</p><p>综上,时间复杂度为:O(n!*n)</p><h3 id="93-递归实现组合型枚举"><a href="#93-递归实现组合型枚举" class="headerlink" title="93.递归实现组合型枚举"></a>93.递归实现组合型枚举</h3><p><a href="https://www.acwing.com/problem/content/95/">题目传送门</a></p><p><strong>排列:考虑顺序</strong></p><p>123的排列(以下都是不同的方案):</p><ul><li>123 </li><li>132</li><li>213</li><li>231</li><li>312</li><li>321</li></ul><p><strong>组合:不考虑顺序</strong><br>123的组合(以下都是相同的方案):</p><ul><li>123 </li><li>132</li><li>213</li><li>231</li><li>312</li><li>321</li></ul><p><strong>对于编程题,拿个笔,在纸上画一画,比用脑子空想好很多!好比列乘法竖式,空想肯定比列竖式困难!</strong></p><p>分析图如下:</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647919093480-image.png"></p><p>对于组合来说,人为规定一种顺序,这个顺序对于一个集合来说,只有一个方案满足,这样在枚举的时候,就可以保证不重复了</p><ul><li>枚举顺序:通常规定从小到大排序,即保持升序选择.</li></ul><ul><li>枚举方案:依次枚举每个位置上的数字是几.</li></ul><p>递归枚举组合类型的搜索树,如下:</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647926392765-image.png"></p><p><strong>整体思路:</strong></p><ol><li><p>需要想,如何把搜索问题的顺序变成搜索树的顺序.</p></li><li><p>需要想,如何把树的形式转化成代码(核心:想dfs的参数是什么).<br>参数:全局变量 / 形参</p></li></ol><p>参数1:存放三个位置,开一个数组way[N](方案)<br>参数2:当前该枚举哪个位置, u<br>参数3:当前最小可以从哪个数开始枚举(因为我们要保证比前面一个数大),start</p><p><strong>时间复杂度分析:</strong></p><p>从n个数中选m个的方案数,组合数在何处取最值呢?中间点!方案数大致17 + 8</p><p>17! / 8!9! = 24310</p><p>输出方案再加上一个O(n),大概二十多万的时间复杂度</p><p>之前说过,时间复杂度在一个亿以内都可以.</p><p><strong>注意点:</strong></p><p><code>const int N = 30;</code></p><p><em>数组开大一点,是为了防止数组越界,比方说,虽然长度是10000,可能用到a[10000],但a[10000]其实是第10001个数,因为下标从0开始.为了防止这些比较恶心的边界问题,不妨多开一些.</em></p><p><code>dfs(int u, int start)</code><br>mian函数内:<br><code>dfs(1, 1); </code></p><p>dfs三个参数,由于way是全局变量,就不用传了.从第一个数开始枚举</p><p><code>if (u == m + 1)</code><br><strong>u为1的时候,选了第一个数(way[1]=1),u为2的时候,选了第2个数(way[2]=2),u为3的时候,选了第3个数(way[3]=3),当往下执行<code>dfs(4,4)</code>时,此时<code>u = 4,m = 3</code>触发了退出条件<code>u = m + 1</code>,就直接输出结果(遍历way数组.tips:进入下次dfs后,新值会覆盖旧值)了!</strong></p><p><strong>Debug,yyds!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    way[u] = i;</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">    way[u] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>way[u] = 0</code><br>恢复现场,每个点往下走的时候要公平,向下走的时候要保证这个点是空的,可以用0来表示空</p><p>优化:</p><p><strong>剪枝:如果发现这个分支里面是没有解的,就可以提前退出.</strong></p><p>如到4分支,发现是无解的,提前退出,就可以少搜一些节点,效率会高一些.</p><p>正在选第u个数,说明已经选了u-1个数,后面可以从start选到n,如果把从start到n全部选上都不够m个数的话,说明就无解了.</p><p>从start到n,总共有n-start+1个数,</p><p>综上,可列式子:</p><p>u-1+n-start+1 &lt; m</p><p>整理得:</p><p>u+n-start &lt; m</p><p>即<code>if (u+n-start &lt; m) return; //剪枝 如果把后面所有数都选上,都不够m个,当前分支就一定无解. </code></p><p>满足如上条件,就可以提前退出了.</p><p><strong>经过优化,速度快了三倍多.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30</span>; <span class="comment">// 数组开大一点,是为了防止数组越界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> way[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u<span class="number">-1</span>+n-start+<span class="number">1</span> &lt; m) <span class="keyword">return</span>; <span class="comment">// 剪枝 如果把后面所有数都选上,都不够m个,当前分支就一定无解.</span></span><br><span class="line">    <span class="keyword">if</span> (u == m + <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, way[i]); <span class="comment">// way原有的值会在进入下次dfs后,被新的值覆盖掉</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举n个分支</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n;  i ++ ) <span class="comment">// start的值,代表了各个分支</span></span><br><span class="line">    &#123;</span><br><span class="line">        way[u] = i; </span><br><span class="line">        <span class="built_in">dfs</span>(u + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// 注意是i+1,而不是start+1.因为只有i+1才能更新不同分支的起点,例如1-&gt;2  1-&gt;3  1-&gt;4 而start+1恒为1-&gt;2  </span></span><br><span class="line">        <span class="comment">// 考虑下一个坑,并将起点后移一位(保持升序)</span></span><br><span class="line">        way[u] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><p>思维量真的是很大.画图可以帮助思考逻辑.</p><p>递归三部曲:</p><ol><li>找整个递归的终止条件：递归应该在什么时候结束？</li><li>找返回值：应该给上一级返回什么信息？</li><li>本级递归应该做什么：在这一级递归中，应该完成什么任务？</li></ol><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642117816987-image.png"></p><p>本题中,</p><ol><li>终止条件是坑都被填满了,即<code>u == m + 1</code>.以及萝卜不够的情况(剪枝)</li></ol><p><em>注意:等号千万不要写成赋值号!</em></p><ol start="2"><li>返回值是坑填满后,所有坑中的不同萝卜.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(u<span class="number">-1</span>+n-start+<span class="number">1</span> &lt; m) <span class="keyword">return</span>; <span class="comment">// 剪枝 如果把后面所有数都选上,都不够m个,当前分支就一定无解.</span></span><br><span class="line"><span class="keyword">if</span> (u == m + <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, way[i]); <span class="comment">// way原有的值会在进入下次dfs后,被新的值覆盖掉</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>本级递归应该完成,枚举这个坑,可以填多少个不同的萝卜,且保持升序选择.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n;  i ++ ) <span class="comment">// start的值,代表了各个分支</span></span><br><span class="line">&#123;</span><br><span class="line">    way[u] = i; </span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// 注意是i+1,而不是start+1.因为只有i+1才能更新不同分支的起点,例如1-&gt;2  1-&gt;3  1-&gt;4 而start+1恒为1-&gt;2</span></span><br><span class="line">    <span class="comment">// 考虑下一个坑,并将起点后移一位(保持升序)</span></span><br><span class="line">    way[u] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647936456267-FF8B7E54249B5A50091F3AABD22F8C72.png"></p><h3 id="1209-带分数"><a href="#1209-带分数" class="headerlink" title="1209. 带分数"></a>1209. 带分数</h3><p><a href="https://www.acwing.com/problem/content/1211/">传送门</a></p><ol><li><p>枚举全排列时间复杂度n!*n(后面这个n为输出方案的复杂度)</p></li><li><p>枚举位数,以九个位置为例,有八个空挡,要放两个板子,时间复杂度C82,</p></li></ol><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647939730121-image.png"></p><p>九千多万的复杂度,是ok的.因为这个算法常数很小.</p><p>常数 约等于 代码量.</p><p>所以这种做法,刚刚好可以够.</p><p><strong>空间复杂度的计算:</strong></p><p>1Byte(字节/B) = 8bit(位/b)</p><p>char = 1Byte<br>int = 4Byte<br>float = 4Byte<br>double = 8Byte<br>long long = 8Byte</p><p>64MB = 64M Byte<br>64 * 2^20 Byte (2^20 约= 10^6)<br>(6.4 * 10^7个Byte) / 4 = 1.6*10^7个int</p><p>题目给64M,用到60M就差不多了就极限了,因为会有别的开销.</p><p><strong>另外,程序中数组并不是开多大,就会占多少空间,操作系统会给我们做优化,如果开一个很大数组但是不用的话,它也是不会占空间的.</strong></p><p><strong>这题学到的小技巧</strong></p><ol><li>取每一位数字<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x = a % <span class="number">10</span>; <span class="comment">// 取个位</span></span><br><span class="line">  a /= <span class="number">10</span>; <span class="comment">// 个位删掉</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>memset(arr, 0, sizeof arr)</code></li></ol><p>参数1:数组名<br>参数2:值<br>参数3:数组大小</p><p>效果:把arr的每一个字节都变成0.</p><p><code>memcpy(arr, arr1, sizeof arr1)</code><br>参数1:第一个数组<br>参数2:第二个数组<br>参数3:一个长度</p><p>效果:把从arr1开始的,长度为<code>sizeof arr1</code>的一段内容,复制到前面的arr数组</p><ol start="3"><li><code>next_permutation</code>生成全排列.</li></ol><p><a href="https://blog.csdn.net/qq_43488547/article/details/100032724">知识点详解传送门</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;num[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;num[<span class="number">2</span>]&lt;&lt;endl;  </span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(num,num+<span class="number">3</span>));  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>为什么要写成do，while，不直接写while，无条件先执行一次的目的是什么呢?</p><p><em>因为你初始化的时候数组是一种情况，直接全排列的话第一种情况直接就少掉了!do.while是用 next_permutation() 的一个固定方式。</em></p><p><strong>函数返回值:当前序列不存在下一个排列时，函数返回false，否则返回true</strong></p><p>当我们把while(next_permutation(num,num+3))中的3改为2时，输出就变为了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><p>由此可以看出，next_permutation(num,num+n)<strong>函数是对数组num中的前n个元素进行全排列，同时并改变num数组的值。</strong></p><p>另外，需要强调的是，next_permutation（）在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组num初始化为2,3,1，那么输出就变为了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>此外，next_permutation（node,node+n,cmp）可以对结构体num按照自定义的排序方式cmp进行排序。</p><hr><p>综上,本题思想如下:</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647949766945-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> target;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">// 将l~r之间的数拼起来</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++ ) <span class="comment">// 初始化数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// 记录可行方案数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全排列暴搜</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">9</span>; j ++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="built_in">calc</span>(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">int</span> b = <span class="built_in">calc</span>(i + <span class="number">1</span>, j);</span><br><span class="line">                <span class="keyword">int</span> c = <span class="built_in">calc</span>(j + <span class="number">1</span>, <span class="number">8</span>); <span class="comment">// 下标从0开始,最后一位是8</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span> || c == <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a * c + b == target * c) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(num, num + <span class="number">9</span>));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><p>通过<code>next_permutation</code> 枚举出每一个全排列,并通过两重for循环(两块板子)对每一种方案的九个数字进行分割,并通过一个拼数的小算法,把拼好的数字进行判断,是否满足题目等式要求,对于题中的要求,可以同乘一个c,使得除法变乘法,从而更方便的判断!</p><p>太爽了!</p><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><ul><li>递归是把一个问题,分解成若干个子问题.即自顶向下.</li></ul><p><em>想f(n)怎么做,等于f(n-1)+f(n-2).</em></p><ul><li>递推是自底向上.</li></ul><p><em>先算出来f(n-1)和f(n-2),再算f(n),也就是从1算到n.</em></p><p>tips:对于评测来说最后一个回车加不加都可以过.<br><code>cout &lt;&lt; endl</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n; </span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">46</span>];</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>, f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i ++ ) f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; f[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化:<strong>滚动变量</strong></p><p>不开辟数组,用一个变量fn表示两个数的相加.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">代码:</span><br><span class="line">```c++</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int n; </span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    int a = 0, b = 1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i ++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt;&quot; &quot;;</span><br><span class="line">        int fn = a + b;</span><br><span class="line">        a = b; b = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:<br>滚动变量太妙了.</p><h3 id="95-费解的开关"><a href="#95-费解的开关" class="headerlink" title="95. 费解的开关"></a>95. 费解的开关</h3><p><a href="https://www.acwing.com/problem/content/97/">传送门</a></p><p>一行五个格子,可以枚举出2^5个方案,总共2^25个,三千多万了.飞行员那题2^16才六万多,所以直接暴力枚举所有选法.</p><p>初始状态:<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647954793403-image.png"></p><p>坐标轴心左上角,向右y轴,向下x轴</p><p>为什么这么规定呢?因为符合平时使用数组习惯,数组第一行,第二行…</p><p>在(1, 5)按一下,变成:<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647954895848-image.png"></p><p>第二步,在(2, 5)按一下,就全亮了</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-22/1647954950566-image.png"></p><p>解题性质:</p><ol><li>顺序可以任意.</li></ol><p><em>只与格子被按的次数有关,按两次相当于没按,和顺序无关.</em></p><ol start="2"><li>每个格子最多按一次.</li></ol><p><em>按两次相当于没按,且平白无故多出一步</em></p><ol start="3"><li>每一行开关的操作,完全被前一行灯的亮灭状态所唯一确定.</li></ol><p><strong>做事先宏观考虑,再商定细节.</strong></p><p><strong>1. 如何枚举第一行的操作?</strong></p><p>方法一:一个指数类型枚举.</p><p>方法二:<em>状态压缩</em>!(每一个二进制的操作都可以对应一个十进制的数,如11010对应26)</p><p>五位二进制,可以对应0<del>2^5-1即0</del>31之间的数.即0~31可以一一对应这32种方案中的每一个方案.因此在枚举状态时,只需要用一个for循环:<code>for(int i = 0; i &lt; 32; i ++ )</code>,从0枚举到31即可.</p><p>当我们想看每一位是不是应该操作的时候,只需要看一下i的二进制的某一位是不是1即可!!比方说,看一下第二个开关应不应该操作,只需要看一下i的二进制表示的第二位是不是1就可以了.</p><p>怎么看呢?有个小技巧:</p><p><strong>想看i的第k位数字是不是1,只需要i右移k位与上1即可.</strong></p><p><code>i &gt;&gt; k &amp; 1</code></p><p>43210(位数:高位-&gt;低位)</p><p>11010 想看第1位是不是1,</p><ul><li>11011右移一位得到1101</li><li>取最低位数字1 &amp; 1 = 1 说明第1位上是1</li></ul><p><strong>2. turn(x, y)</strong></p><p>如何把上下左右中这五个数都变一下呢?</p><p>可以写五句话,但不够优雅</p><p>可以定义一下偏移量即可.</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-23/1648002068583-image.png"></p><p><strong>3. 时间复杂度</strong></p><p>32(第一行32种情况) * 25(格子) * 5(按或不按) * 500(数据量) = 200w &lt;&lt; 1亿 是ok的.</p><p><strong>Tips:</strong></p><p><code>const int N = 6;</code></p><p>字符串最后有一个<code>\0</code>,所以,一个长度为五的字符串实际上需要六位,所以多开一个.</p><p><code>memcpy(backup, g, sizeof g);</code> // 备份</p><p>把原始数组备份一下,然后操作g,操作完了还原,然后再操作.</p><p><code>memcpy(g, backup,sizeof backup);</code> // 还原</p><p>‘0’的ASCLL码为:48  即110000<br>‘1’的ASCLL码为:49  即110001</p><p><strong>想改变状态,异或一个1就可以了.</strong></p><p><code>a ^= 1 即 a = a ^ 1</code></p><p>Debug时,先通读一遍代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> dx[N] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[N] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;; <span class="comment">// 顺序:上右下左中(坐标原点左上角,x轴向下,y轴向右)</span></span><br><span class="line"><span class="keyword">char</span> g[N][N], backup[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个操作是把(x, y)以及上右下左中的灯都变成相反的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果在边界外边，直接忽略即可</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt;= <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        g[a][b] ^= <span class="number">1</span>;   <span class="comment">//异或，不同的时候就变成相反的数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按行输入，把每一行当成一个字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) cin &gt;&gt; g[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里我们枚举了第一行的32种按法，不用管是亮是灭，把第一行所有情况都按一遍</span></span><br><span class="line">        <span class="comment">// 按每种情况的第一行，去遍历接下来的行</span></span><br><span class="line">        <span class="comment">// 枚举32种第一行的按法只是可能会减少步数，如果直接从第二行开始答案一定是固定的了，找不到最优解或者可能没有解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> op = <span class="number">0</span>; op &lt; <span class="number">32</span>; op ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 我们在对这种情况操作的时候，得先备用一下</span></span><br><span class="line">            <span class="comment">// 把原始数组备份一下，然后操作g，操作完了还原，然后再操作</span></span><br><span class="line">            <span class="built_in">memcpy</span>(backup, g, <span class="keyword">sizeof</span> g);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一行的按法(在这里 1 表示按了, 0 表示不按)，这里只是为了输出第一行按完之后的状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">                <span class="keyword">if</span> (op &gt;&gt; i &amp; <span class="number">1</span>)  <span class="comment">// 数字2 对应了 00010 表示第2个位置的按一下</span></span><br><span class="line">                                  <span class="comment">// 00010 &gt;&gt; 1 &amp; 1  是1 所以turn(0, 1) 就是第一行第二个位置</span></span><br><span class="line">                &#123;                 <span class="comment">// 数字3 对应了00011 表示第1 和第2个位置的按一下</span></span><br><span class="line">                    step ++ ;</span><br><span class="line">                    <span class="built_in">turn</span> (<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后通过第一行按完之后的状态，按234行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>;j ++ )</span><br><span class="line">                    <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        step ++;</span><br><span class="line">                        <span class="built_in">turn</span> (i + <span class="number">1</span>, j);  <span class="comment">// 如果这个位置是灭的，就按下一行对应的位置</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> dark = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (g[<span class="number">4</span>][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dark = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于32种情况的这一种，如果所有的全亮就记录下步数(事实上只记录了最后一行是否dark)</span></span><br><span class="line">            <span class="keyword">if</span> (!dark) res = <span class="built_in">min</span>(res, step);</span><br><span class="line">            <span class="built_in">memcpy</span> (g, backup, <span class="keyword">sizeof</span> g);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res &gt; <span class="number">6</span>) res = <span class="number">-1</span>;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="翻硬币"><a href="#翻硬币" class="headerlink" title="翻硬币"></a>翻硬币</h3><p><strong>经过几步，可以把初始状态转换成另一个状态 =&gt; BFS</strong></p><p>等价于求两个点之间的最短距离！由于所有边的权值都是1，所以最常用的做法是BFS.</p><p>棋盘的局面不大的时候，才可以用宽搜，因为假设每一步操作有四种选择，进行100次操作，4^100，直接炸裂。</p><p>本题字符串长度最多100，每一步最多有99种选择，起码50步做完，时间复杂度50^99，<strong>是不可接受的</strong>。</p><p><strong>没想法的话，模拟一下很重要！！！可以帮助找一下思路！</strong><br>能控制第一个灯泡的，只有第一个开关，第二个灯泡同理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-3-23/1648028524002-image.png"></p><p><strong>在开关只按一次的情况下，只要有解，那肯定是唯一一组解。只要前面状态是确定的，后面状态也是唯一确定的。所以，本题不是一个最优化的问题，而是一个模拟的问题。</strong></p><p><strong>思路：</strong></p><p>从前往后地推就可以了。看一下第一个灯泡一不一样，一样的话，就考虑下个灯泡，不一样，就把相邻两个灯泡变一下。</p><p>以此类推，每一次看一下这个灯泡和最终状态是不是一样的。如果不一样，就把当前灯泡和下一个灯泡变一下，最后统计一下变了多少次就行。</p><p><strong>时间复杂度分析：</strong></p><p>字符串长度都是100，复杂度是O(n)，线性扫了一遍，100的复杂度非常小。</p><p><strong>Tips:</strong></p><ul><li>strlen(str);<br>功能：函数返回字符串str 的长度( 即空值结束符’\0’之前字符数目)。</li></ul><p>区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char s[N] = &#123;&quot;lskddjflaksdf&quot;&#125;;</span><br><span class="line">string s1 = &quot;laksjdflkjsdlkfjs&quot;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout  &lt;&lt; strlen(s) &lt;&lt; endl; // 13</span><br><span class="line">    cout  &lt;&lt; s1.length() &lt;&lt; endl; // 17</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要扫描到n - 1即可，因为保证有解，那么最后一个字符一定相等，不想等的话，就一定无解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> start[N], aim[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start[i] == <span class="string">&#x27;*&#x27;</span>) start[i] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> start[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; start &gt;&gt; aim;</span><br><span class="line">    n = <span class="built_in">strlen</span>(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (start[i] != aim[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">turn</span>(i), <span class="built_in">turn</span>(i + <span class="number">1</span>);</span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>turn函数的写法，扫描的写法，值得反复学习！</strong></p><h3 id="飞行员"><a href="#飞行员" class="headerlink" title="飞行员"></a>飞行员</h3><p>本质上是开关问题，有以下特点：</p><ol><li>只按一次</li><li>顺序无关紧要</li></ol><p>区别：</p><p><strong>此前的灯泡只能被一个开关影响，本题的灯泡可以被所在行、列的开关所影响。</strong></p><p>所以说，不能用递推的方法求解。</p><p>本题 <strong>时间复杂度</strong>：4*4=16  2^16 = 65536</p><p>2^16(这么多种方案）* 【16(会枚举16个开关)*7（每个开关需要操作7个灯泡） + 16（判断一下每个灯泡的状态）+ 16(如果全亮，记录方案）】</p><p>注：后面的三个环是并列的关系，加起来即可。</p><p>思路：</p><ol><li>直接暴力枚举所有方案。</li></ol><p><em>之前费解的开关枚举了第一行的状态，利用二进制的方式。本题同理，需要枚举0 ~ 2^16 - 1，这里面的每一个数，把它看成16位的二进制数，1表示按它，0表示不按</em></p><ol start="2"><li><p>按照该方案对所有灯泡进行操作。</p></li><li><p>判断灯泡是否全亮 =&gt; 记录方案</p></li></ol><p><em>即改变一下原始的灯泡的状态，如果可以把所有的灯泡变成‘-’，就说明这个方案是合法的。再统计一下这个方案里面需要按的开关的数量，并在所有的数量里面取一个最小值就可以了。<br>如果两个方案 操作步数相同，则返回字典序最小（先按照横坐标排序，如果相同的话，按照纵坐标排序）的方案即可。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何准备蓝桥杯比赛&quot;&gt;&lt;a href=&quot;#如何准备蓝桥杯比赛&quot; class=&quot;headerlink&quot; title=&quot;如何准备蓝桥杯比赛&quot;&gt;&lt;/a&gt;如何准备蓝桥杯比赛&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;要有一定刷题量&lt;br&gt;若想在省赛中取得较好成绩，建议做200题左右</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="蓝桥杯" scheme="http://example.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://example.com/2022/01/24/%E8%B4%AA%E5%BF%83/"/>
    <id>http://example.com/2022/01/24/%E8%B4%AA%E5%BF%83/</id>
    <published>2022-01-24T11:58:31.000Z</published>
    <updated>2022-01-28T12:38:32.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单贪心"><a href="#简单贪心" class="headerlink" title="简单贪心"></a>简单贪心</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-24/1643025792683-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-24/1643025851353-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-24/1643025864065-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-24/1643025881106-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mooncake</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> sell; <span class="comment">// 售价 </span></span><br><span class="line"><span class="keyword">double</span> store; <span class="comment">// 库存 </span></span><br><span class="line"><span class="keyword">double</span> price; <span class="comment">// 单价 </span></span><br><span class="line">&#125;cake[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(mooncake a, mooncake b)</span> </span>&#123; <span class="comment">// 单价降序 </span></span><br><span class="line"><span class="keyword">return</span> a.price &gt; b.price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">0</span>; <span class="comment">// 月饼种类</span></span><br><span class="line"><span class="keyword">double</span> D = <span class="number">0</span>; <span class="comment">// 市场最大需求量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>,&amp;N,&amp;D);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">// 库存 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;cake[i].store);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">// 售价 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;cake[i].sell);</span><br><span class="line">cake[i].price = cake[i].sell / cake[i].store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按单价降序排序 </span></span><br><span class="line"><span class="built_in">sort</span>(cake, cake + N, cmp);</span><br><span class="line"><span class="comment">// 贪心</span></span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>; <span class="comment">// 总售价 </span></span><br><span class="line"><span class="comment">// 如果库存够，直接增加总售价。不够，</span></span><br><span class="line"><span class="comment">// 则增加总售价后，全部减去一种库存，看下一种产品 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cake[i].store &gt;= D) &#123; <span class="comment">// 库存够 </span></span><br><span class="line">ans += cake[i].price * D;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 库存不够 </span></span><br><span class="line">ans += cake[i].sell;</span><br><span class="line">D -= cake[i].store;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>自定义排序cmp的写法需熟记</li><li>printf和scanf包含在<cstdio>，效率比cin、cout高</li><li>数据的读入，输出</li><li>贪心的逻辑：找单价最高的月饼，若库存够，直接增加总售价；不够，全部减去一种的库存后，增加总售价，看单价其次的月饼。</li></ul><hr><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-24/1643028179144-image.png"><br>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count[<span class="number">10</span>]; <span class="comment">// 记录数字0~9的个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;count[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 从1~9中选择count不为0的最小数字 </span></span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i); <span class="comment">// 是 i 不是count[i]  // 是 i 不是count[i] </span></span><br><span class="line">count[i]--;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 找到一个之后就中断 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 从0~9输出对应个数的数字 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i); <span class="comment">// 是 i 不是count[i] </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 3 0 2 0 0 0 4 0 1 1</span></span><br><span class="line"><span class="comment">// 20002666689</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>注意输出 i 而不是count[i]，输出数字本身，而不是其数量！</li><li>break别忘了</li></ul><hr><h1 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-24/1643030882483-image.png"></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y; <span class="comment">// 开区间左右端点 </span></span><br><span class="line">&#125;I[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(Inteval a, Inteval b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.x != b.x) <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">// 先按左端点从大到小排序</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.y &lt; b.y; <span class="comment">// 左端点相同的按右端点从小到大排序 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 区间个数 </span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;I[i].x, &amp;I[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span> (I, I + n, cmp);  <span class="comment">// 把区间排序</span></span><br><span class="line"><span class="comment">// ans记录不相交区间个数，lastX记录上一个被选中区间的左端点 </span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>, lastX = I[<span class="number">0</span>].x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (I[i].y &lt;= lastX) &#123; <span class="comment">// 如果该区间右端点在lastX左边</span></span><br><span class="line">lastX = I[i].x; <span class="comment">// 以I[i]作为新选中的区间 </span></span><br><span class="line">ans++; <span class="comment">// 不相交区间个数加1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3  // 区间个数 </span></span><br><span class="line"><span class="comment">// 1 3 4 6 2 5  // 区间左右端点 </span></span><br><span class="line"><span class="comment">// 2  // 结果：共有俩不相交区间 </span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>重写cmp需要考虑左右端点两种情况</li><li>using namespace std; 没加，找了好久的错</li><li>while里面语句非常好，既完成了区间个数的读入，也完成了判断空区间。</li><li>贪心体现在lastX语句那边</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-25/1643077823381-image.png"></p><hr><h1 id="蓝桥杯真题"><a href="#蓝桥杯真题" class="headerlink" title="蓝桥杯真题"></a>蓝桥杯真题</h1><h2 id="题目-1453-蓝桥杯历届试题-翻硬币"><a href="#题目-1453-蓝桥杯历届试题-翻硬币" class="headerlink" title="题目 1453: 蓝桥杯历届试题-翻硬币"></a>题目 1453: 蓝桥杯历届试题-翻硬币</h2><p><a href="https://www.dotcpp.com/oj/problem1453.html">题目 1453: 蓝桥杯历届试题-翻硬币</a></p><p>思路：从0开始进行遍历，找到两个当前状态与目标状态不同的硬币，然后通过第二个硬币的下标减去第一个硬币的下标即为需要翻动的次数，然后第二个硬币及其之前的所有硬币状态均与目标状态相同，继续往下遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">// 用到abs() </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// flag作为标记，先减第一个硬币下标，再加上第二个硬币下标 &lt;=&gt; 第二个下标 - 第一个下标 </span></span><br><span class="line">string str, ch; <span class="comment">// 初始串，目标串 </span></span><br><span class="line">cin &gt;&gt; str &gt;&gt; ch;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch[i] != str[i]) &#123; </span><br><span class="line">cnt = cnt + flag * i; <span class="comment">// 所有次数加起来即为所需翻动的次数</span></span><br><span class="line">flag = flag*(<span class="number">-1</span>); <span class="comment">// 减号变加号！ </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">abs</span>(cnt); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">asasas</span></span><br><span class="line"><span class="comment">aaaaaa</span></span><br><span class="line"><span class="comment">cnt = cnt - 1 = -1</span></span><br><span class="line"><span class="comment">cnt = cnt + 3 = 2  </span></span><br><span class="line"><span class="comment">cnt = cnt - 5 = -3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p><strong>将两位置下标之差转换为：先减第一个下标，再加上第二个下标。（flag = -1，每找到一个不同的字符后，反转flag符号（乘上一个-1）</strong></p></li><li><p>cin输入俩字符串s1, s2，直接<code>cin &gt;&gt; s1 &gt;&gt; s2</code>即可    </p></li><li><p>第一轮找出俩不同后，算出翻动次数（=&gt;下标之差），随后继续向下遍历。</p></li><li><p>abs() 包含在 &lt;algorithm&gt; 中</p><hr><h2 id="题目-2229-蓝桥杯算法训练-最大最小公倍数"><a href="#题目-2229-蓝桥杯算法训练-最大最小公倍数" class="headerlink" title="题目 2229: 蓝桥杯算法训练-最大最小公倍数"></a>题目 2229: 蓝桥杯算法训练-最大最小公倍数</h2><p><a href="https://www.dotcpp.com/oj/problem2229.html">题目 2229: 蓝桥杯算法训练-最大最小公倍数</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum, n; <span class="comment">// sum为输出的最大最小公倍数，n为输入的数字</span></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">cout &lt;&lt; n;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// n为偶数 </span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123; </span><br><span class="line">sum = (n<span class="number">-1</span>) * (n<span class="number">-2</span>) * (n<span class="number">-3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不被3整除，n-2会被3整除，会造成最小公倍数变小。 </span></span><br><span class="line">sum = n * (n<span class="number">-1</span>) * (n<span class="number">-3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// n为奇数，则直接sum = n*(n-1)*(n-2)</span></span><br><span class="line">sum = n * (n<span class="number">-1</span>) * (n<span class="number">-2</span>); </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>这题要分奇偶讨论 </p></li><li><p>当n为奇数，那么n,n-1互质；n-1,n-2互质；所以，当n为奇数时，最大最小公倍数为n(n-1)(n-2)；</p></li><li><p>当n为偶数时有2种情况：</p><p>   n%3!=0,最大最小公倍数为n(n-1)(n-3);</p><p>   n%3==0,最大最小公倍数为(n-1)(n-2)(n-3)。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单贪心&quot;&gt;&lt;a href=&quot;#简单贪心&quot; class=&quot;headerlink&quot; title=&quot;简单贪心&quot;&gt;&lt;/a&gt;简单贪心&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/r2peak/picture/raw/master/2022-1-2</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>甘心吗？</title>
    <link href="http://example.com/2022/01/22/%E7%94%98%E5%BF%83%E5%90%97%EF%BC%9F/"/>
    <id>http://example.com/2022/01/22/%E7%94%98%E5%BF%83%E5%90%97%EF%BC%9F/</id>
    <published>2022-01-22T11:08:26.000Z</published>
    <updated>2022-01-22T11:17:05.653Z</updated>
    
    <content type="html"><![CDATA[<p>今天他们都在劝他改目标。</p><p>他苦笑着说，去他妈的命，老子不信！</p><p>“我这个人是搞什么学什么，我有这个能力。”</p><p>“你不担心做不成吗？”</p><p>”我不管。“</p><p>——钱伟长</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天他们都在劝他改目标。&lt;/p&gt;
&lt;p&gt;他苦笑着说，去他妈的命，老子不信！&lt;/p&gt;
&lt;p&gt;“我这个人是搞什么学什么，我有这个能力。”&lt;/p&gt;
&lt;p&gt;“你不担心做不成吗？”&lt;/p&gt;
&lt;p&gt;”我不管。“&lt;/p&gt;
&lt;p&gt;——钱伟长&lt;/p&gt;
</summary>
      
    
    
    
    <category term="随笔录" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94%E5%BD%95/"/>
    
    
    <category term="随感" scheme="http://example.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++中的STL</title>
    <link href="http://example.com/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/"/>
    <id>http://example.com/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/</id>
    <published>2022-01-18T04:27:31.000Z</published>
    <updated>2022-01-23T08:41:15.964Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-18/1642504703480-image.png"></p><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>&emsp;&emsp;vector 翻译为向量，但是这里使用“<strong>变长数组</strong>”的叫法更容易理解，也即“长度根据需要而自动改变的数组”。在考试题中，有时会碰到只用普通数组会超内存的情况，这种情况使用 vector 会让问题的解决便捷许多。另外， vector 还可以用来以邻接表的方式储存图，这对无法使用邻接矩阵的题目（结点数太多）、又害怕使用指针实现邻接表的读者是非常友好的，写法也非常简洁。</p><p><strong>常见用途：</strong></p><p><em>1. 储存数据</em></p><p><em>① vector 本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。</em></p><p><em>② 有些场合需要根据一些条件把部分数据输出在同一行，数据中间用空格隔开。由于输出数据的个数是不确定的，为了更方便地处理最后一个满足条件的数据，后面不输出额外的空格，可以先用 vector 记录所有需要输出的数据，然后一次性输出。</em></p><p><em>2. 用邻接表存储图</em></p><p><em>使用 vector 实现邻接表可以让一些对指针不太熟悉的读者有一个比较方便的写法。具体见《算法笔记》10.2.2 节。</em></p><p><strong>vector 常用函数概览：</strong></p><ol><li>push_back()：在 vector 后面添加一个元素，O(1)</li><li>size()：用于获取 vector 中元素个数，O(1)</li><li>pop_back()：删除 vector 尾部元素，O(1)</li><li>insert(it, x)：用于向 vector 的任意迭代器 it 处插入一个元素，O(N)</li><li>erase()：删除单个元素 / 一个区间内所有元素，均为 O(N)。① 删除单个元素 vi.erase(vi.begin() + 2); 即删除第三个位置上的元素；② erase(first, last) 即删除 [first, last)内所有元素</li><li>clear()：用于清空 vector 中所有元素，O(N)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_back()：在vector后面添加一个元素，O(1)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//size()：用于获取vector中元素个数，O(1)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop_back()：删除vector尾部元素，O(1)</span></span><br><span class="line">vi.<span class="built_in">pop_back</span>(); <span class="comment">// 删除vi尾元素 9</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// insert(it, x)：用于向vector的任意迭代器it处插入一个元素，O(N)</span></span><br><span class="line">vi.<span class="built_in">insert</span>(vi.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">-1</span>); <span class="comment">// 将-1插入到vi[2]的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 -1 2 3 4 5 6 7 8</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase()：删除单个元素 / 一个区间内所有元素，均为O(N)</span></span><br><span class="line"><span class="comment">// 1、删除单个元素</span></span><br><span class="line">vi.<span class="built_in">erase</span>(vi.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 2、erase(first, last) 即删除 [first, last)内所有元素</span></span><br><span class="line">vi.<span class="built_in">erase</span>(vi.<span class="built_in">begin</span>() + <span class="number">1</span>, vi.<span class="built_in">end</span>() - <span class="number">3</span>);  <span class="comment">// 0 6 7 8</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear()：用于清空vector中所有元素，O(N)</span></span><br><span class="line">vi.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; vi.<span class="built_in">size</span>();  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set 翻译为集合，是一个<strong>内部自动有序（递增排序）</strong>且<strong>不含重复元素</strong>的容器。</p><p>需要注意的是，<strong>除了 vector 和 string 之外的 STL 容器都不支持*(it+i)的访问方式。</strong></p><p><strong><em>常见用途：</em></strong></p><p><em>set 最主要的作用是自动去重并按升序排序，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用 set 解决。</em></p><p><em>延伸：set 中元素是唯一的，如果需要处理不唯一的情况，则需要使用 multiset。另外，C++11 标准中还增加了<strong>unordered_set</strong>，以散列代替 set 内部的红黑树（ Red Black Tree，一种自平衡二叉査找树）实现，使其可以用来处理<strong>只去重但不排序</strong>的需求，速度比 set 要快得多。</em></p><p><strong>set 常用函数概览：</strong></p><ol><li>insert() O(logN) N 为 set 内元素个数</li><li>find() O(logN)</li><li>erase()① 删除单个元素。方式一：通过迭代器，时间复杂度为：O(1)。方式二：通过 value ，时间复杂度为：O(logN)。 ② 删除区间元素 （通过迭代器确定删除位置）</li><li>size() O(1)</li><li>clear O(N) 清空 set</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert O(logN) N为set内元素个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">st.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//find O(logN)</span></span><br><span class="line"><span class="comment">// set&lt;int&gt;::iterator it = st.find(2); // 在set中查找2，返回其迭代器</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; *it &lt;&lt;endl;</span></span><br><span class="line">cout&lt;&lt;*(st.<span class="built_in">find</span>(<span class="number">2</span>))&lt;&lt;endl; <span class="comment">// 等价于上面两句  // 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// erase</span></span><br><span class="line"><span class="comment">// 1、删除单个元素</span></span><br><span class="line">st.<span class="built_in">erase</span>(st.<span class="built_in">find</span>(<span class="number">3</span>)); <span class="comment">// 通过迭代器 O(1)</span></span><br><span class="line">st.<span class="built_in">erase</span>(<span class="number">4</span>); <span class="comment">// 通过 value O(logN)</span></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++) &#123; <span class="comment">// 遍历</span></span><br><span class="line">cout &lt;&lt;*(it)&lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 2、删除区间元素</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">find</span>(<span class="number">6</span>);</span><br><span class="line">st.<span class="built_in">erase</span>(it, st.<span class="built_in">end</span>()); <span class="comment">// 删除6~9区间元素</span></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = st.<span class="built_in">begin</span>(); it != st.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt;*(it)&lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 5</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// size O(1)</span></span><br><span class="line">cout &lt;&lt; st.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear O(N) 清空set</span></span><br><span class="line">st.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">size</span>(); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>&emsp;&emsp;在 C 语言中，一般使用字符数组 char strl 来存放字符串，但是使用字符数组有时会显得操作麻烦，而且容易因经验不足而产生一些错误。为了使编程者可以更方便地对字符串进行操作，C++在 STL 中加入了 string 类型，对字符串常用的需求功能进行了封装，使得操作起来更方便，且不易出错。</p><p>string 函数概述：</p><ol><li><p>string 的定义</p></li><li><p>string 中内容的访问<br>（1）通过下标访问（可直接像字符数组那样去访问 string）<br>（2）通过迭代器访问<br>注意：若要读入和输出整个字符串，只能用 cin 和 cout</p></li></ol><p><strong>3. string 常用函数</strong></p><p>（1）operator+= 这是 string 的加法，可将 string 直接拼接起来</p><p>（2）compare operator 两个 string 类型可使用== != &lt; &lt;= &gt; &gt;=比较大小 （字典序）</p><p>（3）length() / size() length()返回 string 长度，即存放的字符数，O(1)，二者基本相同</p><p>（4）insert() 两个常用写法，均 O(N)</p><ul><li>insert(pos, string)，在 pos 号位置插入字符串 string。</li><li>insert(it, it2, it3)，it 为原字符串的欲插入位置，it2 和 it3 为待插字符串的首尾迭代器，用来表示串[it2,it3)将被插在 it 的位置上。</li></ul><p>（5） erase() 删除单个元素 / 删除区间元素（两种方法）</p><ul><li>方法一： 迭代器方式</li><li>方法二： str.erase(pos, length) 需要开始删除的起始位置下标，删除字符个数</li></ul><p>（6）clear() 清空 string 中的数据，O(1)</p><p>（7）substr(pos, len) 返回从 pos 号位开始，长度为 len 的子串，O(len)</p><p>（8）string::npos 这是个常数，值为-1 但由于是 unsigned_int 类型 ，因此也可以认为是 unsigned_int 类型的最大值。string::npos 用以作为 find 函数失配时的返回值。<br>可以认为 string::npos 等于-1 或 4294967295</p><p><em>注：4294967295 是计算机程序设计里面的一个值，表示 32 位无符号整数的十进制最大值。如果是 16 进制，那么是 0xFFFFFFFF。也可以解释为一个 IP 地址(V4) 255.255.255.255</em></p><p>（9）find() O(nm) 其中 n 和 m 分别是 str 和 str2 的长度。</p><ul><li>str.find(str2) 当 str2 是 str1 的子串时，返回其在 str 中第一次出现的位置；若 str2 不是 str1 子串，返回 string::npos</li><li>str.find(str2, pos) 从 str 的 pos 号位开始匹配 str2， 返回值与上相同。</li></ul><p>（10）replace() O(str.length())</p><ul><li>str.replace(pos, len, str2)把 str 从 pos 号位开始、长度为 len 的子串替换为 str2。</li><li>str.replace(it1, it2, str2)把 str 的迭代器[it1,it2)范围的子串替换为 str2</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1、string的定义</span></span><br><span class="line">string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、string中内容的访问</span></span><br><span class="line"><span class="comment">// （1）通过下标访问（可直接像字符数组那样去访问string）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125; <span class="comment">// a b c d e f g</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 注意：若要读入和输出整个字符串，只能用 cin 和 cout</span></span><br><span class="line"><span class="comment">//string str1;</span></span><br><span class="line"><span class="comment">//cin &gt;&gt; str1; // ahhh</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; str1 &lt;&lt;endl; // ahhh</span></span><br><span class="line"><span class="comment">// （2）通过迭代器访问</span></span><br><span class="line"><span class="comment">// string不像其它STL容器那样需要参数，可以直接如下定义：</span></span><br><span class="line"><span class="keyword">for</span> (string::iterator it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 通过*it来访问string里的每一位</span></span><br><span class="line">&#125; <span class="comment">// a b c d e f g</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// string和 vector一样，支持直接对迭代器进行加减某个数字，如str. begin()+3的写法是可行的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、string常用函数</span></span><br><span class="line"><span class="comment">// （1）operator+=  这是string的加法，可将string直接拼接起来</span></span><br><span class="line">string str1 = <span class="string">&quot;aaa&quot;</span>, str2 = <span class="string">&quot;bbb&quot;</span>, str3;</span><br><span class="line">str3 = str1 + str2; <span class="comment">// 将str1和str2拼接，赋值给str3</span></span><br><span class="line">str1 += str2; <span class="comment">// 将str2直接拼接到str1上</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt;endl; <span class="comment">// str3 = aaabbb</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt;endl; <span class="comment">// str1 = aaabbb</span></span><br><span class="line"><span class="comment">// （2）compare operator  两个string类型可使用== != &lt; &lt;= &gt; &gt;=比较大小</span></span><br><span class="line">string s1 = <span class="string">&quot;aa&quot;</span>, s2 = <span class="string">&quot;aaa&quot;</span>, s3 = <span class="string">&quot;abc&quot;</span>, s4 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1 &lt; s2) cout &lt;&lt; <span class="string">&quot;ok1&quot;</span> &lt;&lt; endl; <span class="comment">// 如果s1字典序小于s2，输出ok1 // ok1</span></span><br><span class="line"><span class="keyword">if</span> (s1 != s3) cout &lt;&lt; <span class="string">&quot;ok2&quot;</span> &lt;&lt;endl; <span class="comment">// 如果s1和s3不等，输出ok2  // ok2</span></span><br><span class="line"><span class="keyword">if</span> (s4 &gt; s3) cout &lt;&lt; <span class="string">&quot;ok3&quot;</span> &lt;&lt;endl; <span class="comment">// 如果s4字典序大于等于s3，输出ok3  // ok3</span></span><br><span class="line"><span class="comment">// （3）length() / size() length()返回string长度，即存放的字符数，O(1)，二者基本相同</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">// 2</span></span><br><span class="line"><span class="comment">// （4）insert()  两个常用写法，均O(N)</span></span><br><span class="line"><span class="comment">// 1）、insert(pos, string)，在pos号位置插入字符串string。</span></span><br><span class="line">string s = <span class="string">&quot;ad&quot;</span>, ss = <span class="string">&quot;bc&quot;</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>, ss); <span class="comment">//  在s[1]处插入bc，这里ss位置直接写&quot;bc&quot;也可以</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; <span class="comment">// abcd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）、insert(it, it2, it3)</span></span><br><span class="line"><span class="comment">// it为原字符串的欲插入位置，it2和it3为待插字符串的首尾</span></span><br><span class="line"><span class="comment">// 迭代器，用来表示串[it2,it3)将被插在it的位置上。</span></span><br><span class="line">string ss1 = <span class="string">&quot;1245&quot;</span>, ss2 = <span class="string">&quot;3&quot;</span>; <span class="comment">// ss1是原字符串，ss2 是待插字符串</span></span><br><span class="line"><span class="comment">// 在ss1的2号位（即2和4之间）插入 ss2</span></span><br><span class="line">ss1.<span class="built_in">insert</span>(ss1.<span class="built_in">begin</span>() + <span class="number">2</span>, ss2.<span class="built_in">begin</span>(), ss2.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; ss1 &lt;&lt;endl; <span class="comment">// 12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （5） erase() 删除单个元素 / 删除区间元素（两种方法）</span></span><br><span class="line">ss1.<span class="built_in">erase</span>(ss1.<span class="built_in">begin</span>() + <span class="number">1</span>); <span class="comment">// 删除1号位（即2）</span></span><br><span class="line">cout &lt;&lt; ss1 &lt;&lt; endl; <span class="comment">// 1345</span></span><br><span class="line"><span class="comment">// 方法一： 迭代器方式</span></span><br><span class="line">ss1.<span class="built_in">erase</span>(ss1.<span class="built_in">begin</span>() + <span class="number">1</span>, ss1.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 删除[3,5)</span></span><br><span class="line">cout &lt;&lt; ss1 &lt;&lt; endl; <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 方法二： str.erase(pos, length) 需要开始删除的起始位置下标，删除字符个数</span></span><br><span class="line">ss1.<span class="built_in">erase</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; ss1 &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （6）clear() 清空string中的数据，O(1)</span></span><br><span class="line">ss1.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; ss1.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （7）substr(pos, len) 返回从pos号位开始，长度为len的子串，O(len)</span></span><br><span class="line">string sss1 =  <span class="string">&quot;I love you&quot;</span>;</span><br><span class="line">cout &lt;&lt; sss1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// I</span></span><br><span class="line">cout &lt;&lt; sss1.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// love</span></span><br><span class="line">cout &lt;&lt; sss1.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">// you</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （8）string::npos 是个常数，值为-1 但由于是unsigned_int类型 ，因此也可以</span></span><br><span class="line"><span class="comment">// 认为是unsigned_int类型的最大值。string::npos用以作为find函数失配时的返回值。</span></span><br><span class="line"><span class="comment">// 可以认为string::npos等于-1或4294967295</span></span><br><span class="line"><span class="comment">// 4294967295：这是计算机程序设计里面的一个值，表示32位无符号整数的十进制最大值。</span></span><br><span class="line"><span class="comment">// 如果是16进制，那么是0xFFFFFFFF。也可以解释为一个IP地址(V4) 255.255.255.255</span></span><br><span class="line"><span class="keyword">if</span> (string::npos == <span class="number">-1</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-1 is true.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (string::npos == <span class="number">4294967295</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4294967295 is true.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （9）find()  O(nm) 其中n和m分别是str和str2的长度。</span></span><br><span class="line"><span class="comment">// str.find(str2)  当str2是str1的子串时，返回其在str中第一次出现的位置；</span></span><br><span class="line"><span class="comment">// 若str2不是str1子串，返回string::npos</span></span><br><span class="line"><span class="comment">// str.find(str2, pos)  从str的pos号位开始匹配str2， 返回值与上相同。</span></span><br><span class="line">string st1 = <span class="string">&quot;Lonely noodle shop&quot;</span>;</span><br><span class="line">string st2 = <span class="string">&quot;Lonely&quot;</span>;</span><br><span class="line">string st3 = <span class="string">&quot;Lovely&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (st1.<span class="built_in">find</span>(st2) != string::npos) &#123;</span><br><span class="line">cout &lt;&lt; st1.<span class="built_in">find</span>(st2) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st1.<span class="built_in">find</span>(st3) == string::npos) &#123;</span><br><span class="line">cout &lt;&lt; st1.<span class="built_in">find</span>(st3) &lt;&lt; endl; <span class="comment">// 4294967295</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (st1.<span class="built_in">find</span>(st2, <span class="number">0</span>) != string::npos) &#123;</span><br><span class="line">cout &lt;&lt; st1.<span class="built_in">find</span>(st2, <span class="number">0</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （10）replace()  O(str.length())</span></span><br><span class="line"><span class="comment">// str.replace(pos, len, str2)把str从pos号位开始、长度为len的子串替换为str2。</span></span><br><span class="line"><span class="comment">// str.replace(it1, it2, str2)把str的迭代器[it1,it2)范围的子串替换为str2</span></span><br><span class="line">string ssss1 = <span class="string">&quot;Lovely duck shop&quot;</span>;</span><br><span class="line">string ssss2 = <span class="string">&quot;Lonely&quot;</span>;</span><br><span class="line">string ssss3 = <span class="string">&quot;noodle&quot;</span>;</span><br><span class="line">cout &lt;&lt; ssss1.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">6</span>, ssss2) &lt;&lt; endl; <span class="comment">// Lonely duck shop</span></span><br><span class="line">cout &lt;&lt; ssss1.<span class="built_in">replace</span>(ssss1.<span class="built_in">begin</span>() + <span class="number">7</span>,ssss1.<span class="built_in">begin</span>() + <span class="number">11</span>, ssss3); <span class="comment">// Lonely noodle shop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-18/1642496633843-image.png"></p><p><strong>1.map 的定义</strong></p><p>单独定义一个 map:</p><blockquote><p>map&lt;typename1, typename2&gt; mp;</p></blockquote><p>map 和其他 STL 容器在定义上有点不一样，因为 map 需要确定<strong>映射前类型（键 key）和映射后类型（值 value）</strong>，所以需要在&lt; &gt;内填写两个类型，其中第一个是键的类型，第二个是值的类型。<strong>如果是 int 型映射到 int 型，就相当于是普通的 int 型数组。</strong></p><p>而如果是字符串到整型的映射，<strong>必须使用 string 而不能用 char 数组:</strong></p><blockquote><p>map&lt;string, int&gt; mp;</p></blockquote><p>这是因为 char 数组作为数组，是不能被作为键值的。如果想用字符串做映射，必须用 string。<br>前面也说到，map 的键和值也可以是 STL 容器，例如可以将一个<strong>set 容器映射到一个字符串</strong>：</p><blockquote><p>map&lt;set<int>, string&gt; mp:</p></blockquote><p><strong>2.map 容器内元素的访问</strong></p><p>&emsp;&emsp;map 一般有两种访问方式：通过下标访问或通过迭代器访问。下面分别讨论这两种访问方式。</p><p><strong>(1) 通过下标访问</strong></p><p>&emsp;&emsp;和访问普通的数组是一样的，例如对一个定义为 map&lt;char, int&gt; mp 的 map 来说，就可以直接使用 mp[‘c’]的方式来访问它对应的整数。于是，当建立映射时，就可以直接使用 mp[‘c’] = 20 这样和普通数组一样的方式。但是要注意的是，<strong>map 中的键是唯一的</strong>，也就是说，下面的代码将输出 30：</p><blockquote><p>map&lt;char, int&gt; mp;<br>mp[‘c’]=20;<br>mp[‘c’]=30; // 20 被覆盖</p></blockquote><p><strong>(2)通过迭代器访问</strong></p><p>map 迭代器的定义和其他 STL 容器迭代器定义的方式相同：</p><blockquote><p>map&lt;typenamel, typename2&gt;::iterator it;</p></blockquote><p>typenamel 和 typename2 就是定义 map 时填写的类型，这样就得到了迭代器 it。</p><p><strong>map 迭代器的使用方式和其他 STL 容器的迭代器不同</strong>，因为 map 的每一对映射都有两个 typename，这决定了必须能通过一个 it 来同时访问键和值。事实上，<strong>map 可以使用 it&gt;first 来访问键，使用 it-&gt; second 来访问值。</strong></p><p>来看下面这个示例:</p><blockquote><p>map&lt;char, int&gt; mp;<br>mp[‘m’]=20<br>mp[‘r’]=30;<br>mp[‘a’]=40;<br>for (map&lt;char, int&gt;::iterator it = mp.begin&gt;(); it != mp.end(); it++) {</p></blockquote><pre><code>cout&lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; it -&gt; second &lt;&lt; endl;</code></pre><p>}</p><p>在上面这个例子中，it-&gt;first 是当前映射的键，it-&gt;second 是当前映射的值。程序输出如下</p><blockquote><p>a 40<br>m 20<br>r 30</p></blockquote><p>接下来似乎发现了一个很有意思的现象：<strong>map 会以键从小到大的顺序自动排序</strong>，即按 a &lt; m &lt; r 的顺序排列这三对映射。这是由于 map 内部是使用红黑树实现的(set 也是)，在建立映射的过程中会自动实现从小到大的排序功能。</p><p><strong>3. map 的常用函数</strong></p><ul><li>find(key) 返回键为 key 的映射的迭代器，O(logN)，N 为 map 中映射的个数。</li><li>erase()</li></ul><p>&emsp;&emsp;（1）删除单个元素有两种方法：</p><p>&emsp;&emsp;mp.erase(it) it 为需要删除的元素的迭代器，O(1)</p><p>&emsp;&emsp;mp.erase(key) key 为欲删除的映射的键。O(logN)，N 为 map 内元素的个数。</p><p>&emsp;&emsp;（2）删除一个区间内的所有元素<br> &emsp;&emsp;mp.erase(first, last),其中 first 为需要删除的区间的起始迭代器，而 last 则为需要删除的区间的末尾迭代器的下一个地址，也即为删除左闭右开的区间[first, last) 时间复杂度为 O(last - first)</p><ul><li>size() 用来获得 map 中映射的对数</li><li>clear()用来清空 map 中的所有元素 O(N)，N 为 map 中元素的个数</li></ul><p><strong>4.map 的常见用途</strong></p><p>① 需要建立字符（或字符串）与整数之间映射的题目，使用 map 可以减少代码量</p><p>② 判断大整数或者其他类型数据是否存在的题目，可以把 map 当 bol 数组用</p><p>③ 字符串和字符串的映射也有可能会遇到。</p><p><em>延伸：map 的键和值是唯一的，而如果一个键需要对应多个值，就只能用 multimap。另外，C+11 标准中还增加了 unordered_map，以散列代替 map 内部的红黑树实现，使其可以用来处理只映射而不按 key 排序的需求，速度比 map 要快得多。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;m&#x27;</span>] = <span class="number">20</span>; <span class="comment">// a 40</span></span><br><span class="line">mp[<span class="string">&#x27;r&#x27;</span>] = <span class="number">30</span>; <span class="comment">// m 20</span></span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">40</span>; <span class="comment">// r 30</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1)find(key) 返回键为key的映射的迭代器，O(logN)，N为map中映射的个数。</span></span><br><span class="line">map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// r 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)erase()</span></span><br><span class="line"><span class="comment">// 1）删除单个元素有两种方法</span></span><br><span class="line"><span class="comment">// mp.erase(it)  it为需要删除的元素的迭代器，O(1)</span></span><br><span class="line">mp.<span class="built_in">erase</span>(it); <span class="comment">// 删除 r 30</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// a 40</span></span><br><span class="line">&#125;<span class="comment">// m 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mp.erase(key) key为欲删除的映射的键。O(logN)，N为map内元素的个数。</span></span><br><span class="line">mp.<span class="built_in">erase</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// m 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2）删除一个区间内的所有元素 O(last - first)</span></span><br><span class="line"><span class="comment">// mp.erase(first, last),其中first为需要删除的区间的起始迭代器，而last则为需要</span></span><br><span class="line"><span class="comment">// 删除的区间的末尾迭代器的下一个地址，也即为删除左闭右开的区间[first, last)</span></span><br><span class="line"> map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it1= mp.<span class="built_in">find</span>(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"> mp.<span class="built_in">erase</span>(it1, mp.<span class="built_in">end</span>()); <span class="comment">// 删除it之后的所有映射</span></span><br><span class="line"> cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (3)size() 用来获得map中映射的对数 O(1)如上所示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (4)clear()用来清空map中的所有元素  O(N)，N为map中元素的个数</span></span><br><span class="line">mp[<span class="string">&#x27;h&#x27;</span>] = <span class="number">66</span>;</span><br><span class="line">map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it2 = mp.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">cout &lt;&lt; it2-&gt;second&lt;&lt;endl; <span class="comment">// 66</span></span><br><span class="line">mp.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">size</span>(); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>queue 翻译为队列，在 STL 中主要则是实现了一个先进先出的容器。</p><p><strong>1.queue 的定义</strong></p><p>添加头文件#include <queue>，其定义的写法和其他 STL 容器相同， typename 可以是<strong>任意基本数据类型</strong>或<strong>容器</strong>：</p><blockquote><p>queue&lt; typename&gt; name;</p></blockquote><p><strong>2.queue 容器内元素的访问</strong></p><p>由于队列( queue)本身就是一种先进先出的限制性数据结构，因此在<strong>STL 中只能通过 front()来访问队首元素，或是通过 back()来访问队尾元素。</strong></p><p><strong>3.queue 常用函数</strong></p><ul><li>push()</li></ul><p>push(x)将 x 进行入队，时间复杂度 O(1)。</p><ul><li>front(),back()</li></ul><p>分别获得队首元素和队尾元素，时间复杂度 O(1)。</p><ul><li>pop()</li></ul><p>令队首元素出队，时间复杂度为 O(1)。</p><ul><li>empty()</li></ul><p>检测 queue 是否为空，返回 true 则空，返回 false 则非空。时间复杂度为 O(1)。</p><ul><li>size()</li></ul><p>返回 queue 内元素的个数，时间复杂度为 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(i); <span class="comment">// push(i)用以将i压入队列，因此依次入队1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 1 5</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 将队首元素1出队</span></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">empty</span>() == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;Empty!&quot;</span> &lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Not Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt;endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.queue 的常见用途</strong></p><p>当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用 queue 作为代替，以提高程序的准确性。</p><p>另外有一点注意的是，<strong>使用 front()和 pop()函数前，必须用 empty()判断队列是否为空</strong>，否则可能因为队空而出现错误。</p><p>延伸：STL 的容器中还有两种容器跟队列有关，分别是双端队列( deque)和优先队列( priority_queue)，前者是首尾皆可插入和删除的队列，后者是使用堆实现的默认将当前队列最大元素置于队首的容器。</p><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>priority_queue 又称为优先队列，其底层是用堆来进行实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。例如在队列有如下元素，且定义好了优先级:</p><blockquote><p>桃子(优先级 3)<br>梨子(优先级 4)<br>苹果(优先级 1)</p></blockquote><p>那么出队的顺序为梨子(4) → 桃子(3) → 苹果(1)。<br>当然，可以在任何时候往优先队列里面加入(push)元素，而优先队列底层的数据结构堆(heap)会随时调整结构，使得<strong>每次的队首元素都是优先级最大的。</strong><br>关于这里的优先级则是规定出来的。例如上面的例子中，也可以规定数字越小的优先级越大（在德国课程中，评分 1 分为优秀，5、6 分就是不及格了）。</p><p><strong>1.priority_queue 的定义</strong></p><p>添加头文件#include <queue></p><blockquote><p>priority_queue&lt; typename &gt; name;</p></blockquote><p>其定义的写法和其他 STL 容器相同，typename 可以是任意基本数据类型或容器：</p><p><strong>2. priority_queue 容器内元素的访问</strong></p><p>和队列不一样的是，优先队列没有 font()函数与 back()函数,而<strong>只能通过 top()函数来访问队首元素</strong>（也可以称为堆顶元素），也就是优先级最高的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>3.priority_queue 常用函数</strong></p><p>（1）push()<br>push(x)将令 x 入队，时间复杂度为 O(logN)，其中 N 为当前优先队列中的元素个数。实例见“ priority_queue 容器内元素的访问 ”。<br>（2）top()<br>top()可以获得队首元素(即堆顶元素)，时间复杂度为 O(1)。</p><p>（3）pop()</p><p>pop()令队首元素（即堆顶元素）出队，时间复杂度为 O(logN)，其中 N 为当前优先队列中的元素个数。</p><p>（4）empty()<br>empty()检测优先队列是否为空，返回 true 则空，返回 false 则非空。时间复杂度为 O(1)。</p><p>（5） size<br>size()返回优先队列内元素的个数，时间复杂度为 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队列非空！&quot;</span> &lt;&lt; endl; <span class="comment">// 队列非空！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.priority_queue 内元素优先级的设置</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642559357249-image.png"><br>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，即便是基本数据类型，也可以使用下面讲解的结构体的优先级设置方法，只不过第三个参数的写法不太一样了。下面来看结构体的优先级设置方法。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642559912177-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642561142817-image.png"><br>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;</span><br><span class="line"><span class="keyword">return</span> f1.price &gt; f2.price; <span class="comment">// 苹果 1 若改为 &gt; 则输出：梨子 4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;f1, f2, f3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;fruit&gt; q;  <span class="comment">// fruit类型！</span></span><br><span class="line">f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">f1.price = <span class="number">3</span>;</span><br><span class="line">f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">f2.price = <span class="number">4</span>;</span><br><span class="line">f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">f3.price = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(f1);</span><br><span class="line">q.<span class="built_in">push</span>(f2);</span><br><span class="line">q.<span class="built_in">push</span>(f3);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">top</span>().name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">top</span>().price &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642561717988-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642561843838-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span> &#123;</span></span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line">&#125;f1, f2, f3;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(fruit f1, fruit f2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> f1.price &gt; f2.price; <span class="comment">// 苹果 1 若改为 &gt; 则输出：梨子 4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q;</span><br><span class="line">f1.name = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">f1.price = <span class="number">3</span>;</span><br><span class="line">f2.name = <span class="string">&quot;梨子&quot;</span>;</span><br><span class="line">f2.price = <span class="number">4</span>;</span><br><span class="line">f3.name = <span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">f3.price = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(f1);</span><br><span class="line">q.<span class="built_in">push</span>(f2);</span><br><span class="line">q.<span class="built_in">push</span>(f3);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; q.<span class="built_in">top</span>().name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">top</span>().price &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642562211950-image.png"></p><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642562340813-image.png"></p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">st.<span class="built_in">push</span>(i); <span class="comment">// push(i)用以把i压入栈，故此处依次入栈 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642562604217-image.png"><br>示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st.pop();</span><br><span class="line">cout &lt;&lt; st.top() &lt;&lt; endl; // 4</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642562750771-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈不为空&quot;</span> &lt;&lt; endl; <span class="comment">// 栈不为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642562990209-image.png"></p><blockquote><pre><code>cout &lt;&lt; st.size() &lt;&lt; endl; // 4</code></pre></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642563007738-image.png"></p><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642563395747-image.png"></p><p>pair 中只有两个元素，分别是 first 和 second，只需要按正常结构体的方式去访问即可。<br>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pair&lt;string, <span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">p.first = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line">p.second = <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl; <span class="comment">// haha 5</span></span><br><span class="line"></span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="string">&quot;xixi&quot;</span>, <span class="number">55</span>);</span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl; <span class="comment">// xixi 55</span></span><br><span class="line"></span><br><span class="line">p = pair&lt;string, <span class="keyword">int</span>&gt;(<span class="string">&quot;heihei&quot;</span>, <span class="number">555</span>);</span><br><span class="line">cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; endl; <span class="comment">// heihei 555</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642563840389-image.png"><br>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="number">5</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1 &lt; p3) cout &lt;&lt; <span class="string">&quot;p1 &lt; p3&quot;</span> &lt;&lt; endl; <span class="comment">// p1 &lt; p3</span></span><br><span class="line"><span class="keyword">if</span> (p1 &lt;= p3) cout &lt;&lt; <span class="string">&quot;p1 &lt;= p3&quot;</span> &lt;&lt; endl; <span class="comment">// p1 &lt;= p3</span></span><br><span class="line"><span class="keyword">if</span> (p1 &lt; p2) cout &lt;&lt; <span class="string">&quot;p1 &lt; p2&quot;</span> &lt;&lt; endl; <span class="comment">// p1 &lt; p2</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642564714035-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;heihei&quot;</span>, <span class="number">5</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(pair&lt;string, <span class="keyword">int</span>&gt;(<span class="string">&quot;haha&quot;</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (map&lt;string, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl; <span class="comment">// haha 10</span></span><br><span class="line">&#125; <span class="comment">// heihei 5</span></span><br></pre></td></tr></table></figure><h1 id="algorithm-头文件下的常用函数"><a href="#algorithm-头文件下的常用函数" class="headerlink" title="algorithm 头文件下的常用函数"></a>algorithm 头文件下的常用函数</h1><p>  <strong>概览：</strong></p><ol><li>max()、min()和abs()</li><li>swap()</li><li>reverse()</li><li>next_permutation()</li><li>fill()</li><li>sort()</li><li>lower_bound()和upper_bound()</li></ol><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642565036624-image.png"><br>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>, y = <span class="number">-2</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(x, y) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">min</span>(x, y) &lt;&lt; endl; <span class="comment">// -1 -2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">abs</span>(x) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">abs</span>(y) &lt;&lt; endl; <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642568647056-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl; <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642568805908-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">3</span>); <span class="comment">// 将a[0]~a[2]反转</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 12 11 10 13 14 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是对容器中的元素（例如 string 字符串）进行反转，结果也是一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcdefghi&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(str.<span class="built_in">begin</span>() + <span class="number">1</span>, str.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 对str[1]~str[7]反转</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// a h g f e d c b i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642569435590-image.png"><br>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a[0]~a[2]之间的序列需要求解 next_permutation</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a + <span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>在上述代码中，使用循环是因为 next_permutation 在已经到达全排列的最后一个时会返回 false，这样会方便退出循环。而使用 do… while 语句而不使用 while 语句是因为序列 123 本身也需要输出，如果使用 while 会直接跳到下一个序列再输出，这样结果会少一个 123。</p><p>若 a[10] = {1, 5, 3};<br>输出结果中没有 135，因为这个函数给出一个序列在全排列中的下一个序列，135 是 153 的上一个序列，所以不会输出。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642570367535-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">4</span>, <span class="number">233</span>); <span class="comment">// 将a[0]~a[3]均赋值为233</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 233 233 233 233 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642570771088-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642570779878-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 将a[0]~a[1]从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 4 9 2 5 6 -1</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 a[0]~a[5] 从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// -1 2 4 5 6 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看运行结果，试着理解一下 ”尾元素地址的下一个地址“含义。</p><p>对 double、char（默认为字典序）同理，不再展开。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642571480702-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要从大到小来排序，则要使用比较函数 cmp 来”告诉“sort 何时要交换元素（让元素的大小比较关系反过来）。<br>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b; <span class="comment">// 可以理解为当 a &gt; b时把a放在b前面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a, a + <span class="number">4</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 4 3 2 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><blockquote><p>return a &gt; b;</p></blockquote><p><strong>可以理解为当 a &gt; b 时把 a 放在 b 前面，妙啊！</strong></p><p>这样就可以让数值较大的元素放在前面，也就达到了从大到小排序的要求。</p><p>对于 double、char 等同理，不再展开。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642572022731-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x &gt; b.x; <span class="comment">// 按x值从大到小对结构体数组排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ssd[<span class="number">0</span>].x = <span class="number">2</span>; <span class="comment">// &#123;2, 2&#125;</span></span><br><span class="line">ssd[<span class="number">0</span>].y = <span class="number">2</span>;</span><br><span class="line">ssd[<span class="number">1</span>].x = <span class="number">1</span>; <span class="comment">// &#123;1, 3&#125;</span></span><br><span class="line">ssd[<span class="number">1</span>].y = <span class="number">3</span>;</span><br><span class="line">ssd[<span class="number">2</span>].x = <span class="number">3</span>; <span class="comment">// &#123;3, 1&#125;</span></span><br><span class="line">ssd[<span class="number">2</span>].y = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(ssd, ssd + <span class="number">3</span>, cmp); <span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; ssd[i].x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ssd[i].y &lt;&lt; <span class="string">&quot;   &quot;</span>; <span class="comment">//3, 1   2, 2   1, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642572532350-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642572662386-image.png"></p><p>下面以 vector 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 因为vector中的元素为int型，因此仍然是int的比较</span></span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vi.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">sort</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), cmp); <span class="comment">// 对整个vector排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; vi[i]&lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 3 2 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看 string 的排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 因为vector中的元素为int型，因此仍然是int的比较</span></span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str[<span class="number">3</span>] = &#123;<span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(str, str + <span class="number">3</span>); <span class="comment">// 将string型数组按字典序从小到大输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; str[i]&lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// aaa bbbb ccc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上例中，需要按字符串长度从小到大排序，那么可以这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str1.<span class="built_in">length</span>() &lt; str2.<span class="built_in">length</span>(); <span class="comment">// 按string的长度从小到大排序 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str[<span class="number">3</span>] = &#123;<span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(str, str + <span class="number">3</span>, cmp); <span class="comment">// 将string型数组按字典序从小到大输出 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">cout &lt;&lt; str[i]&lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// cc aaa bbbb</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-19/1642573727022-image.png"></p><p>  示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 寻找-1</span></span><br><span class="line"><span class="keyword">int</span>* lowerPos = <span class="built_in">lower_bound</span>(a, a + <span class="number">10</span>, <span class="number">-1</span>); </span><br><span class="line"><span class="keyword">int</span>* upperPos = <span class="built_in">upper_bound</span>(a, a + <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">cout &lt;&lt; lowerPos - a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; upperPos - a &lt;&lt; endl; <span class="comment">// 0 0  返回的都是下标 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找1</span></span><br><span class="line">lowerPos = <span class="built_in">lower_bound</span>(a, a + <span class="number">10</span>, <span class="number">1</span>); </span><br><span class="line">upperPos = <span class="built_in">upper_bound</span>(a, a + <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; lowerPos - a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; upperPos - a &lt;&lt; endl; <span class="comment">// 0 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找3 </span></span><br><span class="line">lowerPos = <span class="built_in">lower_bound</span>(a, a + <span class="number">10</span>, <span class="number">3</span>); </span><br><span class="line">upperPos = <span class="built_in">upper_bound</span>(a, a + <span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; lowerPos - a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; upperPos - a &lt;&lt; endl; <span class="comment">// 3 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找4 </span></span><br><span class="line">lowerPos = <span class="built_in">lower_bound</span>(a, a + <span class="number">10</span>, <span class="number">4</span>); </span><br><span class="line">upperPos = <span class="built_in">upper_bound</span>(a, a + <span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; lowerPos - a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; upperPos - a &lt;&lt; endl; <span class="comment">// 6 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找6</span></span><br><span class="line">lowerPos = <span class="built_in">lower_bound</span>(a, a + <span class="number">10</span>, <span class="number">6</span>); </span><br><span class="line">upperPos = <span class="built_in">upper_bound</span>(a, a + <span class="number">10</span>, <span class="number">6</span>);</span><br><span class="line">cout &lt;&lt; lowerPos - a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; upperPos - a &lt;&lt; endl; <span class="comment">// 10 10 返回可插入该元素的位置的指针 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  显然，如果只是想获得欲查元素的下标，就可以不使用临时指针，而<strong>直接令返回值减去数组首地址</strong>即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 寻找3</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">lower_bound</span>(a, a + <span class="number">10</span>, <span class="number">3</span>) - a &lt;&lt; endl; <span class="comment">// 3 所在位置下标 </span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">upper_bound</span>(a, a + <span class="number">10</span>, <span class="number">3</span>) - a &lt;&lt; endl; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/r2peak/picture/raw/master/2022-1-18/1642504703480-image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;he</summary>
      
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯2021省赛</title>
    <link href="http://example.com/2022/01/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2021%E7%9C%81%E8%B5%9B/"/>
    <id>http://example.com/2022/01/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2021%E7%9C%81%E8%B5%9B/</id>
    <published>2022-01-17T06:27:31.000Z</published>
    <updated>2022-01-28T12:40:30.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>命运给你一个低的起点想看你翻盘的精彩，而不是让你自甘堕落，脚下的路虽难走，但我还能走，比起向阳而生，我更喜欢逆风翻盘。</p></blockquote><p>c++万能头文件，蓝桥杯可以用。</p><blockquote><p>#include&lt;bits/stdc++.h&gt;</p></blockquote><hr><h1 id="空间（5’）"><a href="#空间（5’）" class="headerlink" title="空间（5’）"></a>空间（5’）</h1><blockquote><p>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。<br>小蓝准备用256MB的内存空间开一个数组，数组的每个元素都是32位二进制整数，如果不考虑程序<br>占用的空间和维护内存需要的辅助空间，请问256MB的空间可以存储多少个32位二进制整数？</p></blockquote><p>运行限制</p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><p><strong>解题思路：</strong></p><p><em>计组基础题：256MB=256 * 2^20 * 8 位<br>所以存放32位元素可以存放 256 * 1024 * 1024 * 8 / 32<br>ans： 67108864</em></p><hr><h1 id="卡片（5’）"><a href="#卡片（5’）" class="headerlink" title="卡片（5’）"></a>卡片（5’）</h1><blockquote><p>小蓝有很多数字卡片，每张卡片上都是数字 0 到 9。<br>小蓝准备用这些卡片来拼一些数，他想从 1 开始拼出正整数，每拼一个，<br>就保存起来，卡片就不能用来拼其它数了。<br>小蓝想知道自己能从 1 拼到多少。<br>例如，当小蓝有 30 张卡片，其中 0 到 9 各 3 张，则小蓝可以拼出 1 到 10，<br>但是拼 11 时卡片 1 已经只有一张了，不够拼出 11。<br>现在小蓝手里有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1<br>拼到多少？<br>提示：建议使用计算机编程解决问题。</p></blockquote><p>运行限制</p><ul><li>最大运行时间：1s</li><li>最大运行内存: 128M</li></ul><p><strong>题目大意</strong></p><p>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。</p><p>用卡片拼数字，拼过的卡片不能再用，有 0 到 9 的卡片各 2021 张，共 20210 张，请问小蓝可以从 1 拼到多少？</p><p><strong>解题思路</strong></p><p><em>比较容易的模拟，我们从 1 开始枚举， 每次检查剩下的卡片能不能拼出这个数字就好。</em></p><p><em>我们是怎么把一个数在 10 进制下每个位置的数字求出来呢？先 对 10 取模，个位上的数字就求出来了，再除以 10 ，原本十位上的数字就变到了个位上，再对 10 取模…依次进行下去就求出来了。把当前拼的这个数每一位都拆出来，看看那个数字的卡片还够不够，不够的话就说明拼不了，这时候退出循环，所以最多拼到上一个数。</em></p><p>最终答案：3181。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>]; <span class="comment">// 存放0-9,每种卡片剩余数量 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line"><span class="keyword">int</span> now = x % <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (num[now] &gt; <span class="number">0</span>) num[now]--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 有一种卡片被用完了，终止for循环 </span></span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) num[i] = <span class="number">2021</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">cout &lt;&lt; i - <span class="number">1</span> &lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>这题适合用Excel来验证答案，直接在Excel里将1枚举到3181，复制到Word里面，将1替换成X，会有弹窗提示替换了多少个。</strong></p><hr><h1 id="直线（10’）"><a href="#直线（10’）" class="headerlink" title="直线（10’）"></a>直线（10’）</h1><blockquote><p>【问题描述】<br>在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上，<br>那么这些点中任意两点确定的直线是同一条。<br>给定平面上 2 × 3 个整点 {(x, y)|0 ≤ x &lt; 2, 0 ≤ y &lt; 3, x ∈ Z, y ∈ Z}，即横坐标是 0 到 1 (包含 0 和 1) 之间的整数、纵坐标是 0 到 2 (包含 0 和 2) 之间的整数的点。这些点一共确定了 11 条不同的直线。<br>给定平面上 20 × 21 个整点 {(x, y)|0 ≤ x &lt; 20, 0 ≤ y &lt; 21, x ∈ Z, y ∈ Z}，即横坐标是 0 到 19 (包含 0 和 19) 之间的整数、纵坐标是 0 到 20 (包含 0 和 20) 之间的整数的点。请问这些点一共确定了多少条不同的直线。</p></blockquote><p><strong>解题思路</strong></p><p><em>本题的求解方法就是把所有直线构造出来，然后去重，去重可以用map。对一条新的直线，映射(map)成1，井计数；下ー次再找到这条直线，判断一下，如果该直线的值已经为1了，就不重复计数。</em></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-17/1642407494502-image.png"></p><p><strong>直线的表示方法：</strong></p><ul><li><p><em>在平面直角坐标系中，俩点可以确定一条直线，但俩点有四个坐标值，我们不太好维护四个坐标值是否重复。</em></p></li><li><p><em>直线的表示方式中，除了俩点式，还有点斜式，点斜式的话， 一个点俩个坐标值和一个斜率值，三个值来确定唯一性，虽然不太好写但是还是勉强能跑出来。</em></p></li><li><p><em>更进一步，如果那个点是在 x 轴或者 y 轴上，那么一个坐标就恒定为 0, 只要维护另一个坐标值(其实就是截距)和斜率就好了，每一条直线：<strong>y = kx + b</strong>，斜率 k 和截距 b  肯定是唯一的，用 map 维护一下，要注意考虑枚举的斜率不存在的情况。</em></p></li></ul><p>最终答案：40257。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-17/1642407776778-image.png"><br>关于截距 b 的推导：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-17/1642415099713-image.png"></p><p><em><strong>代码辛辛苦苦写完了，别忘了验证！如何验证呢？</strong></em></p><p><em><strong>拿小规模数据验证一下，将题目中20，21换成小点的数字，2，3验证一下结果就行！</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">&#125;p[<span class="number">25</span>*<span class="number">25</span>]; <span class="comment">// 存下每个点</span></span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt;, <span class="keyword">int</span>&gt; mp; <span class="comment">// 存斜率 k 和截距 b </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 构造出整点的个数 （cnt为count缩写） </span></span><br><span class="line"><span class="comment">// 为每个点赋值 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">21</span>; j++) &#123;</span><br><span class="line">p[cnt].x = i; </span><br><span class="line">p[cnt++].y = j;  <span class="comment">// ++是为了构建下一个整点 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">20</span> + <span class="number">21</span>; <span class="comment">// 20条竖线，21条横线 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="comment">// 两点的直线与坐标轴平行或共点（这种直线ans上面已累计过） </span></span><br><span class="line"><span class="keyword">if</span> (p[i].x == p[j].x || p[i].y == p[j].y) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 斜率 和 截距(把j点坐标带进去算即可） </span></span><br><span class="line"><span class="keyword">double</span> k = (p[j].y - p[i].y) / (p[j].x - p[i].x);</span><br><span class="line"><span class="keyword">double</span> b = (p[j].x * p[i].y  - p[i].x * p[j].y ) / (p[j].x - p[i].x);</span><br><span class="line"><span class="comment">// 判断在map中由k, b构成的实数对的映射值，有未出现过 </span></span><br><span class="line"><span class="keyword">if</span> (mp[&#123;k, b&#125;] == <span class="number">0</span>) &#123; <span class="comment">// 该映射值对应的k, b在之前没出现过 </span></span><br><span class="line">mp[&#123;k, b&#125;] = <span class="number">1</span>; <span class="comment">// 若没出现过，映射值改为1 </span></span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt;ans &lt;&lt;endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p><em>这题先定义结构体Point，两个属性x, y为坐标，使用一个map来存斜率k、截距b的映射值。下面的思路是先用俩for循环，初始化每个点（循环变量i, j分别为这个点p的x, y坐标赋值)。</em></p></li><li><p><em>再通过两个for循环，遍历每个点：先找出特殊的线（与坐标轴平行或共点的线），再表示出斜率、截距，找出独一无二的线，遍历寻找结束后返回结果。</em></p></li><li><p><em>结构体、map的定义与应用，要好好把握。</em></p></li></ul><h1 id="货物摆放（10’）"><a href="#货物摆放（10’）" class="headerlink" title="货物摆放（10’）"></a>货物摆放（10’）</h1><blockquote><p>【问题描述】<br>小蓝有一个超大的仓库，可以摆放很多货物。<br>现在，小蓝有 n 箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝<br>规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、<br>宽、高。<br>小蓝希望所有的货物最终摆成一个大的立方体。即在长、宽、高的方向上<br>分别堆 L、W、H 的货物，满足 n = L × W × H。<br>给定 n，请问有多少种堆放货物的方案满足要求。<br>例如，当 n = 4 时，有以下 6 种方案：1×1×4、1×2×2、1×4×1、2×1×2、 2 × 2 × 1、4 × 1 × 1。<br>请问，当 n = 2021041820210418 （注意有 16 位数字）时，总共有多少种<br>方案？<br>提示：建议使用计算机编程解决问题。</p></blockquote><p><strong>题目大意</strong></p><p>给定一个n，n=2021041820210418，可满足 (a,b,c)=n 的(a,b,c)组合有多少种。</p><p><strong>解题思路</strong></p><p><em>首先明确，(a,b,c) 肯定是 n 的因子(n=axbc &amp;&amp; n=bxac &amp;&amp; n=cxab)</em></p><p><em>于是可以筛出 n 的因子，存入数组中。</em></p><p><em>因为n的值很大，不能枚举1,2,…,n能不能整除n，这个枚举算法要将近1年才能运行完。</em></p><p><em>枚举1,2,…,i(i</em>i &lt;= n)，而且若i是n的因子，则n / i 也是 n 的因子。另外，要判断i 和 n / i是否相等。*</p><p><em>我们得到 n 的因子数为128，数目很小，所以可以直接枚举a,b,c,来计算总共的组合数。</em></p><p>官方题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>; <span class="comment">// 1e3 = 1*10^3 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[maxn]; <span class="comment">// 数组a来存所有的因子 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">2021041820210418</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 所有因子的数目 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求n的所有因子 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123; </span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123; <span class="comment">// 说明i是n的一个因子 </span></span><br><span class="line">a[len++] = i;</span><br><span class="line"><span class="keyword">if</span> (i != n / i) &#123; <span class="comment">// 特例：当i == n / i 时，只能存一个 </span></span><br><span class="line">a[len++] = n / i;  <span class="comment">// 若i为n的因子，则n/i也是n的因子 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举因子相乘是否等于n </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>; <span class="comment">// 方案总和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] * a[j] &gt; n) <span class="keyword">continue</span>; <span class="comment">// 剪枝很聪明 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] * a[j] * a[k] == n) &#123; </span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-17/1642420909730-image.png"></p><p><em>三重for循环，128</em>128<em>128结果为两百多万，几十毫秒就能跑完。</em></p><p><em><strong>同样，代码编完了，用题目给的数据检验一下，或者自己编个数，草稿纸上算算比对一下。</strong></em></p><p>大佬题解：</p><p>事先宏定义long long 值得学习，使用到了动态数组vector更方便。</p><p>这代码真好看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL n = <span class="number">2021041820210418</span>; </span><br><span class="line">vector&lt;LL&gt;d; <span class="comment">// 存储n的所有因子  d : divisor 除数，约数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求n的所有因子 </span></span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span>; i * i &lt;= n; i++) &#123; </span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123; <span class="comment">// 说明i是n的一个因子 </span></span><br><span class="line">d.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (i != n / i) &#123; <span class="comment">// 特例：当i == n / i 时，只能存一个 </span></span><br><span class="line">d.<span class="built_in">push_back</span>(n / i);  <span class="comment">// 若i为n的因子，则n/i也是n的因子 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans = <span class="number">0</span>; <span class="comment">// 方案数 </span></span><br><span class="line">vector&lt;LL&gt;::iterator i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = d.<span class="built_in">begin</span>(); i != d.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = d.<span class="built_in">begin</span>(); j != d.<span class="built_in">end</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*i) * (*j) &gt; n) <span class="keyword">continue</span>; <span class="comment">// 剪枝很聪明 </span></span><br><span class="line"><span class="keyword">for</span> (k = d.<span class="built_in">begin</span>(); k != d.<span class="built_in">end</span>(); k++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*i) * (*j) * (*k) == n) &#123; </span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><em>其实就分两步：</em></p><p><em>1. 求出 n 的所有因子(约数）</em></p><p><em>2. 枚举所有因子，判断成立的方案个数</em></p><p><em><strong>这题要熟练掌握分解因子的写法！</strong></em></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-18/1642467583169-image.png"><br><em><strong>常见数据类型范围也要熟悉：</strong></em><br><em>unsigned int 0～4294967295（10位）<br>int -2147483648～2147483647（10位）<br>unsigned long 0～4294967295（10位）<br>long -2147483648～2147483647（10位）<br>long long的最大值：9223372036854775807（19位）<br>long long的最小值：-9223372036854775808</em>（19位）</p><hr><h1 id="路径（15’）"><a href="#路径（15’）" class="headerlink" title="路径（15’）"></a>路径（15’）</h1><blockquote><p>【问题描述】<br>小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图<br>中的最短路径。<br>小蓝的图由 2021 个结点组成，依次编号 1 至 2021。<br>对于两个不同的结点 a, b，如果 a 和 b 的差的绝对值大于 21，则两个结点<br>之间没有边相连；如果 a 和 b 的差的绝对值小于等于 21，则两个点之间有一条<br>长度为 a 和 b 的最小公倍数的无向边相连。</p></blockquote><p>例如：结点 1 和结点 23 之间没有边相连；结点 3 和结点 24 之间有一条无<br>向边，长度为 24；结点 15 和结点 25 之间有一条无向边，长度为 75。</p><p>请计算，结点 1 和结点 2021 之间的最短路径长度是多少。<br>提示：建议使用计算机编程解决问题。</p><p><strong>题目大意</strong></p><p><em>本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。<br>题目给定建图方式， i和 j 的差值的绝对值小于 21 的时候 i和 j之间连接一条权值为 LCM(i,j) 的边,问1 到 2021 的最短路径。<br>LCM 表示最小公倍数。</em></p><p><strong>解题思路</strong></p><p><em>这题建图方式告诉你了，老老实实按照题目说的方式建图，然后单源最短路 dijkstra 算法一下子就跑出来了。<br>由于蓝桥杯是闭卷，也就是不让带参考材料，很多人记不住 dijkstra 算法,或者比赛的时候一紧张写错了，导致跑出来的答案差了那么一丢丢，就很尴尬了。考虑这道题是填空题，那么不需要在规定时间内完成，那么简单好记的粗暴算法 Floyd 就纳入我们的选择。<br>为什么说 Floyd算法粗暴，因为他用的是 DP 的思想，复杂度高达 O(n^3)，优点就是简单好写。这题 n = 2021，n^3约等于 10 ^10, 假设考场的电脑性能比较差，*<em>一秒只能跑 10^8（一亿次）</em></em> ，也就是我们最多运行 100 秒， 2 分钟不到就可以跑出最稳妥的答案。*</p><p><em>最终答案：10266837。</em></p><p>dijkstra算法：</p><p><strong>总结：</strong></p><ul><li><p><em>greatest common divisor 最大公约数<br>least common multiple 最小公倍数</em><br>缩写：gcd和lcm</p></li><li><p><em>adjacent 邻接的</em></p></li><li><p>vertex 顶点</p></li><li><p>ACM中常用的无穷大常量——0x3f3f3f3f</p></li></ul><p><code> const int inf = 0x3f3f3f3f;</code></p><blockquote><p>介绍：<br>0x3f3f3f3f是一个很有用的数值，它是满足以下两个条件的最大整数。</p><p>1、整数的两倍不超过 0x7f7f7f7f，即int能表示的最大正整数。</p><p>2、整数的每8位（每个字节）都是相同的。</p><p>我们在程序设计中经常需要使用 memset(a, val, sizeof a) 初始化一个数组a，该语句把数值 val（0x00~0xFF）填充到数组a 的每个字节上，所以用memset只能赋值出“每8位都相同”的 int。</p><p>当需要把一个数组中的数值初始化成正无穷时，为了避免加法算术上溢出或者繁琐的判断，我们经常用 memset(a, 0x3f, sizeof(a)) 给数组赋 0x3f3f3f3f的值来代替。</p></blockquote><ul><li>memset():</li></ul><blockquote><p>void *memset(void *s, int ch, size_t n);</p></blockquote><p>函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。<br>memset：<strong>作用是在一段内存块中填充某个给定的值</strong>，它是对较大的结构体或数组进行清零操作的一种最快方法。</p><ul><li>C++中最大公约数函数： __gcd(int a, int b) </li></ul><blockquote><p>注：gcd前面是俩_下划线，用__gcd(a, b)可以求出a和b的最小公倍数，公式是：a*b除以a和b的最大公约数。</p></blockquote><p>floyd:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">2022</span>][<span class="number">2022</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2022</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> gcd = __gcd(a, b);</span><br><span class="line"><span class="keyword">return</span> a*b/gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d, INF, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2021</span>; k++) &#123; <span class="comment">// </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2021</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2021</span>; j++) &#123;</span><br><span class="line">g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]); <span class="comment">// 从i到j的最短路径 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> g[<span class="number">1</span>][<span class="number">2021</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="built_in">memset</span>(g, INF, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line"><span class="comment">//map begin</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2021</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2021</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == j) g[i][j] = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) &lt;= <span class="number">21</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> w = <span class="built_in">lcm</span>(i, j);</span><br><span class="line">g[i][j] = g[j][i] = w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map end</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">floyd</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10266837</span></span><br></pre></td></tr></table></figure><p>官方题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line">ll mp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                mp[i][j] = <span class="built_in">min</span>(mp[i][j], mp[i][k] + mp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2021</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) mp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(i - j) &lt;= <span class="number">21</span>) mp[i][j] = mp[j][i] = i * j / __gcd(i, j);</span><br><span class="line">            <span class="keyword">else</span> mp[i][j] = mp[j][i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>(n);</span><br><span class="line">    cout &lt;&lt; mp[<span class="number">1</span>][<span class="number">2021</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>n方便修改测试了</li><li>建图的逻辑不错！</li></ul><p>dijkstra：（值得反复学习）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f</span>; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">2025</span>]; <span class="comment">// 起点到达各点的最短路径长度 </span></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">2025</span>][<span class="number">2025</span>];  </span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2025</span>]; <span class="comment">// 记录是否被访问 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// 最小公倍数 </span></span><br><span class="line"><span class="keyword">int</span> gcd = __gcd(x,y);</span><br><span class="line"><span class="keyword">return</span> x * y / gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d, INF, <span class="built_in"><span class="keyword">sizeof</span></span>(d)); <span class="comment">// 边清空 </span></span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2021</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2021</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; d[u]) &#123; <span class="comment">// d[u]初值为INF </span></span><br><span class="line">u = j; <span class="comment">// 使d[u]最小的还没被访问的顶点的标号 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[u] = <span class="literal">true</span>; <span class="comment">// 记u已被访问 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2021</span>; j++) &#123; <span class="comment">// 优化d[j] </span></span><br><span class="line">d[j] = <span class="built_in">min</span> (d[j], d[u] + g[u][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int j = max(1, u - 21); j &lt;= min(2021, u + 21); j++) &#123; // 剪枝，只有这些点有边 </span></span><br><span class="line"><span class="comment"> d[j] = min(d[j], d[u] + g[u][j]);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[<span class="number">2021</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(g, INF, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line"><span class="comment">// 建图......begin</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2021</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">2021</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == j) g[i][j] = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) &lt;= <span class="number">21</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> w = <span class="built_in">lcm</span>(i, j); <span class="comment">// 最小公倍数，权值</span></span><br><span class="line">g[i][j] = g[j][i] = w; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 建图......end </span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10266837</span></span><br></pre></td></tr></table></figure><h1 id="时间显示（15’）"><a href="#时间显示（15’）" class="headerlink" title="时间显示（15’）"></a>时间显示（15’）</h1><blockquote><p>【问题描述】<br>小蓝要和朋友合作开发一个时间显示的网站。在服务器上，朋友已经获取<br>了当前的时间，用一个整数表示，值为从 1970 年 1 月 1 日 00:00:00 到当前时<br>刻经过的毫秒数。<br>现在，小蓝要在客户端显示出这个时间。小蓝不用显示出年月日，只需要<br>显示出时分秒即可，毫秒也不用显示，直接舍去即可。<br>给定一个用整数表示的时间，请将这个时间对应的时分秒输出。<br>【输入格式】<br>输入一行包含一个整数，表示时间。<br>【输出格式】<br>输出时分秒表示的当前时间，格式形如 HH:MM:SS，其中 HH 表示时，值<br>为 0 到 23，MM 表示分，值为 0 到 59，SS 表示秒，值为 0 到 59。时、分、秒<br>不足两位时补前导 0。<br>【样例输入 1】<br>46800999<br>【样例输出 1】<br>13:00:00<br>【样例输入 2】<br>1618708103123<br>【样例输出 2】<br>01:08:23<br>【评测用例规模与约定】<br>对于所有评测用例，给定的时间为不超过 10^18 的正整数。</p></blockquote><p><strong>解题思路：</strong><br>简单模拟题。<br>由于不用考虑毫秒，所以可以去掉毫秒的精度。<br>由于不用考虑年月日，所以只保留最后一天的时间即可。<br>值得注意的是 1s = 1000ms。<br>时间复杂度为 O(1)。</p><ul><li>fill()可以用来改变填充的字符，比如cout.fill(‘*‘)，使用*填充空白部分。</li></ul><p><em>千万要注意：fill函数在设置后将一直有效，除非被重新设定。</em></p><ul><li>setw(int n)是c++中在输出操作中使用的字段宽度设置，设置输出的域宽，n表示字段宽度。</li></ul><p><em>注：只对紧接着的输出有效，紧接着的输出结束后又变回默认的域宽。<br>当后面紧跟着的输出字段长度小于n的时候，在该字段前面用空格补齐；当输出字段长度大于n时，全部整体输出。</em></p><ul><li>通过秒数s获取小时：小时 = s / (60 *60)</li><li>通过秒数s获取分钟：分钟 = s / 60 <em><strong>% 60</strong></em></li><li>通过秒数s获取秒：秒 = s % 60</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">cin &gt;&gt; n; </span><br><span class="line">n /= <span class="number">1000</span>; <span class="comment">// 得到秒数</span></span><br><span class="line">n %= (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>); <span class="comment">// 得到最后一天的秒数 </span></span><br><span class="line">cout.<span class="built_in">fill</span>(<span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; n / <span class="number">3600</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; n / <span class="number">60</span> % <span class="number">60</span> </span><br><span class="line">&lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; n % <span class="number">60</span> &lt;&lt; endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>本题主要考察对于时间格式的转换，以及对格式控制函数的掌握。</p><h1 id="砝码称重（20’）"><a href="#砝码称重（20’）" class="headerlink" title="砝码称重（20’）"></a>砝码称重（20’）</h1><blockquote><p>【问题描述】<br>你有一架天平和 N 个砝码，这 N 个砝码重量依次是 W1, W2, · · · , WN。<br>请你计算一共可以称出多少种不同的重量？<br>注意砝码可以放在天平两边。<br>【输入格式】<br>输入的第一行包含一个整数 N。<br>第二行包含 N 个整数：W1, W2, W3, · · · , WN。<br>【输出格式】<br>输出一个整数代表答案。<br>【样例输入】<br>3<br>1 4 6<br>【样例输出】<br>10<br>【样例说明】<br>能称出的 10 种重量是：1、2、3、4、5、6、7、9、10、11。<br>1 = 1；<br>2 = 6 − 4 (天平一边放 6，另一边放 4)；<br>3 = 4 − 1；<br>4 = 4；<br>5 = 6 − 1；<br>6 = 6；<br>7 = 1 + 6；<br>9 = 4 + 6 − 1；<br>10 = 4 + 6；<br>11 = 1 + 4 + 6。<br>【评测用例规模与约定】<br>对于 50% 的评测用例，1 ≤ N ≤ 15。<br>对于所有评测用例，1 ≤ N ≤ 100，N 个砝码总重不超过 100000。</p></blockquote><p><strong>解题思路：</strong></p><blockquote><p>跑两遍01背包，<br>第一遍是加砝码，第二遍是减砝码。<br>（对于减砝码<br>如果已经加上了当前的砝码，则相当于把砝码拿下来<br>如果没有加当前的砝码，则相当于把砝码放在天平另一边<br>因此不会冲突）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll dp[<span class="number">100005</span>]; <span class="comment">// dp[j]表示重量为j的称重能不能实现，取值为1或0 </span></span><br><span class="line">ll w[<span class="number">105</span>]; <span class="comment">// N个砝码各自的重量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll N; </span><br><span class="line">cin &gt;&gt; N; <span class="comment">// N个砝码 </span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">cin &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 设置初值，否则无法完成递推 </span></span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= N; i++) &#123; <span class="comment">// 考虑每个砝码 </span></span><br><span class="line"><span class="comment">// 从大到小考虑每个称重j, j&gt;=w[i]（因为要保证j-w[i]&gt;=0） </span></span><br><span class="line"><span class="comment">// 若从小到大，则意味着w[i]可以加很多次，j-w[i]+w[i]=j,j+w[i],... </span></span><br><span class="line"><span class="keyword">for</span>(ll j = <span class="number">100000</span>; j &gt;= w[i]; j--) &#123; </span><br><span class="line"><span class="comment">// 如果此前dp[j-w[i]]为1【所谓记忆化搜索！】，则加上w[i]重量，能达到j,所以dp[j]为1 </span></span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]]); <span class="comment">// dp数组示意图：|----...----dp[j-w[i]]----dp[j]------|</span></span><br><span class="line">&#125;  <span class="comment">// 加上w[i]后得到dp[j]，而将此前dp[j-w[i]]为1的值赋给dp[j]！妙啊 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= N; i++) &#123; <span class="comment">// 考虑每个砝码  </span></span><br><span class="line">ll size = <span class="number">100000</span> - w[i];</span><br><span class="line"><span class="comment">// 从小到大考虑每个称重j,j&lt;=100000-w[i]</span></span><br><span class="line"><span class="comment">// 若从大到小，则意味着w[i]可以减很多次，j+w[i]-w[i]=j,j-w[i],... </span></span><br><span class="line"><span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= size; j++) &#123;</span><br><span class="line"><span class="comment">//如果此前dp[j+w[i]]为1，则减去w[i]重量，能达到j，所以dp[j]为1</span></span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j + w[i]]);  <span class="comment">// dp数组示意图：|------dp[j]----dp[j+w[i]]----...----|</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">ans += dp[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="杨辉三角形"><a href="#杨辉三角形" class="headerlink" title="杨辉三角形"></a>杨辉三角形</h1><p>【问题描述】<br>下面的图形是著名的杨辉三角形：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-22/1642817077841-image.png"></p><p>如果我们按从上到下、从左到右的顺序把所有数排成一列，可以得到如下<br>数列：<br>1, 1, 1, 1, 2, 1, 1, 3, 3, 1, 1, 4, 6, 4, 1, …<br>给定一个正整数 N，请你输出数列中第一次出现 N 是在第几个数？<br>【输入格式】<br>输入一个整数 N。<br>【输出格式】<br>输出一个整数代表答案。<br>【样例输入】<br>6<br>【样例输出】<br>13<br>【评测用例规模与约定】<br>对于 20% 的评测用例，1 ≤ N ≤ 10；<br>对于所有评测用例，1 ≤ N ≤ 1000000000（即10^9)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;命运给你一个低的起点想看你翻盘的精彩，而不是让你自甘堕落，脚下的路虽难走，但我还能走，比起向阳而生，我更喜欢逆风翻盘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;c++万能头文件，蓝桥杯可以用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;#inclu</summary>
      
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="蓝桥杯" scheme="http://example.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://example.com/2022/01/15/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://example.com/2022/01/15/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2022-01-15T03:27:31.000Z</published>
    <updated>2022-01-16T05:50:40.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表理论基础"><a href="#哈希表理论基础" class="headerlink" title="哈希表理论基础"></a>哈希表理论基础</h1><p>哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，看到这两个名称知道都是指hash table就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p>这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。</p><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642217365280-image.png"></p><p>那么哈希表能解决什么问题呢，一般<strong>哈希表用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。</p><p>要枚举的话时间复杂度是 O(n) ，但如果使用哈希表的话， 只需要 O(1) 就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了hash function ，也就是<strong>哈希函数。</strong></p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642217484420-image.png"><br>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p><p>接下来<strong>哈希碰撞</strong>登场</p><h2 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h2><p>如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642217575684-image.png"></p><p>一般哈希碰撞有两种解决方法， <strong>拉链法</strong>和<strong>线性探测法。</strong></p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642217705971-image.png"></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><p><strong>拉链法原理:</strong></p><ul><li><p>把具有相同散列地址的关键字(同义词)值放在同一个单链表中，称为同义词链表。</p></li><li><p>有m个散列地址就有m个链表，同时用指针数组 T[0..m-1] 存放各个链表的头指针，凡是散列地址为i的记录都以结点方式插入到以 T[i] 为指针的单链表中。T 中各分量的初值应为空指针。</p></li></ul><p><strong>用途</strong></p><p>主要用于解决key值冲突的问题</p><p><strong>场景</strong></p><ul><li>HashMap就用了拉链法 HashMap的key是转化成了hashcode，这个值是可能重复的</li><li><strong>求集合交集</strong></li></ul><p>&emsp;&emsp;妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙啊</p><p>示例：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642218267865-image.png"><br>&emsp;&emsp;有序集合1{1,3,5,7,8,9}</p><p>&emsp;&emsp;有序集合2{2,3,4,5,6,7}</p><p>&emsp;&emsp;两个指针指向首元素，比较元素的大小：</p><p>&emsp;&emsp;&emsp;&emsp;1、如果相同，放入结果集，随意移动一个指针</p><p>&emsp;&emsp;&emsp;&emsp;2、否则，移动值较小的一个指针，直到队尾</p><p>&emsp;&emsp;这种方法的好处是：</p><p>&emsp;&emsp;&emsp;&emsp;1、集合中的元素最多被比较一次，时间复杂度为O(n)</p><p>&emsp;&emsp;&emsp;&emsp;2、多个有序集合可以同时进行，这适用于多个分词的item求url_id交集</p><p>&emsp;&emsp;这个方法就像一条拉链的两边齿轮，一一比对就像拉链，故称为拉链法</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642218520694-image.png"></p><h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set（集合）</li><li>map（映射）</li></ul><p>这里数组就没啥可说的了，我们来看一下set。</p><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642218596713-image.png"><br><strong>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是 <em>有序</em> 的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</strong><br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642218616492-image.png"><br><strong>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是 <em>有序</em> 的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</strong></p><p><strong>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</strong></p><p>那么再来看一下map ，在<strong>map 是一个 &lt;key , value&gt; 的数据结构</strong>，map中，<strong>对key是有限制的，对value没有限制</strong>，因为key的存储方式使用红黑树实现的。</p><p>其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。</p><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是<strong>std::set、std::multiset 依然使用哈希函数来做映射</strong>，只不过底层的符号表使用了红黑树来存储数据，所以<strong>使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法</strong>。 map也是一样的道理。</p><p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642224733916-image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。</p><p>但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><p><a href="https://leetcode-cn.com/problems/valid-anagram/">242.有效的字母异位词</a></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p>说明: 你可以假设字符串只包含小写字母。</p><p><strong>思路一：排序</strong></p><p>使用 std::sort 把两个字符串排序，如果排序之后结果相同就是 有效的字母异位词，否则不是。</p><p>Time Complexity O(n logn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">      <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">      <span class="keyword">return</span> s == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n log n)，其中 n 为 s 的长度。排序的时间复杂度为 O(n log n)，比较两个字符串是否相等时间复杂度为 O(n)，因此总体时间复杂度为 O(n log n + n)=O(n log n)。</p></li><li><p>空间复杂度：O(log n)。排序需要 O(log n) 的空间复杂度。</p></li></ul><p><strong>思路二：哈希表</strong></p><p>这不算一道难题，核心点就在于使用哈希表映射，我们还是用一个数组来代替哈希表。</p><ul><li><p>我们先判断两个字符串长度是否相同，不相同直接返回false。</p></li><li><p>然后把s中所有的字符出现个数统计起来，存入一个大小为26的数组中，因为题目中限定了输入字符串为小写字母组成。</p></li><li><p>然后我们再来统计t字符串，如果发现不匹配则返回false。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m [<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ++m[s[i] - <span class="string">&#x27;a&#x27;</span>]; <span class="comment">// 先将s中元素映射成数字存入数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--m[t[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 为 s 的长度。</p></li><li><p>空间复杂度：O(S)，其中 S 为字符集大小，此处 S=26。</p></li></ul><h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></p><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p>示例 1：</p><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]</p><p>示例 2：</p><p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[9,4]</p><p>说明：</p><p>输出结果中的每个元素一定是唯一的。<br>我们可以不考虑输出结果的顺序。</p><hr><p>这道题目，主要要学会使用一种哈希数据结构：unordered_set，这个数据结构可以解决很多类似的问题。</p><p>注意题目特意说明：<strong>输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序。</strong></p><p>这摆明了是要用 unordered_set 哇：“唯一”、“无序“。</p><p>这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。</p><p>那么用数组来做哈希表也是不错的选择，例如242. 有效的字母异位词</p><p>但是要注意，<strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了，set ，关于set，C++ 给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树（一种平衡二叉搜索树），std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><p>思路如图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642235579794-image.png"></p><p><strong>思路一：set</strong></p><p>解题思路：使用两个集合解决这个问题。</p><ul><li><p>首先，将nums1中的元素加入到集合set1中。</p></li><li><p>依次检查nums2中的元素是否在set1中，如果在，说明属于交集元素，加入到交集集合set2中。</p></li><li><p>遍历set2，把所有元素加入到数组res中，返回res。</p></li></ul><p>复杂度分析</p><ul><li><p>时间复杂度：O(m+n)，m和n分别表示nums1和nums2的长度。算法中对nums1和nums2分别进行遍历。</p></li><li><p>空间复杂度:O(max(n,m))，m表示nums1的长度。集合set1的长度最长为m，set2和res的长度不会超过set1。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，将nums1中的元素加入到集合set1中。</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set1;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            set1.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">…        <span class="keyword">for</span>(<span class="keyword">int</span> num : set2) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路二：双指针</strong></p><p>解题思路：</p><ul><li><p>首先，将nums1和nums2排序。</p></li><li><p>定义双指针i和j，分别指向两个数组。从前向后遍历寻找交集元素。</p></li></ul><p>&emsp;&emsp;当nums1[i] &lt; nums2[j]，i后移1位</p><p>&emsp;&emsp;当nums1[i] &gt; nums2[j]，j后移1位</p><p>&emsp;&emsp;当nums1[i] == nums2[j]，把nums1[i]加入集合intersect，i后移1位，j后移1位</p><ul><li>将集合intersect的元素加入res中</li></ul><p>复杂度分析：</p><ul><li><p>时间复杂度：O(mlog(m)+nlog(n))，其中m和n分别是nums1和nums2长度。排序算法的时间复杂度是O(mlog(m)+nlog(n))，双指针扫描的复杂度是O(m+n)。</p></li><li><p>空间复杂度：O(1)，常量空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、两个指针分别指向s1、s2首部，若相同，加入set；否则将数值小的指针后移。</span></span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp;　p2 &lt; nums2.<span class="built_in">size</span>()) &#123; <span class="comment">// 二者之一遍历完时，循环结束</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[p1] == nums2[p2]) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(nums1[p1]);</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// set中元素即为两数组交集部分，将其加入vector中返回</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : s) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>遍历元素简洁写法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int num : s) &#123;</span><br><span class="line">    res.push_back(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意细节！在插入元素时，vector-是-push-back，而-set-是insert"><a href="#注意细节！在插入元素时，vector-是-push-back，而-set-是insert" class="headerlink" title="注意细节！在插入元素时，vector 是 push_back，而 set 是insert !"></a><strong>注意细节！在插入元素时，vector 是 push_back，而 set 是insert !</strong></h2><hr><h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><p>思路：看看变化的过程中，是否出现重复，若出现，则代表不是快乐数。</p><p>先判断<strong>特殊情况</strong>的思想很重要！取各位的小算法也要牢记！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; us;</span><br><span class="line">        us.<span class="built_in">insert</span>(n);</span><br><span class="line">        <span class="comment">// 判断是否是“快乐数”，若不是返回false，若是返回true</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n)&#123;</span><br><span class="line">                sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>); <span class="comment">// 各位求和</span></span><br><span class="line">                n = n / <span class="number">10</span>; <span class="comment">// 扔掉个位</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断是否重复</span></span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (us.<span class="built_in">find</span>(sum) != us.<span class="built_in">end</span>())&#123; <span class="comment">// 若满足条件，说明在us中发现重复了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            n = sum; <span class="comment">// ★ 更新n ★</span></span><br><span class="line">            us.<span class="built_in">insert</span>(sum); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></p><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。</p><p><code>242. 有效的字母异位词</code> 这道题目是用数组作为哈希表来解决哈希问题，<code>349. 两个数组的交集</code> 这道题目是通过set作为哈希表来解决哈希问题。</p><p>本题则要使用map，那么来看一下使用数组和set来做哈希法的局限。</p><ul><li><p>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</p></li><li><p>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。<br>此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以<strong>用key保存数值，用value在保存数值所在的下标。</strong></p></li></ul><p>C++中map，有三种类型：<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642218616492-image.png"></p><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。</p><p>同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。 </p><p>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</p><hr><p>注：</p><ul><li>find() 函数返回一个迭代器，指向键值为key的元素，若没找到就返回指向map尾部的迭代器。</li><li>auto<br>在C++11标准的语法中，auto被定义为自动推断变量的类型。例如：</li></ul><p><code>auto x=5.2; //这里的x被auto推断为double类型</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt;m;</span><br><span class="line">for(auto it=m.begin(); // 这里it被auto推断为map&lt;int,int&gt;::iterator类型</span><br><span class="line">it!=m.end();++it)</span><br><span class="line">&#123;</span><br><span class="line">//....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>不过C++11的auto关键字时有一个限定条件，那就是必须给申明的变量赋予一个初始值，否则编译器在编译阶段将会报错。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]); <span class="comment">// iter指向要找的那个pair </span></span><br><span class="line">            <span class="keyword">if</span> (iter != map.<span class="built_in">end</span>()) &#123; <span class="comment">// 成立说明找到了</span></span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(nums[i], i));<span class="comment">//不是要找的，就加入map中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;哈希表理论基础&quot;&gt;&lt;a href=&quot;#哈希表理论基础&quot; class=&quot;headerlink&quot; title=&quot;哈希表理论基础&quot;&gt;&lt;/a&gt;哈希表理论基础&lt;/h1&gt;&lt;p&gt;哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，看到这两个名称知道都是指h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>递归三部曲</title>
    <link href="http://example.com/2022/01/14/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    <id>http://example.com/2022/01/14/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2/</id>
    <published>2022-01-13T23:58:31.000Z</published>
    <updated>2022-01-15T08:12:12.017Z</updated>
    
    <content type="html"><![CDATA[<p>为防止丢失，在此处备份。</p><p><a href="https://lyl0724.github.io/2020/01/25/1/">原文链接</a></p><h1 id="递归解题三部曲"><a href="#递归解题三部曲" class="headerlink" title="递归解题三部曲"></a>递归解题三部曲</h1><p>何为递归？程序反复调用自身即是递归。</p><p>我自己在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。</p><p>相信很多初学者和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，<strong>因此我们只需要关注一级递归的解决过程即可。</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642117578636-image.png"><br>如上图所示，我们需要关心的主要是以下三点：</p><ol><li>整个递归的终止条件。</li><li>一级递归需要做什么？</li><li>应该返回给上一级的返回值是什么？</li></ol><p><strong>因此，也就有了我们解递归题的三部曲：</strong></p><p><strong>1. 找整个递归的终止条件：递归应该在什么时候结束？</strong><br><strong>2. 找返回值：应该给上一级返回什么信息？</strong><br><strong>3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？</strong></p><p>一定要理解这3步，这就是以后递归秒杀算法题的依据和思路。</p><p>但这么说好像很空，我们来以题目作为例子，看看怎么套这个模版，相信3道题下来，你就能慢慢理解这个模版。之后再解这种套路递归题都能直接秒了。</p><h1 id="例1：求二叉树的最大深度"><a href="#例1：求二叉树的最大深度" class="headerlink" title="例1：求二叉树的最大深度"></a>例1：求二叉树的最大深度</h1><p>先看一道简单的Leetcode题目： <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Leetcode 104. 二叉树的最大深度</a></p><p>题目很简单，求二叉树的最大深度，那么直接套递归解题三部曲模版：</p><ol><li><p><strong>找终止条件。</strong> 什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了。</p></li><li><p><strong>找返回值。</strong> 应该返回什么？题目求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回值应该是当前树的最大深度，这一步可以结合第三步来看。</p></li></ol><ol start="3"><li><strong>本级递归应该做什么。</strong> 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。</li></ol><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642117816987-image.png"></p><p>具体Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件：当树为空时结束递归，并返回当前深度0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//root的左、右子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="comment">//返回的是左右子树的最大深度+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当足够熟练后，也可以和Leetcode评论区一样，很骚的几行代码搞定问题，让之后的新手看的一脸懵逼(这道题也是我第一次一行代码搞定一道Leetcode题)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例2：两两交换链表中的节点"><a href="#例2：两两交换链表中的节点" class="headerlink" title="例2：两两交换链表中的节点"></a>例2：两两交换链表中的节点</h1><p>看了一道递归套路解决二叉树的问题后，有点套路搞定递归的感觉了吗？我们再来看一道Leetcode中等难度的链表的问题，掌握套路后这种中等难度的问题真的就是秒：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">Leetcode 24. 两两交换链表中的节点</a></p><p>直接上三部曲模版：</p><ol><li><strong>找终止条件。</strong> 什么情况下递归终止？没得交换的时候，递归就终止了呗。因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。</li><li><strong>找返回值。</strong> 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。</li><li><strong>本级递归应该做什么。</strong> 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点，就很easy了。</li></ol><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642117983772-image.png"></p><p>附上Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//终止条件：链表只剩一个节点或者没节点了，没得交换了。返回的是已经处理好的链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//一共三个节点:head, next, swapPairs(next.next)</span></span><br><span class="line">      <span class="comment">//下面的任务便是交换这3个节点中的前两个节点</span></span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">      <span class="comment">//根据第二步：返回给上一级的是当前已经完成交换后，即处理好了的链表部分</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例3：平衡二叉树"><a href="#例3：平衡二叉树" class="headerlink" title="例3：平衡二叉树"></a>例3：平衡二叉树</h1><p>相信经过以上2道题，你已经大概理解了这个模版的解题流程了。</p><p>那么请你先不看以下部分，尝试解决一下这道easy难度的Leetcode题（个人觉得此题比上面的medium难度要难）：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/comments/">Leetcode 110. 平衡二叉树</a></p><p>我觉得这个题真的是集合了模版的精髓所在，下面套三部曲模版：</p><p>1、<strong>找终止条件。</strong> </p><p>什么情况下递归应该终止？自然是子树为空的时候，空树自然是平衡二叉树了。</p><p>2、<strong>应该返回什么信息：</strong></p><p>为什么我说这个题是集合了模版精髓？正是因为此题的返回值。要知道我们搞这么多花里胡哨的，都是为了能写出正确的递归函数，因此在解这个题的时候，我们就需要思考，我们到底希望返回什么值？</p><p>何为平衡二叉树？平衡二叉树即左右两棵子树高度差不大于1的二叉树。而对于一颗树，它是一个平衡二叉树需要满足三个条件：<strong>它的左子树是平衡二叉树，它的右子树是平衡二叉树，它的左右子树的高度差不大于1。</strong> 换句话说：如果它的左子树或右子树不是平衡二叉树，或者它的左右子树高度差大于1，那么它就不是平衡二叉树。</p><p>而在我们眼里，这颗二叉树就3个节点：root、left、right。那么我们应该返回什么呢？如果返回一个当前树是否是平衡二叉树的boolean类型的值，那么我只知道left和right这两棵树是否是平衡二叉树，无法得出left和right的高度差是否不大于1，自然也就无法得出root这棵树是否是平衡二叉树了。而如果我返回的是一个平衡二叉树的高度的int类型的值，那么我就只知道两棵树的高度，但无法知道这两棵树是不是平衡二叉树，自然也就没法判断root这棵树是不是平衡二叉树了。</p><p>因此，这里我们返回的信息应该是既包含子树的深度的int类型的值，又包含子树是否是平衡二叉树的boolean类型的值。可以单独定义一个ReturnNode类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnNode</span></span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isB;</span><br><span class="line">  <span class="keyword">int</span> depth;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReturnNode</span><span class="params">(<span class="keyword">boolean</span> isB, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isB = isB;</span><br><span class="line">    <span class="keyword">this</span>.depth = depth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<strong>本级递归应该做什么。</strong></p><p>知道了第二步的返回值后，这一步就很简单了。目前树有三个节点：root，left，right。我们首先判断left子树和right子树是否是平衡二叉树，如果不是则直接返回false。再判断两树高度差是否不大于1，如果大于1也直接返回false。否则说明以root为节点的子树是平衡二叉树，那么就返回true和它的高度。</p><p>具体的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个ReturnNode是参考我描述的递归套路的第二步：思考返回值是什么</span></span><br><span class="line">    <span class="comment">//一棵树是BST等价于它的左、右俩子树都是BST且俩子树高度差不超过1</span></span><br><span class="line">    <span class="comment">//因此我认为返回值应该包含当前树是否是BST和当前树的高度这两个信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isB;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReturnNode</span><span class="params">(<span class="keyword">int</span> depth, <span class="keyword">boolean</span> isB)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isB = isB;</span><br><span class="line">            <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBST(root).isB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参考递归套路的第三部：描述单次执行过程是什么样的</span></span><br><span class="line">    <span class="comment">//这里的单次执行过程具体如下：</span></span><br><span class="line">    <span class="comment">//是否终止?-&gt;没终止的话，判断是否满足不平衡的三个条件-&gt;返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnNode <span class="title">isBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnNode(<span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不平衡的情况有3种：左树不平衡、右树不平衡、左树和右树差的绝对值大于1</span></span><br><span class="line">        ReturnNode left = isBST(root.left);</span><br><span class="line">        ReturnNode right = isBST(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left.isB == <span class="keyword">false</span> || right.isB == <span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnNode(<span class="number">0</span>, <span class="keyword">false</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left.depth - right.depth) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnNode(<span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不满足上面3种情况，说明平衡了，树的深度为左右俩子树最大深度+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnNode(Math.max(left.depth, right.depth) + <span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些可以用这个套路解决的题"><a href="#一些可以用这个套路解决的题" class="headerlink" title="一些可以用这个套路解决的题"></a>一些可以用这个套路解决的题</h1><p>暂时就写这么多啦，作为一个高考语文及格分，大学又学了工科的人，表述能力实在差因此啰啰嗦嗦写了一大堆，希望大家能理解这个很好用的套路。</p><p>下面我再列举几道我在刷题过程中遇到的也是用这个套路秒的题，真的太多了，大部分链表和树的递归题都能这么秒，因为树和链表天生就是适合递归的结构。</p><p>我会随时补充，正好大家可以看了上面三个题后可以拿这些题来练练手，看看自己是否能独立快速准确的写出递归解法了。</p><p><a href="https://leetcode-cn.com/problems/symmetric-tree/comments/">Leetcode 101. 对称二叉树</a></p><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">Leetcode 111. 二叉树的最小深度</a></p><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">Leetcode 226. 翻转二叉树</a>：这个题的备注是最骚的。Mac OS下载神器homebrew的大佬作者去面试谷歌，没做出来这道算法题，然后被谷歌面试官怼了：”我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。”</p><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">Leetcode 617. 合并二叉树</a></p><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">Leetcode 654. 最大二叉树</a></p><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Leetcode 83. 删除排序链表中的重复元素</a></p><h1 id="递归和迭代区别"><a href="#递归和迭代区别" class="headerlink" title="递归和迭代区别"></a>递归和迭代区别</h1><p>递归（recursion）：递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）</p><p>迭代（iteration）：重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）</p><hr><p>递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。</p><p>迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。</p><p>理论上递归和迭代时间复杂度方面是一样的，但实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率要低。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642125182079-image.png"></p><hr><p><strong>相同点：</strong></p><p>递归和迭代都是循环的一种。</p><p><strong>不同点：</strong></p><p>1、 程序结构不同</p><p>递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>2、算法结束方式不同</p><p>递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。 当然很多情况都是多种循环混合采用，这要根据具体需求。</p><p>3、效率不同</p><p>在循环的次数较大的时候，迭代的效率明显高于递归。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为防止丢失，在此处备份。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lyl0724.github.io/2020/01/25/1/&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;递归解题三部曲&quot;&gt;&lt;a href=&quot;#递归解题三部曲&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2022/01/13/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/13/%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-13T01:58:31.000Z</published>
    <updated>2022-01-15T08:13:42.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h1><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链接的入口节点称为链表的头结点也就是head。</p><h2 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h2><p>如图所示为<strong>单链表</strong>：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642050944130-image.png"></p><p>单链表中的节点只能指向节点的下一个节点。</p><p><strong>双链表</strong>：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p><p>双链表 既可以向前查询也可以向后查询。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642051002306-image.png"></p><p><strong>循环链表</strong>，顾名思义，就是链表首尾相连。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642051066194-image.png"></p><p>循环链表可以用来解决约瑟夫环问题。</p><blockquote><p>约瑟夫环问题为：设编号为1，2，……n得n个人围坐一圈，约定编号为k（k大于等于1并且小于等于n）的人从1开始报数，数到m的那个人出列。它的下一位继续从1开始报数，数到m的人出列，依次类推，直到所有人都出列为止。</p></blockquote><h2 id="链表的存储方式"><a href="#链表的存储方式" class="headerlink" title="链表的存储方式"></a>链表的存储方式</h2><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>如图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642051168984-image.png"></p><p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存个不同地址空间上，通过指针串联在一起。</p><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表节点的定义，很多同学在面试的时候都写不好。</p><p>这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p><p>而在面试的时候，一旦要自己手写链表，就写的错漏百出。</p><p>这里给出C/C++的定义链表节点方式，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。</p><p>但是这个构造函数不会初始化任何成员变量，下面举两个例子：</p><p>通过自己定义构造函数初始化节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>使用默认构造函数初始化节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p><h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除D节点，如图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642051936100-image.png"><br>只要将C节点的next指针 指向E节点就可以了。</p><p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p><p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p><p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>如图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642051987350-image.png"></p><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>把链表的特性和数组的特性进行一个对比，如图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642052049755-image.png"><br>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p><h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203.移除链表元素</a><br>这里以链表 1 4 2 4 来举例，移除元素4。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642052743845-image.png"><br>如果使用C，C++编程语言的话，不要忘了还要从内存中删除这两个移除的节点， 清理节点内存之后如图：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642052764567-image.png"><br>当然如果使用java ，python的话就不用手动管理内存了。</p><p>还要说明一下，就算使用C++来做leetcode，如果移除一个节点之后，没有手动在内存中删除这个节点，leetcode依然也是可以通过的，只不过，内存使用的空间大一些而已，但建议依然要养成手动清理内存的习惯。</p><p>这种情况下的移除操作，就是让节点next指针直接指向下下一个节点就可以了，</p><p>那么因为单链表的特殊性，只能指向下一个节点，刚刚删除的是链表的中第二个，和第四个节点，那么如果删除的是头结点又该怎么办呢？</p><p>这里就涉及如下链表操作的两种方式：</p><ul><li>直接使用原来的链表来进行删除操作。</li><li>设置一个虚拟头结点在进行删除操作。</li></ul><p>来看第一种操作：直接使用原来的链表来进行移除。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642052828783-image.png"><br>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p><p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642052850997-image.png"></p><p>依然别忘将原头结点从内存中删掉。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642052868413-image.png"><br>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p><p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p><p>其实可以设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p><p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642052891547-image.png"></p><p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p><p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p><p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p><p>最后呢在题目中，return 头结点的时候，别忘了 <strong>return dummyNode-&gt;next</strong>;， 这才是新的头结点</p><hr><p>下面，直接使用原来的链表来进行移除节点操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == val) &#123;</span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head -&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp; <span class="comment">// C++需要手动释放空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除非头结点</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">// 遍历变量cur初值为head</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123; <span class="comment">// 找到了值为val的结点，进行删除操作</span></span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp; </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 没找到,将cur后移，继续遍历访问链表</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置一个虚拟头结点在再进行移除节点操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 带头结点</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，方便后面的删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123; <span class="comment">// 还未达链表尾部</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li><p>时间复杂度：O(n))，其中 n 是链表的长度。需要遍历链表一次。</p></li><li><p>空间复杂度：O(1)。</p></li></ul><hr><p>上面两种是非递归方式，下面为递归方式：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642056207949-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置递归出口</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next,val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(n)，其中 n 是链表的长度。递归过程中需要遍历链表一次。</p></li><li><p>空间复杂度：O(n))，其中 n 是链表的长度。空间复杂度主要取决于递归调用栈，最多不会超过 n 层。</p></li></ul><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><p><a href="https://leetcode-cn.com/problems/design-linked-list/">707.设计链表</a></p><p>题意：</p><p>在链表类中实现这些功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</p><p>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</p><p>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</p><p>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</p><p>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642060542923-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义链表节点结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkedNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="keyword">int</span> val):<span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>); <span class="comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123; <span class="comment">// 如果--index 就会陷入死循环</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表最后面添加一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果index大于链表的长度，则返回空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    LinkedNode* _dummyHead;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206.反转链表</a></p><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p><strong>思路一：双指针法</strong></p><p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p><p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p><p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p><p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p><p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642068485729-QQ%E5%BD%95%E5%B1%8F20220113180731%2000_00_00-00_00_30.gif"></p><p>下面，反转的代码要细细品味！尤其是四步曲！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head; </span><br><span class="line">        ListNode* temp; <span class="comment">// 保存cur的下一个结点</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 作为反转后链表的尾部</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123; <span class="comment">// 【四步曲，精彩绝伦！】</span></span><br><span class="line">            temp = cur-&gt;next; <span class="comment">// 保存一下 cur的下一个结点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">// 反转操作 </span></span><br><span class="line">            pre = cur; <span class="comment">// 后移 pre 指针！</span></span><br><span class="line">            cur = temp; <span class="comment">// 后移 cur 指针！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路二：递归法</strong></p><p>递归法相对抽象一些，但是其实和双指针法是一样的逻辑，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。</p><p>关键是初始化的地方，可能有的同学会不理解， 可以看到双指针法中初始化 cur = head，pre = NULL，在递归法中可以从如下代码看出初始化的逻辑也是一样的，只不过写法变了。</p><p><strong>悟了！看动图，cur前移，pre也跟着。这两步操作永远都连在一起，这就是递归的规律！</strong></p><p><strong>只有在充分理解了非递归方式的实现思路之后，才能更加深入体会递归的写法！</strong></p><p>具体可以看代码（已经详细注释），双指针法写出来之后，理解如下递归写法就不难了，代码逻辑都是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre, ListNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="comment">// 可以和双指针法进行对比，如下递归的写法，其实是做了这两步</span></span><br><span class="line">        <span class="comment">// pre = cur;</span></span><br><span class="line">        <span class="comment">// cur = tmp;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(cur, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和双指针法初始化一样的逻辑</span></span><br><span class="line">        <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">        <span class="comment">// ListNode* pre = nullptr; // 反转后的链表尾部</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">nullptr</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，上面的递归写法和双指针法实质上都是<strong>从前往后翻转指针指向</strong>，其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边缘条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用，反转第二个结点开始往后的链表</span></span><br><span class="line">        ListNode* last = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        <span class="comment">// 反转头结点与第二个结点的指向</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        <span class="comment">// 此时的 head 结点为尾结点，next 需要指向nullptr</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p><p><strong>思路一：递归</strong></p><p>向大佬学习：<br><a href="https://lyl0724.github.io/2020/01/25/1/">三道题套路解决递归问题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 1、找终止条件：本题终止条件很明显，当递归到链表为空或者链表只剩一个元素的时候，没得交换了，自然就终止了。</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3、单次的过程：因为递归是重复做一样的事情，所以从宏观上考虑，只用考虑某一步是怎么完成的。</span></span><br><span class="line">        <span class="comment">//    我们假设待交换的俩节点分别为head和next，next的应该接受上一级返回的子链表(参考第2步)。</span></span><br><span class="line">        <span class="comment">//    就相当于是一个含三个节点的链表交换前两个节点，就很简单了，想不明白的画画图就ok。</span></span><br><span class="line">        <span class="comment">// 位置分别为： head next 已交换好的链表 【目标：】 next head 已交换好的链表</span></span><br><span class="line">        ListNode* next = head-&gt;next; </span><br><span class="line">        head-&gt;next = <span class="built_in">swapPairs</span>(next-&gt;next);</span><br><span class="line">        next-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、找返回值：返回给上一层递归的值应该是已经交换完成后的子链表。</span></span><br><span class="line">        <span class="keyword">return</span> next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析:</p><ul><li><p>时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。</p></li><li><p>空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。</p></li></ul><hr><p>这种标记<strong>one、two、three</strong> 的写法真不错！！</p><p>标记好1、2、3号节点，谁都看的懂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* one = head;</span><br><span class="line">        ListNode* two = one-&gt;next;</span><br><span class="line">        ListNode* three = two-&gt;next;</span><br><span class="line"></span><br><span class="line">        two-&gt;next = one;</span><br><span class="line">        one-&gt;next = <span class="built_in">swapPairs</span>(three);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> two;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路二：迭代</strong></p><p>初始时，cur指向虚拟头结点，然后进行如下三步：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642130924392-%EF%BF%BD1TQY6~FTN%2507Z2YSPH.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，以方便后面删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 下面这俩结点，是为了防止cur指向3号结点导致连接丢失，故保存一下</span></span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 记录临时节点：即演示图中 1 号结点</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时结点：即演示图中 3 号结点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">// 步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp; <span class="comment">// 步骤二</span></span><br><span class="line">            <span class="comment">// 想一下为什么下面不能tmp = tmp1？ 因为前两步已经更新过链表结点之间的连接了，动态的思维得有！</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1; <span class="comment">// 步骤三   </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 【迭代！】这里理解一下，前两位已交换好，后面继续进行迭代。</span></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next; <span class="comment">// 返回头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析:</p><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第N个节点</a></p><p>双指针的经典应用,分为如下几步：</p><ul><li>定义fast指针和slow指针，初始值为虚拟头结点</li><li>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）</li><li>fast和slow同时移动，直到fast指向末尾</li><li>删除slow指向的下一个节点<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642140142712-M9OMWVM%60FRW5$%5BBC%5BCSD%5D@S.png"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n-- &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next; <span class="comment">// 将快指针后移n个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next; <span class="comment">// fast多走一步，是为了让slow少走一步，因为需要让slow指向删除结点的上一个结点！</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表相交-只要以相同的速度前进，就一定有机会遇见你！"><a href="#链表相交-只要以相同的速度前进，就一定有机会遇见你！" class="headerlink" title="链表相交(只要以相同的速度前进，就一定有机会遇见你！)"></a>链表相交(只要以相同的速度前进，就一定有机会遇见你！)</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642145285679-image.png"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><hr><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642146040774-image.png"></p><p>设交集链表长 c , 链表1除交集的长度为 a，链表2除交集的长度为 b，有</p><ul><li><strong>若相交，两人走过的是路长是一致的，会同时达到点</strong>。</li></ul><p>&emsp;&emsp;<strong>a + c + b(走对方的路)  =  b + c + a(走对方的路)</strong></p><p>&emsp;&emsp;解释：curA（指向headA）走完路径 a 、路径 c 之后，跳到headB上走路径 b。 倘若，二者有交集。则curB也会在走完路径 b 、 路径 c 之后，跳到headA上走路径 a。由于他俩路径总长度相同，故于路径 c 的第一个元素处相逢！此时while循环不满足curA != curB条件，退出循环，并返回相交的结点。</p><ul><li><strong>若无交集，也就各自走过一生</strong></li></ul><p>&emsp;&emsp;<strong>a + b = b + a  =&gt; NULL</strong></p><p>&emsp;&emsp;解释：curA走完 a 和 b， curB走完 b 和 a。最后两个指针会同时指向 NULL，化为尘埃。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642146343417-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要么相遇即节点相等，要么都为空即无缘无分，最终都能跳出感情的死循环。</span></span><br><span class="line">        <span class="keyword">while</span> (curA != curB) &#123;</span><br><span class="line">        <span class="comment">// 两人以相同的速度（一次一步）沿着各自的路径走，当走完各自的路时，再走对方的路。（起点平齐速度相同，终点即为相遇点）</span></span><br><span class="line">            curA = (curA == <span class="literal">nullptr</span> ? headB : curA-&gt;next); <span class="comment">// a + c + b</span></span><br><span class="line">            curB = (curB == <span class="literal">nullptr</span> ? headA : curB-&gt;next); <span class="comment">// b + c + a</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> curA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142.环形链表II</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-14/1642147497184-image.png"></p><p><strong>思路一：哈希表</strong></p><p>&emsp;&emsp;遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><p>复杂度分析：</p><ul><li><p>时间复杂度O(n)，其中 n 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。</p></li><li><p>空间复杂度O(n)，其中 n 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。</p></li></ul><p><a href="https://zh.cppreference.com/w/cpp/container/unordered_set">unordered_set函数文档</a></p><p>其中的count()函数只会返回1或0，存在返回1，不存在返回0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; visited;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(head)) &#123; <span class="comment">// 存在返回1，否则返回0</span></span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路二：双指针法</strong></p><ol><li><p>先判断是否存在环</p></li><li><p>当第一次快慢指针相遇时，说明存在环，此时相遇点在圆内，此时慢指针走过的距离是x+y，快指针走过的距离是x+y+z+y，因为快指针走过的距离是慢指针的2倍，所以得到等式2（x+y）= x+y+z+y,所以x = z</p></li><li><p>接下来，令p = head，让p和slow同时再走一段距离为x的路程，二者就在环入口相遇。<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-15/1642204019994-image.png"></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* p = head; <span class="comment">// x = z 中的 x，用于找到环入口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、先判断有无环路，由推导，当x = z时，二者相遇即有环</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123; <span class="comment">// fast被成功赋值 &amp;&amp; 链表不为空</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">// 如果链表存在环</span></span><br><span class="line">                <span class="keyword">while</span> (p != slow) &#123; <span class="comment">// x = z</span></span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>链表理论基础：</strong></p><ul><li>链表的种类主要为：单链表，双链表，循环链表</li><li>链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。</li><li>链表是如何进行增删改查的。</li><li>数组和链表在不同场景下的性能分析。</li></ul><p><strong>虚拟头结点：</strong></p><p>链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。</p><p>每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题。</p><p><strong>链表的基本操作:</strong></p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点的数值</li></ul><p><strong>反转链表:</strong><br>因为反转链表的代码相对简单，有的同学可能直接背下来了，但一写还是容易出问题。</p><p>反转链表是面试中高频题目，很考察面试者对链表操作的熟练程度。</p><p>双指针法和递归法，这里的递归法绝绝子，三部曲yyds！</p><p><strong>两两交换链表中的节点</strong></p><p>递归法、以及迭代法，这里的递归用到了：将三个结点编号： one two three 的表示方法，写代码的时候很直观，写法很不错。</p><p><strong>删除倒数第N个节点</strong><br>结合虚拟头结点 和 双指针法来移除链表倒数第N个节点。</p><p><strong>链表相交</strong><br>使用双指针来找到两个链表的交点（引用完全相同，即：内存地址完全相同的交点）</p><p><strong>环形链表</strong></p><p>难点在于链表如何找环，以及如何找环的入口位置。</p><p>这道题目可以说是链表的比较难的题目了。 但代码却十分简洁，主要在于一些数学证明。</p><hr><p><strong>总之，考察链表的操作其实就是考察指针的操作，是面试中的常见类型。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表理论基础&quot;&gt;&lt;a href=&quot;#链表理论基础&quot; class=&quot;headerlink&quot; title=&quot;链表理论基础&quot;&gt;&lt;/a&gt;链表理论基础&lt;/h1&gt;&lt;p&gt;链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不疯魔不成活</title>
    <link href="http://example.com/2022/01/04/%E4%B8%8D%E7%96%AF%E9%AD%94%E4%B8%8D%E6%88%90%E6%B4%BB/"/>
    <id>http://example.com/2022/01/04/%E4%B8%8D%E7%96%AF%E9%AD%94%E4%B8%8D%E6%88%90%E6%B4%BB/</id>
    <published>2022-01-04T02:24:31.000Z</published>
    <updated>2022-01-04T03:43:49.319Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;昨晚看了《爆裂鼓手》，两个追求极致的偏执狂，相爱相杀，相互成就。</p><p>&emsp;&emsp;安德鲁在练鼓时，时常满手鲜血，他只是一层又一层的创口贴，疼到不行了，直接将手伸入冰块，直至冰块也被鲜血浸透。为了赶上演出证明自己，在出车祸后仍然坚持上台，拿回属于自己的位置。</p><p>&emsp;&emsp;弗莱彻在指挥乐队训练时，从来没一句好话，花式骂人的本事实属顶尖，他拒绝 “ Good job “ 、追求极致、渴望培养出一个下一个查理帕克，极尽人格魅力！<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641266406890-v2-52184c7827e7d1dbce8958f169af7b97_720w.gif"></p><p>&emsp;&emsp;真正对梦想有执念的灵魂，永远不会改行学医、上吊自杀。在成神的道路上，一将功成万骨枯或许才是常态。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265071021-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265107218-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265118898-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265132944-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265154881-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265171443-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265187194-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265205152-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265212885-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265225769-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265237604-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265248868-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265274669-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265285521-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265297773-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265309733-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265335846-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265347470-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265359672-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265369018-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265376791-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265387534-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265399806-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265412195-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265428534-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265444527-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265459294-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265468637-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265478489-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265488314-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265500257-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265510070-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265525366-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265536441-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265550844-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265560950-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265576208-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265587511-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265599247-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265617221-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265635934-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265647183-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265656352-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265664587-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265673399-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265683279-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-4/1641265702448-image.png"></p><p>&emsp;&emsp;<font color = black size=5>也希望自己能沉浸在自己的领域里，昂扬斗志，摆脱他人的成见，坚定自己的步伐，在考研的道路上：</p>  <p style="text-align:center"><font color = red size=10>“不疯魔不成活”]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;昨晚看了《爆裂鼓手》，两个追求极致的偏执狂，相爱相杀，相互成就。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;安德鲁在练鼓时，时常满手鲜血，他只是一层又一层的创口贴，疼到不行了，直接将手伸入冰块，直至冰块也被鲜血浸透。为了赶上演出证明自己，在出车祸后仍然坚</summary>
      
    
    
    
    <category term="随笔录" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94%E5%BD%95/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络1-6合集</title>
    <link href="http://example.com/2021/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1-6%E5%90%88%E9%9B%86/"/>
    <id>http://example.com/2021/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1-6%E5%90%88%E9%9B%86/</id>
    <published>2021-12-30T14:48:31.000Z</published>
    <updated>2022-01-02T18:25:46.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="———概述———"><a href="#———概述———" class="headerlink" title="———概述———"></a>———概述———</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640181013096-image.png"></p><h2 id="图示说明"><a href="#图示说明" class="headerlink" title="图示说明"></a>图示说明</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640140187772-image.png" alt="img"></p><h1 id="计算机网络在信息时代的作用"><a href="#计算机网络在信息时代的作用" class="headerlink" title="计算机网络在信息时代的作用"></a>计算机网络在信息时代的作用</h1><ul><li>计算机网络已由一种<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></li><li>计算机网络已经像水，电，煤气这些基础设施一样，成为我们<strong>生活中不可或缺</strong>的一部分</li></ul><h2 id="我国互联网发展状况"><a href="#我国互联网发展状况" class="headerlink" title="我国互联网发展状况"></a>我国互联网发展状况</h2><p><a href="http://www.cnnic.net.cn/">中国互联网络信息中心 CNNIC</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141190161-image.png" alt="图1"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141215545-image.png" alt="图2"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141229008-image.png" alt="图3"></p><p>&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;</p><h1 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h1><h2 id="网络、互连网（互联网）和因特网"><a href="#网络、互连网（互联网）和因特网" class="headerlink" title="网络、互连网（互联网）和因特网"></a>网络、互连网（互联网）和因特网</h2><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141514917-image.png" alt="img"></p><p>互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141566006-image.png" alt="img"></p><p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141600956-image.png" alt="img"></p><blockquote><p><strong>internet 与 Internet 的区别</strong></p><ul><li>**internet(互联网或互连网)**是一个通用名词，它泛指**多个计算机网络互连而成的网络**。在这些网络之间的通信协议可以是任意的。</li><li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用 TCP/IP 协议族作为通信的规则，其前身是美国的 ARPANET。</li></ul><p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141714937-image.png" alt="img"></p><h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141753427-image.png" alt="img"></p><p><strong>因特网服务提供者<code>ISP</code>(<code>I</code>nternet <code>S</code>ervice <code>P</code>rovider)</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141782854-image.png" alt="img"></p><blockquote><p>普通用户是如何接入到因特网的呢？</p><p>答：<strong>通过 ISP 接入因特网</strong></p><p>ISP 可以从因特网管理机构申请到成块的 IP 地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP 的得到所需要的 IP 地址</strong>。</p><p><strong>因为因特网上的主机都必须有 IP 地址才能进行通信，这样就可以通过该 ISP 接入到因特网</strong></p></blockquote><p><strong>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141910497-image.png" alt="img"></p><p><strong>基于 ISP 的三层结构的因特网</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141947834-image.png" alt="img"></p><blockquote><p>一旦某个用户能够接入到因特网，那么他也可以成为一个 ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p></blockquote><h2 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h2><ul><li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li><li>因特网在指定其标准上的一个很大的特点是<strong>面向公众。</strong><ul><li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><strong>因特网协会 ISOC</strong>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。<ul><li>因特网体系结构委员会 IAB，负责管理因特网有关协议的开发；</li><li>因特网工程部 IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li><li>因特网研究部 IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141976391-image.png" alt="img"></p><ul><li><p>制订因特网的正式标准要经过一下<strong>4 个阶段</strong>：</p><p>1、因特网草案（在这个阶段还不是 RFC 文档）</p><p>2、建议标准（从这个阶段开始就成为 RFC 文档）</p><p>3、草案标准</p><p>4、因特网标准</p></li></ul><h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><ul><li><p>边缘部分</p><p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p></li><li><p>核心部分</p><p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142067589-image.png" alt="img"></p><blockquote><p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p><p><strong>端系统在功能上可能有很大的差别：</strong></p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP。</li></ol></blockquote><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p><strong>端系统之间通信的含义</strong></p><p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p><p>端系统之间的通信方式通常可划分为两大类：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142092193-image.png" alt="img"></p><p><strong>客户-服务器方式：</strong></p><ul><li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li><li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务的请求方，服务器是服务的提供方。</li></ul><blockquote><p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p></blockquote><p><strong>对等连接方式：</strong></p><ul><li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li><li>双方都可以下载对方已经存储在硬盘中的共享文档。</li></ul><hr><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p><p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p><h2 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142116823-image.png" alt="img"></p><blockquote><p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p><p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142131861-image.png" alt="img"></p><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p></li><li><p>电路交换的三个步骤：</p><p>1、建立连接（分配通信资源）</p><p>2、通话（一直占用通信资源）</p><p>3、释放连接（归还通信资源）</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142172494-image.png" alt="img"></p><blockquote><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><p>这是因为计算机数据是突发式地出现在传输线路上的。</p><p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p></blockquote><h2 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142187700-image.png" alt="img"></p><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器</p><ul><li>缓存分组</li><li>转发分组</li><li>简称为“分组转发”</li></ul><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><ol><li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li><li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口<strong>转发</strong>出去。</li></ol></blockquote><p>接收方</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="报文交换（Message-Switching）"><a href="#报文交换（Message-Switching）" class="headerlink" title="报文交换（Message Switching）"></a>报文交换（Message Switching）</h2><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><blockquote><p>假设 A，B，C，D 是分组传输路径所要经过的 4 个结点交换机，纵坐标为时间</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142205748-image.png" alt="img"></p><p>分析：</p><p>电路交换：</p><ul><li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li><li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li></ul><p>报文交换：</p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><p>分组交换：</p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142227189-image.png" alt="img"></p><hr><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>计算机网络的精确定义并未统一</li><li>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。<ul><li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li><li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li><li>集合：是指至少需要两台计算机；</li></ul></li><li>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机 CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ul></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li>公用网</li><li>专用网</li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网 WAN（Wide Area Network）</li></ul><p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p><ul><li>城域网 MAN</li></ul><p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p><ul><li>局域网 LAN</li></ul><p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右）</p><ul><li>个域网 PAN</li></ul><p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p><p><strong>按拓扑结构分类：</strong></p><ul><li>总线型网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142269206-image.png" alt="img"></p><ul><li>星型网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142276589-image.png" alt="img"></p><ul><li>环形网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142284505-image.png" alt="img"></p><ul><li>网状型网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142292234-image.png" alt="img"></p><hr><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142311959-image.png" alt="img"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142327572-image.png" alt="img"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142343767-image.png" alt="img"></p><blockquote><p>带宽 1 Gb/s 的以太网，代表其额定速率是 1 Gb/s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽 1 Gb/s 的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低。</p><p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p></blockquote><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li>发送时延</li></ul><p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><ul><li>传播时延</li></ul><p>电磁波在信道中传播一定的距离需要花费的时间。</p><ul><li>处理时延</li></ul><p>主机或路由器在收到分组时要花费一定时间进行处理</p><ul><li>排队时延</li></ul><p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><blockquote><p>有时会把排队时延看成<strong>处理时延 一部分</strong></p><p>总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142380749-image.png" alt="img"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142399039-image.png" alt="img"></p><blockquote><p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p></blockquote><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 = 传播时延 * 带宽</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142413686-image.png" alt="img"></p><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142425942-image.png" alt="img"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142439263-image.png" alt="img"></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142449337-image.png" alt="img"></p><hr><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="1、常见的计算机网络体系结构"><a href="#1、常见的计算机网络体系结构" class="headerlink" title="1、常见的计算机网络体系结构"></a>1、常见的计算机网络体系结构</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142464891-image.png" alt="img"></p><blockquote><p>如今用的最多的是 TCP/IP 体系结构，现今规模最大的、覆盖全球的、基于 TCP/IP 的互联网并未使用 OSI 标准。</p><p>TCP/IP 体系结构相当于将 OSI 体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>TCP/IP 在网络层使用的协议是 IP 协议，IP 协议的意思是网际协议，因此<strong>TCP/IP 体系结构的网络层称为网际层</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142477688-image.png" alt="img"></p><blockquote><p>在用户主机的操作系统中，通常都带有符合 TCP/IP 体系结构标准的 TCP/IP 协议族。</p><p>而用于网络互连的路由器中，也带有符合 TCP/IP 体系结构标准的 TCP/IP 协议族。</p><p>只不过路由器一般只包含网络接口层和网际层。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142621853-image.png" alt="img"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的 WIFI 接口等。</p><p><strong>网际层</strong>：它的核心协议是 IP 协议。</p><p><strong>运输层</strong>：TCP 和 UDP 是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p></blockquote><blockquote><p><strong>IP 协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP 协议和 UDP 协议（运输层）</strong>提供网络互连服务</p><p>而<strong>TCP 协议</strong>在享受 IP 协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p><p><strong>UDP 协议</strong>在享受 IP 协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p></blockquote><blockquote><p>TCP/IP 体系结构中最重要的是<strong>IP 协议</strong>和<strong>TCP 协议</strong>，因此用 TCP 和 IP 来表示整个协议大家族。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142685463-image.png" alt="img"></p><blockquote><p>教学时把 TCP/IP 体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p></blockquote><h2 id="2、计算机网络体系结构分层的必要性"><a href="#2、计算机网络体系结构分层的必要性" class="headerlink" title="2、计算机网络体系结构分层的必要性"></a>2、计算机网络体系结构分层的必要性</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142719723-image.png" alt="img"></p><p><strong>物理层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142735117-image.png" alt="img"></p><blockquote><p>这图说明</p><ul><li>第一，严格来说，传输媒体并不属于物理层</li><li>计算机传输的信号，并不是图示的方波信号</li></ul><p>这样举例只是让初学者容易理解</p></blockquote><p><strong>数据链路层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142771978-image.png" alt="img"></p><p><strong>网络层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142823123-image.png" alt="img"></p><p><strong>运输层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142861590-image.png" alt="img"></p><blockquote><p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是 QQ 进程</p></blockquote><p><strong>应用层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142871692-image.png" alt="img"></p><blockquote><p>应用层该用什么方法（应用层协议）去解析数据</p></blockquote><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142894542-image.png" alt="img"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142938911-image.png" alt="img"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142947701-image.png" alt="img"></p><h2 id="3、计算机网络体系结构分层思想举例"><a href="#3、计算机网络体系结构分层思想举例" class="headerlink" title="3、计算机网络体系结构分层思想举例"></a>3、计算机网络体系结构分层思想举例</h2><p>例子：主机的浏览器如何与 Web 服务器进行通信</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142999599-image.png" alt="img"></p><p><strong>解析：</strong></p><p>主机和 Web 服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与 Web 服务器中的<strong>Web 服务器应用进程</strong>之间基于<strong>网络的通信</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143034227-image.png" alt="img"></p><p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p><p><strong>1、发送方发送</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143045601-image.png" alt="img"></p><blockquote><p>第一步：</p><ul><li><strong>应用层</strong>按照 HTTP 协议的规定构建一个<strong>HTTP 请求报文</strong></li><li>应用层将<strong>HTTP 请求报文</strong>交付给<strong>运输层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143058037-image.png" alt="img"></p><blockquote><p>第二步：</p><ul><li><strong>运输层</strong>给<strong>HTTP 请求报文</strong>添加一个<strong>TCP 首部</strong>，使之成为<strong>TCP 报文段</strong></li><li><strong>TCP 报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</li><li><strong>运输层</strong>将 T<strong>CP 报文段</strong>交付给<strong>网络层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143069985-image.png" alt="img"></p><blockquote><p>第三步：</p><ul><li><strong>网络层</strong>给<strong>TCP 报文段</strong>添加一个<strong>IP 首部</strong>，使之成为<strong>IP 数据报</strong></li><li><strong>IP 数据报的首部格式</strong>作用是使<strong>IP 数据报</strong>可以在互联网传输，也就是被路由器转发</li><li><strong>网络层</strong>将<strong>IP 数据报</strong>交付给<strong>数据链路层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143087179-image.png" alt="img"></p><blockquote><p>第四步：</p><ul><li><strong>数据链路层</strong>给<strong>IP 数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</li><li>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</li><li>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</li><li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143112339-image.png" alt="img"></p><blockquote><p>第五步：</p><ul><li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络 N1 假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li><li><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143120335-image.png" alt="img"></p><blockquote><p>第六步：</p><ul><li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li></ul></blockquote><p><strong>2、路由器转发</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143139107-image.png" alt="img"></p><blockquote><p>在路由器中</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP 数据报</strong></li><li><strong>网络层</strong>解析<strong>IP 数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143194532-image.png" alt="img"></p><blockquote><p>在路由器中</p><ul><li>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</li><li><strong>网络层</strong>将<strong>IP 数据报</strong>交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>给<strong>IP 数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></li><li><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></li><li><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络 N2 假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web 服务器</strong></li></ul></blockquote><p><strong>3、接收方接收</strong></p><blockquote><p>和发送方（主机）发送过程的封装正好是反着来</p><p>在 Web 服务器上</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP 数据报</strong>，将其交付给<strong>网络层</strong></li><li><strong>网络层</strong>将<strong>IP 数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP 报文段</strong>，将其交付给<strong>运输层</strong></li><li><strong>运输层</strong>将<strong>TCP 报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP 请求报文</strong>，将其交付给<strong>应用层</strong></li><li><strong>应用层</strong>对<strong>HTTP 请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li></ul><p><strong>发回响应报文的步骤和之前过程类似</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143241911-image.png" alt="img"></p><h2 id="4、计算机网络体系结构中的专用术语"><a href="#4、计算机网络体系结构中的专用术语" class="headerlink" title="4、计算机网络体系结构中的专用术语"></a>4、计算机网络体系结构中的专用术语</h2><p>以下介绍的专用术语来源于 OSI 的七层协议体系结构，但也适用于 TCP/IP 的四层体系结构和五层协议体系结构</p><p><strong>实体</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143250955-image.png" alt="img"></p><p><strong>协议</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143267151-image.png" alt="img"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><p>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><strong>服务</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143284271-image.png" alt="img"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143297199-image.png" alt="img"></h2><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143304707-image.png" alt="img" style="zoom:80%;" /><hr><hr><hr><hr><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640308533240-image.png"></p><h1 id="———物理层———"><a href="#———物理层———" class="headerlink" title="———物理层———"></a>———物理层———</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259223415-image.png"></p><hr><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259604351-image.png"></p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p><p><strong>同轴电缆</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259540435-image.png"></p><p><strong>双绞线</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259806097-image.png"></p><p><strong>光纤</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259966233-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260067975-image.png"></p><blockquote><p><strong>多模光纤</strong></p><ul><li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li></ul><p><strong>单模光纤</strong></p><ul><li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260185225-image.png"></p><p><strong>电力线</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260291823-image.png"></p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><p>非导引型传输媒体是指自由空间。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260368722-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260394180-image.png"></p><p><strong>无线电波</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260452471-image.png"></p><p><strong>微波</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260587933-image.png"></p><p><strong>红外线</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260617724-image.png"></p><p><strong>可见光</strong></p><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260751497-image.png"></p><hr><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260914464-image.png"></p><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260971554-image.png"></p><blockquote><p><strong>串行传输</strong>：</p><ul><li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li></ul><p><strong>并行传输</strong>：</p><ul><li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p></li><li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p></li></ul><p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p></blockquote><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261108573-image.png"></p><blockquote><p><strong>同步传输</strong>：</p><ul><li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li></ul><p>所以要使收发双发时钟保持同步</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261212383-image.png"></p><blockquote><p><strong>异步传输</strong>：</p><ul><li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul></blockquote><h2 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h2><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><p><strong>单向通信</strong>：</p><p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261264213-image.png"></p><p><strong>双向交替通信</strong>：</p><p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261300994-image.png"></p><p><strong>双向同时通信</strong>：</p><p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261336625-image.png"></p><blockquote><p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p><p><strong>双向同时通信</strong>的传输效率最高</p></blockquote><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261776448-image.png"></p><blockquote><p><strong>常用术语</strong></p><ul><li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p></li><li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </p></li><li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </p></li><li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </p></li><li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p></li><li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p></li><li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。 </p></li></ul></blockquote><p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261880083-image.png"></p><h2 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h2><blockquote><p><strong>信道的几个基本概念</strong></p><ul><li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li><li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。 </li></ul></blockquote><p>严格来说，传输媒体不能和信道划等号</p><p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261952688-image.png"></p><p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261962121-image.png"></p><blockquote><p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p></blockquote><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><p><strong>不归零编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640263170240-image.png"></p><blockquote><ul><li><p>正电平表示比特1/0</p></li><li><p>负电平表示比特0/1</p></li></ul><p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640263155180-image.png"></p><blockquote><p>这需要发送方的发送与接收方的接收做到严格的同步</p><ul><li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li><li><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</li></ul><p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p></blockquote><p><strong>归零编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265622989-image.png"></p><blockquote><p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p></blockquote><p><strong>曼彻斯特编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265727495-image.png"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发生跳变</p><ul><li>负跳变表示比特1/0</li><li>正跳变表示比特0/1</li><li>码元中间时刻的跳变即表示时钟，又表示数据</li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>传统以太网使用的就是曼切斯特编码</p></blockquote><p><strong>差分曼彻斯特编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265711075-image.png"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li><strong>跳变仅表示时钟</strong></li><li><strong>码元开始处电平是否变换表示数据</strong><ul><li>变化表示比特1/0</li><li>不变化表示比特0/1</li></ul></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p></blockquote><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265881275-image.png"><br><strong>练习</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265989291-image.png"></p><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK/直接序列扩频DSSS/正交频分复用OFDM等<strong>调制</strong>方式。</p><p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p><p><strong>基本调制方法</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266143531-image.png"></p><blockquote><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li></ul><p>但是使用基本调制方法，1个码元只能包含1个比特信息</p></blockquote><p><strong>混合调制</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266190433-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266225459-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266448474-image.png"></p><blockquote><p>下图中一个绿点是一个码元（在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。）</p></blockquote><blockquote><p>每个码元对应4个bit原因：由于QAM可以调制出16种波形，每个波形对应1个码元，所以1个码元需要包含4个bit</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266460203-image.png"></p><blockquote><p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266483834-image.png"></p><blockquote><p>用<a href="https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858?fr=aladdin">格雷码</a>（在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code））的原因是可以降低出错个数，原先最多错四个，用格雷码最多错1个</p></blockquote><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267500705-image.png"></p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267528943-image.png"></p><blockquote><p>三种基本调制方法，它们属于二元调制，只能产生两种不同的码元，也就是两种不同的基本波形，因此每个码元只能携带1比特的信息量<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267784141-image.png"></p></blockquote><blockquote><p>混合调制，属于多元调制，例如QAM16可以调制出16种不同的码元，因此每个码元可以携带4比特的信息量<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267999915-image.png"></p></blockquote><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267544466-image.png"></p><p>奈氏准则和香农公式对比：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267558877-image.png"></p><hr><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640268507728-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640268670854-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640268784941-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269048914-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269228282-image.png"></p><h1 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h1><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p><h2 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h2><p>复用 (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269303651-image.png"></p><p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269318712-image.png"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong> </p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269333875-image.png"></p><ul><li><strong>时分复用可能会造成线路资源的浪费</strong><ul><li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269348614-image.png"></p><p><strong>统计时分复用 STDM  (Statistic TDM)</strong> </p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269364876-image.png"></p><h2 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h2><p>波分复用 WDM(Wavelength Division Multiplexing)</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269377651-image.png"></p><h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用 CDM  (Code Division Multiplexing)</p><ul><li><p>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</p></li><li><p>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</p></li><li><p>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 </p><hr><hr><hr></li></ul><h1 id="———数据链路层———"><a href="#———数据链路层———" class="headerlink" title="———数据链路层———"></a>———数据链路层———</h1><h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312728522-image.png"></p><p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312777033-image.png"></p><p><strong>从层次上来看数据的流动</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312791879-image.png"></p><p><strong>仅从数据链路层观察帧的流动</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312811205-image.png"></p><blockquote><p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p><p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p></blockquote><p><strong>数据链路层使用的信道</strong></p><p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p><ul><li>点对点信道</li><li>广播信道</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312837624-image.png"></p><blockquote><p><strong>局域网属于数据链路层</strong></p><p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p></blockquote><h2 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong></p><p><strong>封装成帧</strong></p><ul><li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li></ul><p>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640314041498-sj%2000_00_00-00_00_30.gif"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313333856-image.png"></p><p><strong>差错控制</strong></p><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313367315-image.png"></p><p><strong>可靠传输</strong></p><p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p><p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p><p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313500264-image.png"></p><blockquote><p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p></blockquote><p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p><p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313394267-image.png"></p><p>可以用编址（地址）的来解决</p><p>将帧的目的地址添加在帧中一起传输</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313406046-image.png"></p><p>还有数据碰撞问题</p><p>当总线上多台主机同时使用总线来传输帧时，传输信号就会产生碰撞，这是采用广播信道的共享式局域网不可避免的。</p><p>以太网采用的协调方法是，使用一种特殊的协议CSMA/CD，也就是载波监听多点接入/碰撞检测。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313456595-image.png"><br>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640319180335-pz%2000_00_00-00_00_30.gif"></p><blockquote><p>随着技术的发展，交换技术的成熟，</p><p>在 有线（局域网）领域，使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p></blockquote><blockquote><p>由于无线信道的广播天性，在无线局域网中仍然使用的是共享信道技术<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640319597874-image.png"></p></blockquote><hr><h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><p><strong>帧头和帧尾中包含有重要的控制信息</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640319932420-image.png"></p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p><p>答：需要帧头和帧尾来做<strong>帧定界</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324243929-image.png"></p><p>但并不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324270462-image.png"></p><blockquote><p>前导码</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li></ul></blockquote><p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324288162-image.png"></p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote><p><strong>透明</strong></p><p>指某一个实际存在的事物看起来却好像不存在一样。</p></blockquote><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p><p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324303083-image.png"></p><blockquote><p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p></blockquote><p><strong>解决透明传输问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324314803-image.png"></p><ul><li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li><li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </li></ul><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324744629-image.png"></p><p><strong>帧的数据部分长度</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324332901-image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324350602-image.png"></p><hr><h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324982632-image.png"></p><blockquote><p>FCS：帧检验序列（Frame Check Sequence）</p></blockquote><blockquote><p>在以太网V2的MAC帧格式的帧尾中，包含了一个长度为4字节的FCS字段。其作用就是让接收方的数据链路层，检查帧在传输过程中是否产生了误码。</p></blockquote><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324994961-image.png"></p><h2 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325046940-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325063159-image.png"></p><p><strong>例题</strong></p><p>例1：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325078192-image.png"></p><p>动图步骤分解：</p><blockquote><p>1、构造被除数<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640326756646-11%2000_00_00-00_00_30.gif"></p></blockquote><blockquote><p>2、构造除数<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640326950205-2%2000_00_00-00_00_30.gif"></p></blockquote><blockquote><p>3、做除法<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327169619-34%2000_00_00-00_00_30.gif"><br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327428849-33%2000_00_00-00_00_30.gif"></p></blockquote><blockquote><p>4、检查余数<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327550182-44%2000_00_00-00_00_30.gif"></p></blockquote><p>例2：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327686674-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325102006-image.png"></p><blockquote><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p></blockquote><hr><h1 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>下面是比特差错</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328428971-image.png"></p><p><strong>其他传输差错</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328449618-image.png"></p><ul><li>分组丢失</li></ul><p>路由器输入队列快满了，主动丢弃收到的分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640329002352-fz1%2000_00_00-00_00_30.gif"></p><ul><li>分组失序</li></ul><p>数据并未按照发送顺序依次到达接收端</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328905281-fz%2000_00_00-00_00_30.gif"></p><ul><li>分组重复</li></ul><p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640329132983-fz2%2000_00_00-00_00_30.gif"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328488142-image.png"></p><h2 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h2><ul><li>停止-等待协议SW</li><li>回退N帧协议GBN</li><li>选择重传协议SR</li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h2 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h2><h3 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h3><p><strong>确认与否认</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333062021-image.png"><br>NAK：否认分组（Negative Acknowledgment， 没有应答）</p><p>小结：<br>发送方每发完一个数据分组后，并不能立即将该数据分组从缓存中删除，只有在收到针对该数据分组的确认分组后，才能将其从缓存中删除。</p><p><strong>超时重传</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333467075-image.png"></p><p><strong>确认丢失</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333489799-image.png"></p><p>一个比特编号，也就是说用0和1即可。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333499360-image.png"></p><blockquote><p>既然数据分组需要编号，确认分组是否需要编号？</p><p>要。如下图所示</p></blockquote><p><strong>确认迟到</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333999427-image.png"></p><blockquote><p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p></blockquote><p><strong>注意事项</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334338739-image.png"></p><h3 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h3><p>假设收发双方之间是一条直通的信道<br>（图中忽略了接收方对数据分组的处理时延，以及发送方对确认分组的处理时延。）</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li></ul><p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334570881-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334584200-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334596096-image.png"></p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><p>练习:</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334889057-image.png"></p><h2 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h2><h3 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h3><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339102277-image.png"></p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339121422-image.png"></p><h3 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h3><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339135060-image.png"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339147119-image.png"></p><p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339159243-image.png"></p><h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339171897-image.png"><br>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345196566-js%2000_00_00-00_00_30.gif"></p><blockquote><p>累计确认</p><p>优点:</p><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>减小接收方的开销</li><li>减小对网络资源的占用</li></ul><p>缺点：</p><ul><li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li></ul></blockquote><h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h3><p>例如</p><p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345351261-image.png"></p><p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345365334-image.png"></p><p>接收同样也不能接收它们，将它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345382029-image.png"></p><p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345886543-image.png"></p><p> 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345989625-image.png"></p><p>若WT超过取值范围，例如WT=8，会出现什么情况？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346010310-image.png"></p><p>习题</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346024469-image.png"><br>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346984847-cc.gif"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346036210-image.png"></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为<strong>滑动窗口协议</strong></li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h2 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h2><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27">视频链接</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640349282523-image.png"></p><p>例子：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350054565-image.png"></p><p>一般情况下接收窗口大小与发送窗口相同。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350340840-image.png"><br>发送方将序号落在发送窗口内的这4个数据分组依次连续发送出去。它们经过互联网的传输陆续到达接收方，但其中的2号数据分组丢失了。</p><p>只要序号落入接收窗口内且无误码的数据分组，接收方都会接收。接收方接收0号和1号数据分组，并发送0号和1号确认分组。接收窗口向前滑动两个位置，这样就有4和5这两个新的序号落入接收窗口。接收方接收3号数据分组，并发送3号确认分组，但接收窗口不能向前滑动，因为3号数据分组是未按序到达的数据分组。</p><p>这些确认分组经过互联网的传输陆续到达发送方，发送方每按序收到一个确认分组，发送窗口就向前滑动一个位置。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350607273-111%2000_00_00-00_00_30.gif"></p><p>发送方接收0号和1号确认分组，发送窗口向前滑动两个位置，这样就有4和5这两个新的序号落入发送窗口，发送方将序号落入发送窗口的4号和5号数据分组发送出去。发送方现在可以将已经收到确认的0号和1号数据分组，从发送缓存中删除了，而接收方可择机将已按序接收的0号和1号数据分组交付上层处理。</p><p>发送方接收3号确认分组，但发送窗口不能向前滑动，因为这是一个未按序到达的确认分组，发送方还未收到它之前的2号确认分组。不过，需要记录3号数据分组已收到确认，这样该数据分组就不会超时重发。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350793690-222%2000_00_00-00_00_30.gif"></p><p>4号和5号数据分组到达接收方，接收方接收之，并发送4号和5号确认分组，但接收窗口不能向前滑动，因为它们是未按序到达的数据分组。接收方还未收到它们之前的2号数据分组。</p><p>假设在4号和5号确认分组的传输过程中，发送方针对2号数据分组的重传计时器超时了，发送方重传2号数据分组，4号和5号确认分组陆续到达发送方。发送方接收它们，但发送窗口不能向前滑动，因为它们是未按序到达的确认分组，发送方还未收到它们之前的2号确认分组。不过，需要记录4号和5号数据分组已收到确认，这样它们就不会超时重发。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640357684970-333%2000_00_00-00_00_30.gif"></p><p>发送方之前重传的2号数据分组到达接收方，接收方接受之，并发送2号确认分组，接收窗口现在可以向前滑动4个位置，这样就有6，7，0，1这四个新的序号落入接收窗口。</p><p>2号确认分组经过互联网的传输到达发送方，发送方接收之，发送窗口现在可以向前滑动4个位置，这样就有6，7，0，1这四个新的序号落入发送窗口。发送方现在就可以继续将这四个序号的数据分组依次发送出去了。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640358254939-444%2000_00_00-00_00_30.gif"></p><p><strong>习题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640359443665-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640359428492-image.png"></p><hr><h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li><li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li><li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640393867274-image.png"></p><ul><li>PPPoE 是为宽带上网的主机使用的链路层协议</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640393885344-image.png"></p><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>必须规定特殊的字符作为帧定界符</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394003308-image.png"></p><h2 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h2><p> 必须保证数据传输的透明性</p><p>实现透明传输的方法</p><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394023009-image.png"></p><ul><li>面向比特的同步链路：比特填充法（插入“比特0”）</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394036499-image.png"></p><h2 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h2><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394465493-image.png"></p><h2 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h2><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机，分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ul><p>动图演示：</p><p>part1<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394843164-11%2000_00_00-00_00_30.gif"></p><p>part2<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394957939-22%2000_00_00-00_00_30.gif"></p><p>all<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394982228-image.png"></p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><hr><h1 id="媒体接入控制（介质访问控制）——广播信道"><a href="#媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="媒体接入控制（介质访问控制）——广播信道"></a>媒体接入控制（介质访问控制）——广播信道</h1><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p><blockquote><p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p></blockquote><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。 </li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395841573-image.png"></p><p><strong>数据链路层的两个子层</strong></p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395858471-image.png"></p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>为什么要媒体接入控制（介质访问控制）？</p><p><strong>共享信道带来的问题</strong></p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395874504-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395900951-image.png"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>信道复用</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396063251-image.png"></p><p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p><ul><li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p></li><li><p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396761121-image.png"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396776295-image.png"></p><p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396787361-image.png"></p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><p><strong>码分复用 CDM  (Code Division Multiplexing)</strong> </p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397157215-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397193171-image.png"></p><p>练习：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397672121-image.png"></p><p>喵喵喵啊：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397993357-image.png"></p><p>以B站为例：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398082956-image.png"></p><p>真题：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398214903-image.png"></p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><p>受控接入</p><p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p><p><strong>随机接入</strong></p><p><strong>重点</strong></p><h2 id="随机接入（CSMA-CD协议）"><a href="#随机接入（CSMA-CD协议）" class="headerlink" title="随机接入（CSMA/CD协议）"></a>随机接入（CSMA/CD协议）</h2><p><strong>总线局域网使用协议：CSMA/CD</strong></p><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><blockquote><p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398741307-image.png"></p><h3 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h3><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398753790-image.png"></p><h3 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h3><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398761665-image.png"><br>动图演示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399184478-jt%2000_00_00-00_00_30.gif"></p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h3 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h3><ul><li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398830799-image.png"><br>动图演示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399290142-pz%2000_00_00-00_00_30.gif"></p><blockquote><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398848314-image.png"></p><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p></blockquote><h3 id="CSMA-CD-协议工作流程"><a href="#CSMA-CD-协议工作流程" class="headerlink" title="CSMA/CD 协议工作流程"></a>CSMA/CD 协议工作流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398871828-image.png"></p><h3 id="CSMA-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA/CD 协议工作——争用期（碰撞窗口）"></a>CSMA/CD 协议工作——争用期（碰撞窗口）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399593948-image.png"></p><h3 id="CSMA-CD-协议工作——最小帧长"><a href="#CSMA-CD-协议工作——最小帧长" class="headerlink" title="CSMA/CD 协议工作——最小帧长"></a>CSMA/CD 协议工作——最小帧长</h3><blockquote><p>帧长一点也就是多说一会，同样的也就能多听一会，这样就可以检测到是否发生了碰撞</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399933493-image.png"></p><h3 id="CSMA-CD-协议工作——最大帧长"><a href="#CSMA-CD-协议工作——最大帧长" class="headerlink" title="CSMA/CD 协议工作——最大帧长"></a>CSMA/CD 协议工作——最大帧长</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400058682-image.png"></p><h3 id="CSMA-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA/CD 协议工作——截断二进制指数退避算法"></a>CSMA/CD 协议工作——截断二进制指数退避算法</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400146477-image.png"></p><h3 id="CSMA-CD-协议工作——信道利用率"><a href="#CSMA-CD-协议工作——信道利用率" class="headerlink" title="CSMA/CD 协议工作——信道利用率"></a>CSMA/CD 协议工作——信道利用率</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400400766-image.png"></p><h3 id="CSMA-CD-协议工作——帧发送流程"><a href="#CSMA-CD-协议工作——帧发送流程" class="headerlink" title="CSMA/CD 协议工作——帧发送流程"></a>CSMA/CD 协议工作——帧发送流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400531547-image.png"></p><h3 id="CSMA-CD-协议工作——帧接收流程"><a href="#CSMA-CD-协议工作——帧接收流程" class="headerlink" title="CSMA/CD 协议工作——帧接收流程"></a>CSMA/CD 协议工作——帧接收流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400612564-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400716027-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400788405-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400881649-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400997888-image.png"></p><h3 id="CSMA-CD-协议的重要特性"><a href="#CSMA-CD-协议的重要特性" class="headerlink" title="CSMA/CD 协议的重要特性"></a>CSMA/CD 协议的重要特性</h3><ul><li>使用 CSMA/CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。 </li></ul><blockquote><p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议</strong></p></blockquote><h2 id="随机接入（CSMA-CA协议）"><a href="#随机接入（CSMA-CA协议）" class="headerlink" title="随机接入（CSMA/CA协议）"></a>随机接入（CSMA/CA协议）</h2><p><strong>无线局域网使用的协议：CSMA/CA</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401187558-image.png"></p><h3 id="为什么无线局域网要使用CSMA-CA协议"><a href="#为什么无线局域网要使用CSMA-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA/CA协议"></a>为什么无线局域网要使用CSMA/CA协议</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401219306-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401356996-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401485998-image.png"></p><h3 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401505224-image.png"></p><h3 id="CSMA-CA协议的工作原理"><a href="#CSMA-CA协议的工作原理" class="headerlink" title="CSMA/CA协议的工作原理"></a>CSMA/CA协议的工作原理</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401514952-image.png"></p><blockquote><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401542707-image.png"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401559283-image.png"></p><h3 id="CSMA-CA协议的退避算法"><a href="#CSMA-CA协议的退避算法" class="headerlink" title="CSMA/CA协议的退避算法"></a>CSMA/CA协议的退避算法</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403445410-image.png"></p><p><strong>退避算法的示例</strong></p><p>如图，A、B、C、D、E是5个无线站点，横坐标为时间。</p><p>假设A正在占用无线信道发送帧，在A的发送过程中，B、C、D也要发送帧，用向上的箭头来表示，于是进行载波监听，<code>发现信道忙，需要退避，根据退避算法选择出一个随机的退避时间，并在每个时隙对信道进行一次检测，当检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器开始倒计时</code>。</p><p>假设C的退避时间最短，当C的退避计时器到时后，C立即开始发送帧，此时信道由空闲状态转换为忙状态，当B和D检测到信道忙后，就冻结各自剩余的退避时间。</p><p>假设在C占用无线信道发送帧的过程中，E也要发送帧，于是进行载波监听，<code>发现信道忙，需要退避。根据退避算法选择出一个随机的退避时间，并在每个时隙对信道进行一次检测，当检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器开始倒计时。</code><br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640404465937-pp1%2000_00_00-00_00_30.gif"><br>末态：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405159240-image.png"></p><p>当B和D检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。</p><p>D的退避计时器会首先到时，D立即开始发送帧。此时信道由空闲状态转换为忙状态，当B和E检测到信道忙后，就冻结各自剩余的退避时间，当D发送完帧后，信道将转为空闲状态，当B和E测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405275746-pp2%2000_00_00-00_00_30.gif"><br>末态：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405691112-image.png"></p><p>E的退避计时器会首先到时，E立即开始发送帧。此时信道由空闲状态转换为忙状态，当B检测到信道忙后，就冻结自己剩余的退避时间，当E发送完帧后，信道将转为空闲状态，当B测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。</p><p>当B的退避计时器到时后，B立即开始发送帧。若B发送完这一帧后还有帧要发送，则在检测到信道空闲，且经过帧间间隔DIFS后，还必须再退避一段随机时间后，才能发送。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405864895-pp3%2000_00_00-00_00_30.gif"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403456513-image.png"></p><h3 id="CSMA-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA/CA协议的信道预约和虚拟载波监听"></a>CSMA/CA协议的信道预约和虚拟载波监听</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403473723-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403487264-image.png"></p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640406934465-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640406945870-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407085368-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407168594-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407229677-image.png"></p><p>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407279137-image.png"></p><hr><h1 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640406966759-image.png"></p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407480075-image.png"></p><h3 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407532795-image.png"></p><blockquote><p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h3 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407795768-image.png"></p><blockquote><p>说白了前面一半(OUI)是标识网卡的厂商，后一半(EUI)是厂商定义的网卡序号用于标识同一厂商的不同网卡的MAC地址。</p></blockquote><p><a href="https://mac.bmcx.com/">查询MAC地址对应的设备厂商信息</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408411167-image.png"></p><blockquote><p><strong>组织唯一标识符OUI</strong></p><ul><li><p>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408271647-image.png"><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408300333-image.png"><br><strong>网络接口标识符</strong>    </p></li><li><p>由获得OUI的厂商自行随意分配</p></li></ul><p><strong>EUI-48</strong></p><ul><li>48是这个MAC地址的位数</li></ul></blockquote><blockquote><p>全球管理：表示是全球唯一的</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408825601-image.png"></p><blockquote><p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p></blockquote><p><strong>关于无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li></ul><blockquote><p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong> </p></blockquote><h3 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408907878-image.png"></p><h3 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408916792-image.png"></p><blockquote><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408926630-image.png"></p><blockquote><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p><p>并将该帧交给其上层处理</p></blockquote><h3 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408937232-image.png"></p><blockquote><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408947809-image.png"></p><blockquote><p>主机B将该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p></blockquote><h3 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408958590-image.png"></p><blockquote><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408983911-image.png"></p><blockquote><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408998943-image.png"></p><blockquote><p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640409009648-image.png"></p><blockquote><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p></blockquote><blockquote><p>注意：给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址，具体可点<a href="https://standards.ieee.org/products-services/regauth/grpmac/public.html">这里</a>进行查询</p></blockquote><p>结果如下图所示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640409633741-image.png"><br>……</p><h3 id="随机MAC地址"><a href="#随机MAC地址" class="headerlink" title="随机MAC地址"></a>随机MAC地址</h3><p>由于斯诺登披露，美国国家安全局有一套系统，通过监视电子设备的MAC地址，来跟踪城市里每个人的行动。因此苹果率先在IOS系列设备，扫描网络设备时，采用随机MAC地址技术，随后……<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640409784123-image.png"></p><p>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640410062094-image.png"></p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p><p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418572750-image.png"></p><h3 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418607589-image.png"></p><h3 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h3><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418625421-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418640294-image.png"></p><blockquote><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP协议</p></blockquote><p>习题：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418684938-image.png"><br>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640419696130-image.png"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP（地址解析协议）</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420598772-image.png"></p><p>ARP高速缓存表</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420609104-image.png"></p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420620751-image.png"></p><blockquote><p>ARP请求报文有具体的格式，上图的只是简单描述</p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420639053-image.png"></p><blockquote><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420669650-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420684239-image.png"></p><p>动态与静态的区别</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420693092-image.png"></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420705052-image.png"></p><blockquote><p>ARP协议的使用是逐段链路进行的</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420718261-image.png"></p><hr><h1 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h1><h2 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420842093-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420854878-image.png"></p><blockquote><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li><li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li><li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li></ul></blockquote><h3 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h3><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420876689-image.png"></p><blockquote><ul><li><strong>优点</strong><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol></li><li><strong>缺点</strong><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 </li></ol></li></ul></blockquote><p><strong>碰撞域</strong></p><ul><li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高。</li></ul><h2 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>扩展以太网更常用的方法是在数据链路层进行。</li><li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420893674-image.png"></p><blockquote><p><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 </li></ul><p><strong>交换机</strong></p><ul><li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul></blockquote><h3 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420907593-image.png"></p><blockquote><p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p><p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422545336-image.png"></p><blockquote><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li><li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>对比集线器和交换机</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422573402-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422662539-image.png"></p><blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><strong>单播</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422703146-image.png"></p><p><strong>广播</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422712697-image.png"></p><p><strong>多个单播</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422728116-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422736198-image.png"></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422751710-image.png"></p><blockquote><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p></blockquote><hr><h1 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640423943535-image.png"></p><h2 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h2><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><p><strong>A -&gt; B</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640423958445-image.png"></p><blockquote><ol><li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li><li>交换机向除接口 1 以外的所有的接口广播这个帧</li><li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 2 写入（图中右边）交换表中</li><li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li><li>主机B发现是给自己的帧，接受该帧</li></ol></blockquote><p><strong>B -&gt; A</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424159451-image.png"></p><blockquote><ol><li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>主机 A 发现目的地址是它，就接受该帧</li><li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li></ol></blockquote><p><strong>E -&gt; A</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424268106-image.png"></p><blockquote><ol><li>E 向 A发送一帧</li><li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li><li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li><li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li><li>主机 A 发现目的地址是它，就接受该帧</li></ol></blockquote><p><strong>G -&gt; A（丢弃帧的情况）</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424427233-image.png"></p><blockquote><p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p><ol><li>主机 G 发送给 主机 A 一个帧</li><li>主机 A 和 交换机接口 1都能接收到</li><li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li><li>交换机 1收到该帧后，首先进行登记工作</li><li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li><li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li></ol></blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424585887-image.png"></p><blockquote><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p></blockquote><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>交换机自学习和转发帧的步骤归纳</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424685215-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424695103-image.png"></p><p>习题：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424649494-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424909239-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640425039518-image.png"><br>1、左侧主机给右侧主机发送数据帧，该帧从交换机的接口1进入交换机，交换机首先进行登记工作，将该帧的源MAC地址记录到自己的帧交换表中，将该帧进入自己的接口的接口号，相应的也记录到帧交换表中。</p><p>之后，交换机对该帧进行转发，在帧交换表中查找该帧的目的MAC地址（00-e1-d5-00-23-c1），找不到，就进行盲目转发，因此<code>数据帧的转发端口为2和3</code></p><p>2、登记源MAC地址，将该帧进入自己的接口的接口号，相应的也记录到帧交换表中。之后，交换机对该帧进行转发，在帧交换表中查找该帧的目的MAC地址，可以找到，于是按照MAC地址对应的接口号1，从接口1明确转发该帧。因此，<code>交换机转发确认帧的端口为1</code></p><hr><h1 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h1><h2 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427323256-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427339637-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427350556-image.png"></p><h2 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427363775-image.png"><br>当某段链路出现故障，相关交换机检测到该故障后，重新计算生成树。决定将自己之前阻塞的接口恢复为正常状态，这样就会生成一个新的逻辑上没有环路的网络。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640428248268-hh%2000_00_00-00_00_30.gif"></p><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><hr><h1 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h1><h2 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h2><p><strong>广播风暴</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427491648-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427504705-image.png"></p><p><strong>分割广播域的方法</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427521001-image.png"></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427529435-image.png"></p><blockquote><ul><li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li></ul></blockquote><h2 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h2><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427559776-image.png"></p><p><strong>Access端口</strong></p><p>交换机与用户计算机之间的互连</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427594140-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427602837-image.png"></p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><strong>Truck端口</strong></p><p>交换机之间或交换机与路由器之间的互连</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427615006-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640430470688-image.png"></p><p><strong>连接主机的交换机端口应设置为Access类型，交换机之间互连的端口应设置为Trunk类型！</strong></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427631948-image.png"></p><p><strong>华为交换机私有的Hybrid端口类型</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427645960-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427654552-image.png"></p><p>主机B给A发送的普通以太网MAC帧，主机A收到的却是802.1Q帧，无法识别而丢弃。</p><p><code>利用用户主机无法识别802.1Q帧的手段，来实现通信隔离。</code></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427665700-image.png"></p><blockquote><p><strong>虚拟局域网优点</strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性 </li></ol></blockquote><hr><hr><hr><h1 id="———网络层———"><a href="#———网络层———" class="headerlink" title="———网络层———"></a>———网络层———</h1><h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442280332-image.png"></p><blockquote><p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p><p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p><p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p></blockquote><ul><li><p>要实现网络层任务，需要解决一下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li></ul><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><ul><li>网络层寻址问题</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442296825-image.png"></p><ul><li>路由选择问题</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442304389-image.png"></p><blockquote><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442319976-image.png"></p></blockquote><blockquote><p>但在实际当中，路由器是怎样知道这些路由记录？</p><ul><li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li><li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442336736-image.png"></p><blockquote><p>补充<br>：<strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442370296-image.png"></p><hr><h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？ </li></ul><h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><p><strong>一种观点：让网络负责可靠交付</strong></p><ul><li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li><li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。 </li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479609694-image.png"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p><blockquote><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li><li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li></ul></blockquote><h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><p><strong>另一种观点：网络提供数据报服务</strong></p><ul><li>互联网的先驱者提出了一种崭新的网络设计思路。</li><li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640569294416-image.png"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p><blockquote><p><strong>尽最大努力交付</strong></p><ul><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li><li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li><li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul></blockquote><h2 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h2><table><thead><tr><th><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td><strong>思路</strong></td><td><strong>可靠通信应当由网络来保证</strong></td><td><strong>可靠通信应当由用户主机来保证</strong></td></tr><tr><td><strong>连接的建立</strong></td><td><strong>必须有</strong></td><td><strong>不需要</strong></td></tr><tr><td><strong>终点地址</strong></td><td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td><td><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td><strong>分组的转发</strong></td><td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td><td><strong>每个分组独立选择路由进行转发</strong></td></tr><tr><td><strong>当结点出故障时</strong></td><td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td><td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td><strong>分组的顺序</strong></td><td><strong>总是按发送顺序到达终点</strong></td><td><strong>到达终点时不一定按发送顺序</strong></td></tr><tr><td><strong>端到端的差错处理和流量控制</strong></td><td><strong>可以由网络负责，也可以由用户主机负责</strong></td><td><strong>由用户主机负责</strong></td></tr></tbody></table><hr><h1 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479875281-image.png"></p><blockquote><p>记住各位对应的权值，用看情况加/减法。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640480224801-image.png"></p><h2 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479892376-image.png"></p><ul><li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li></ul><p><strong>A类地址</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479942073-image.png"></p><p><strong>B类地址</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479955722-image.png"></p><p><strong>C类地址</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479969946-image.png"></p><p><strong>练习</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479984452-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640481813330-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640482140908-image.png"></p><p>俩路由器之间，无主机，只有俩路由器接口，需要可分配的IP地址数量为2，给该网络分配一个A类、B类、C类网络号都可以，本着节约IP地址的原则，给该网络分配一个C类网络号。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640482187843-image.png"><br>综上：<br>橙色A类，蓝色B类，绿色C类，红色C类。</p><blockquote><p>A类地址每个网络中可分配IP地址数量为：2^24 - 2（去除主机号全0的网络地址，和全1的广播地址） = 1677,7214</p><p>B类为：2^16 - 2 = 65534</p><p>C类为：2^8 - 2 = 254</p></blockquote><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640482981898-image.png"></p><p><strong>IP 地址的一些重要特点</strong></p><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><ul><li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。 </li></ul><p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。 </li></ul><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p><p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><h3 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h3><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ul><li>IP 地址空间的利用率有时很低。 </li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li><li>两级的 IP 地址不够灵活。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483385676-image.png"></p><p>如果想要将原来的网络划分成三个独立的网路</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483394592-image.png"></p><p>所以是否可以从主机号部分借用一部分作为子网号</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483401882-image.png"></p><blockquote><p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p><p>所以就有了划分子网的工具：<strong>子网掩码</strong></p><ul><li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li><li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li><li>划分子网已成为互联网的正式标准协议。 </li></ul></blockquote><h3 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h3><p>基本思路</p><ul><li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li><li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483412983-image.png"></p><ul><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li><li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul><p>划分为三个子网后对外仍是一个网络</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483420624-image.png"></p><blockquote><ul><li><strong>优点</strong><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol></li><li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li></ul></blockquote><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483430472-image.png"></p><blockquote><p><strong>(IP 地址) AND (子网掩码) = 网络地址</strong> 重要，下面很多相关知识都会用到</p></blockquote><p>举例</p><p>例子1</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483438980-image.png"></p><blockquote><p>下题中，给的子网掩码255.255.255.128中的128表明从主机号部分借用一个比特作为子网号，也就是<strong>将该C类网均分为两个子网，其子网号分别为0和1</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483455297-image.png"></p><blockquote><p>上图可看出，子网掩码255.255.255.128可将C类网218.75.230.0均分为两个子网</p></blockquote><p>例子2</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483468060-image.png"></p><blockquote><p>主要是看子网号有几位，1位就可划分出2^1个子网，2位就可划分出2^2个子网。</p><p>子网号怎么看？</p><p>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号</p><p>解释：先看是A、B、C哪类网，从而确定网络、主机号有几位，子网掩码主机号部分如255.255.255.192这个是C类网，它的主机号是后8位，192写成八位二进制：11000000，前两位11，表示它子网号就有2^2个。即：00、01、10、11</p><p>梦回计组嗷~</p></blockquote><p>考研题：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485297681-image.png"></p><blockquote><p>思路如下：</p></blockquote><blockquote><p>1、180开头是B类网，网络号16位，主机号16位。将IP地址的主机号部分转换成二进制形式，将子网掩码中，连续的6个比特1所对应的主机号部分作为子网号。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485503303-image.png"></p><blockquote><p>2、将网络号和子网号保持不变，而将主机号的10个比特全部取0，就可以得到该主机所在子网的网络地址。</p><p>写成点分十进制为：180.80.76.0<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485588635-image.png"><br>3、将网络号和子网号保持不变，而将主机号的10个比特全部取1，就可以得到该主机所在子网的广播地址</p><p>写成点分十进制为：180.80.79.255<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485684854-image.png"></p></blockquote><blockquote><p>在这俩区间中（180.80.76.0 ~ 180.80.79.255），可以找到答案。</p></blockquote><p><strong>默认子网掩码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483486944-image.png"></p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483495990-image.png"></p><blockquote><ul><li>子网掩码是一个网络或一个子网的重要属性。</li><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><h3 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h3><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。 </p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486841507-image.png"></p><blockquote><p><strong>CIDR 最主要的特点</strong></p><ul><li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。 </li></ul></blockquote><h3 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486863329-image.png"></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486871657-image.png"></p><h3 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h3><p>存在意义？</p><blockquote><p>路由器R1与五个网络以及路由器R2直接相连，路由器R1和R2互为相邻路由器，它们周期性地通告自己所知道的路由信息给对方。</p><p>若R1将自己直连的这五个网络的路由记录都通告给R2，则R2的路由表会增加5条路由记录。</p><p>为了减少路有记录对路由表的占用，采用路由聚合（构造超网）（即找它们共同前缀）的方式。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486879241-image.png"></p></blockquote><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640487955743-image.png"></p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486886563-image.png"></p><h2 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489579592-image.png"></p><h3 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488402926-image.png"></p><p><strong>划分子网的IPv4就是定长的子网掩码</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488851899-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488863501-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488877218-image.png"></p><blockquote><p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的网络N1</del>N5</p><p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p><p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p><p>例如：图中N5只需要4个网络地址，但我们只能给它分配32个。</p></blockquote><h3 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489022597-image.png"></p><p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489040146-image.png"><br>在地址块中给左图所示的网络N1~N5分配子块，分配原则是<strong>每个子块的起点位置不能随意选取，只能选取块大小整数倍的地址作为起点</strong>。建议<strong>先给大的子块分配</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489051371-image.png"></p><hr><h1 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497932862-image.png"></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497956222-image.png"></p><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497973189-image.png"></p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li></ul></blockquote><p>主机C如何知道路由器R的存在？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497984707-image.png"></p><blockquote><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p><p>例如。路由器的接口0的IP地址192.168.0.128作为左边网络的默认网关</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497997542-image.png"></p><blockquote><p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p></blockquote><p>路由器收到IP数据报后如何转发？</p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ul><p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498035998-image.png"></p><p>接下来路由器对该IP数据报进行查表转发</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498046281-image.png"></p><blockquote><p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一跳指示，图中所示的也就是接口1转发该IP数据报</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498056843-image.png"></p><p>路由器是隔离广播域的</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498134626-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498157727-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498227451-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498367352-image.png"></p><p>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498391300-image.png"></p><hr><h1 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498448485-image.png"></p><h2 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h2><p> <strong>静态路由配置</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498462419-image.png"></p><p><strong>默认路由</strong></p><p>举例</p><p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498473675-image.png"></p><p><strong>特定主机路由</strong></p><p>举例</p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p><p>一般用于网络管理人员对网络的管理和测试</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501073543-image.png"></p><blockquote><p>多条路由可选，匹配路由最具体的，也就是最长前缀匹配，找不到时，匹配默认路由。</p></blockquote><p><strong>静态路由配置错误导致路由环路</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501438058-image.png"></p><p>假设将R2的路由表中第三条目录配置错了下一跳</p><p>这导致R2和R3之间产生了路由环路</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501448219-image.png"></p><p><strong>聚合了不存在的网络而导致路由环路</strong></p><p>举例</p><p>正常情况</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501459117-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501539138-image.png"></p><p>错误情况</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501549689-image.png"></p><p>解决方法</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501561471-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501571088-image.png"></p><blockquote><p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p></blockquote><p><strong>网络故障而导致路由环路</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501580517-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501589454-image.png"></p><p>解决方法</p><p>在R1的路由表中，添加针对该直连网络的黑洞路由。</p><p>这样，当R2要转发IP数据报到该网络时，进行查表转发，找到匹配的路由条目，下一跳转发给R1的接口1。R1收到该IP数据报后，进行查表转发，找到匹配的路由条目，为一条黑洞路由，下一跳为虚拟接口null0，因此该IP数据报会进入这个黑洞。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501600545-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501614509-image.png"></p><p>假设，一段时间后故障网络恢复了</p><p>则R1又自动地得出了其接口0的直连网络的路由条目</p><p>并将我们之前人工配置的，针对该直连网络的黑洞路由条目设置为失效状态。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501668021-image.png"></p><p>假设R1再次检测到其接口0所直连的网络，出现了故障而不可达，则会自动在其路由表中删除该直连网络的路由条目。</p><p>并将我们之前人工配置的，针对该直连网络的黑洞路由条目，设置为生效状态。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501679622-image.png"></p><h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501692517-image.png"></p><hr><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504176232-image.png"></p><p><strong>因特网所采用的路由选择协议的主要特点</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504194636-image.png"></p><p><strong>因特网采用分层次的路由选择协议</strong></p><ul><li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504209365-image.png"></p><blockquote><p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504290247-image.png"></p><blockquote><p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p><p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p><p>使用”网关“这个名词，是因为因特网早期的RFC文档中，没有使用”路由器“。现在新的RFC文档中，又改用”路由器“这一名词。</p><p>故：<br>外部网关协议EGP可称为：外部路由协议ERP<br>内部网关协议IGP可称为：内部路由协议IRP</p></blockquote><p><strong>常见的路由选择协议</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504311934-image.png"></p><p><strong>路由器的基本结构</strong></p><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506060598-image.png"></p><p>路由器结构可划分为两大部分：</p><p>1、<strong>分组转发部分</strong></p><p> 由三部分构成</p><ul><li><p>交换结构</p></li><li><p>一组输入端口：</p><p>信号从某个输入端口进入路由器</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506076797-image.png"></p><p>   物理层将信号转换成比特流，送交数据链路层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506086068-image.png"></p><p>   数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506099124-image.png"></p><p>  如果送交网络层的分组是普通待转发的数据分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506122179-image.png"></p><p>  则根据分组首部中的目的地址进行查表转发</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506157190-image.png"></p><p>   若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p><ul><li><p>一组输出端口</p><p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506240762-image.png"></p><p>   数据链路层将数据分组封装成帧，交给物理层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506247348-image.png"></p><p>   物理层将帧看成比特流将其变换成相应的电信号进行发送</p><blockquote><p>路由器的各端口还会有输入缓冲区和输出缓冲区</p><ul><li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p></li><li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506272010-image.png"></p><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分别给出了输入端口和输出端口是为了更好地演示路由基本工作过程</p></blockquote><p> 2、<strong>路由选择部分</strong></p><ul><li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506315904-image.png"></p><p>   路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640505957126-image.png"></p><p>   路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506373840-image.png"></p><h2 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506648635-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506674809-image.png"></p><p><strong>RIP的基本工作过程</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506690642-image.png"></p><p><strong>RIP的路由条目的更新规则</strong></p><p>举例1</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506701216-image.png"></p><blockquote><p>路由器C的表到达各目的网络的下一跳都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506712548-image.png"></p><blockquote><p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是路由器D现在可以根据改造好的路由表，来更新自己先前的路由表了。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506721860-image.png"></p><p>对于上图中的N2，因为原本下一跳是到C，而C的拓扑结构改变了（原来的那条路可能没了），现在到C不能再那么短的距离了，所以需要更新。</p><p>举例2：请给出路由器B更新后的路由表</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506729743-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509033465-image.png"></p><p><strong>RIP存在“坏消息传播得慢”的问题</strong></p><p>假设R2的更新周期先到时，也就是R2的这条路由信息先到达R1。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506747735-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506757581-image.png"></p><p>解决方法</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506768455-image.png"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><p>练习：</p><p>题目中的”检测“意为第一个探测到，而不是说更新路由表后发现不可达。</p><p>根据题目所给“R3检测到网络201.1.2.0/25不可达”可知，R3与该网络是直连的。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509134152-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509280549-image.png"><br>当R3检测到该故障时，将自己到达该网络的路由条目中的距离修改为16，表示该网络不可达，并向R2发送关于这条路由条目的通告。R2收到后，更新自己相应的路由条目，将距离修改为16</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509791007-image.png"></p><p>最后，根据题目”则R2更新后“这句话可知，R1给R2发送了关于该路由条目的RIP更新报文（R1到了周期性传送时间了）。而R2听信了该谣言，误认为到达该目的网络可以通过R1的转发，距离为3</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509836232-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506779271-image.png"></p><blockquote><p>RIP 协议的优缺点</p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p></li></ol></blockquote><h2 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h2><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p><p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p><strong>概念</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511652453-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511665934-image.png"></p><p><strong>问候（Hello）分组</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511677729-image.png"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511688239-image.png"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511702036-image.png"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511719730-image.png"></p><p><strong>OSPF五种分组类型</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511727824-image.png"></p><p><strong>OSPF的基本工作过程</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511737787-image.png"></p><p>相邻路由器之间周期性发送问候分组，以便建立和维护邻居关系，建立邻居关系后，给邻居路由器发送数据库描述分组。也就是将自己链路状态数据库中的所有链路状态项目的摘要信息，发送给邻居路由器。</p><p>例如，R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组。</p><p>R2收到后，将R1缺少的链路状态项目的详细信息，封装在链路状态更新分组中发送给R1，R1收到后，将这些所缺少的链路状态项目的详细信息，添加到自己的链路状态数据库中，并给R2发送链路状态确认分组。</p><p>需要说明的是，R2也可以向R1请求自己缺少的链路状态项目的详细信息，这里不再赘述。</p><p>最终，R1和R2的链路状态数据库将达到一致，也就是链路状态数据库达到同步。</p><p>每三十分钟或链路状态发生变化时，路由器都会发送链路状态更新分组。收到该分组的其他路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组。这又称为新情况下的链路状态数据库同步。</p><p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p><p>如果不采用其他机制，将会产生大量的多播分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511750144-image.png"></p><blockquote><p>若DR出现问题，则由BDR顶替DR</p></blockquote><p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p><ul><li><p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p></li><li><p>每个区域都有一个32比特的区域标识符</p></li><li><p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p></li><li><p>其他区域的区域标识符不能为0且不相同</p></li><li><p>每个区域一般不应包含路由器超过200个</p></li><li><p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511761048-image.png"></p><p>如果路由器的所有接口都在同一个区域内，则该路由器称为<strong>区域内路由器IR：R1、R2、R8、R9</strong></p><p><strong>区域边界路由器ABR</strong>，它的一个接口用于连接自身所在区域，另一个接口用于连接主干区域：<strong>R3、R4、R7</strong></p><p>主干区域内的路由器，称为<strong>主干路由器BB：R3、R4、R5、R6、R7</strong></p><p>在主干区域内还要有一个路由器，专门和本自治系统外的其他自治系统交换路由信息，其称为<strong>自治系统边界路由器：R6</strong></p><p>在本例中：</p><p>区域边界路由器R3，向主干区域发送自己所在区域1的链路状态通告；向自己所在区域发送区域0，2，3的链路状态通告LSA。</p><p>区域边界路由器R4，向主干区域发送自己所在区域2的链路状态通告；向自己所在区域发送区域0，1，3的链路状态通告。</p><p>区域边界路由器R7，向主干区域发送自己所在区域3的链路状态通告；向自己所在区域发送区域0，1，2的链路状态通告。</p><p><strong>采用分层次划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做，却能使每一个区域内部，交换路由信息的通信量大大减小。因而使OSPF协议能够用于规模很大的自治系统中。</strong></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511771635-image.png"></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516140680-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516301863-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516316977-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516444076-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516347988-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516359608-image.png"><br><strong>在BGP协议刚刚运行时，BGP的邻站交换整个BGP路由表，但以后只需要在发生变化时更新有变化的部，这样做对节省网络带宽和减少路由器的处理开销都有好处。</strong></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640517216782-image.png"></p><h2 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640517254310-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516369655-image.png"></p><hr><h1 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h1><h2 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521549803-image.png"></p><p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521627493-image.png"></p><blockquote><p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p><p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521890173-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521903229-image.png"></p><p><strong>对IPv4数据报进行分片</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521917328-image.png"><br>其中，片偏移字段中0/8除以8的原因是：片偏移字段以8字节为单位。</p><pre><code>    现在假定分片2的IP数据报经过某个网络时还需要进行分片</code></pre><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521990714-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522001939-image.png"></p><p>当首部中，协议字段的取值为1时，表明数据部分时ICMP报文，也就是用ICMP协议封装的协议数据单元。</p><p>当首部中，协议字段的取值为6时，表明数据部分时TCP报文，也就是用TCP协议封装的协议数据单元。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522022596-image.png"></p><p><code>因特网检验和</code>的检错能力不强，好处是简单，处理起来快。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522035712-image.png"></p><p>练习：</p><p>第一题：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523407016-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523446972-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523505333-image.png"></p><p>第二题：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523680370-image.png"><br>IP分组要封装成以太网帧才能发送，在IP分组头中，目的IP地址字段前还有16个字节的内容；在以太网帧中，数据载荷前还有14字节的内容。因此可知，在以太网帧中，从第31个字节开始的4个字节，实际上就是目的IP的内容。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523961116-image.png"><br>从图中可知，主机的默认网关就是路由器R，主机会将Web请求发送给默认网关，由默认网关将Web请求转发到因特网。</p><p>因此，以太网帧头中的目的MAC地址字段，封装的就是默认网关的MAC地址</p><p>如下图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640525620901-image.png"><br>（4）</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526159936-image.png"></p><h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522056482-image.png"></p><hr><h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p>架构IP网络时需要特别注意两点：</p><ul><li>确认网络是否正常工作</li><li>遇到异常时进行问题诊断</li></ul><p><strong>而ICMP就是实现这些问题的协议</strong></p><p>ICMP的主要功能包括：</p><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526315889-image.png"></p><p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p><p>ICMP 报文的格式</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526560581-image.png"></p><h2 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h2><h3 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526364150-image.png"></p><h3 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526386633-image.png"></p><h3 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526398387-image.png"></p><h3 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526414096-image.png"></p><h3 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526463991-image.png"></p><h3 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526475285-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526763689-image.png"></p><h2 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h2><h3 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526487871-image.png"></p><h3 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526841031-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526852962-image.png"></p><p><strong>tracert命令的实现原理</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526867591-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526876348-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526887428-image.png"></p><p>以最后一个为例，H1发送一个封装有ICMP回送请求报文的IP数据报</p><p>其首部中生存时间字段TTL的值被设置为3，经过R1和R2的转发后，该数据报到达主机H2，其生存时间减少为1</p><p>H2解析该数据报，发现其内部封装的是ICMP回送请求报文，于是就给H1发送封装有ICMP回送请求回答报文的IP数据报。</p><p>这样，H1就知道已经跟踪到路径的最后一站，也就是目的主机H2</p><h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526897832-image.png"></p><hr><h1 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h2><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640527798349-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640527945294-image.png"></p><blockquote><p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p><p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528399297-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528486471-image.png"></p><blockquote><p><strong>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</strong></p><p><strong>私有地址只能用作本地地址而不能用作全球地址</strong></p><p><strong>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</strong></p><p><strong>本地地址与全球地址</strong></p><ul><li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </li><li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li></ul></blockquote><p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528126382-image.png"></p><p>部门A向部门B发送数据流程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528119910-image.png"></p><blockquote><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528150396-image.png"></p><p>因此也被称为IP隧道技术</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528176255-image.png"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528186360-image.png"></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528197820-image.png"></p><blockquote><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528206978-image.png"></p><blockquote><p>专有NAT软件的路由器叫做NAT路由器</p><p>它至少有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p></blockquote><p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528216603-image.png"></p><p>因特网上的这台主机给源主机发回数据报</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528225820-image.png"></p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528238068-image.png"></p><p>这种基本转换存在一个问题</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528248721-image.png"></p><p>解决方法</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528257897-image.png"></p><blockquote><p>我们现在用的很多家用路由器都是这种NART路由器</p></blockquote><p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p><p>否定</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528273908-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528285816-image.png"></p><h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528306532-image.png"></p><hr><hr><hr><h1 id="———运输层———"><a href="#———运输层———" class="headerlink" title="———运输层———"></a>———运输层———</h1><h1 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p><strong>进程之间的通信</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570397495-image.png"></p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570382327-image.png"></p><p><strong>进程之间通信流程</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570412444-image.png"></p><p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p><blockquote><p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p><p>在运输层使用不同的端口，来对应不同的应用进程</p><p>然后通过网络层及其下层来传输应用层报文</p><p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570431417-image.png"></p><h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570455190-image.png"></p><hr><h1 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h1><h2 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570698686-image.png"></p><h2 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570710106-image.png"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p></blockquote><h2 id="TCP-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP/IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570726065-image.png"></p><p><strong>在运输层不管用TCP还是UDP协议，在网络层都得用IP协议。IP数据报首部中协议字段的值，表明了IP数据报数据载荷部分，封装的是何种协议数据单元。</strong></p><h2 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h2><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570742253-image.png"></p><blockquote><p>在浏览器输入域名，回车浏览</p><p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p><p>DNS查询请求报文需要使用运输层的UDP协议</p><p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p><p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570763034-image.png"></p><blockquote><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570822635-image.png"></p><blockquote><p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p><p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p><p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570847903-image.png"></p><blockquote><p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570859587-image.png"></p><blockquote><p>用户PC收到该数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p><p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p></blockquote><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571228264-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571247168-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571255174-image.png"></p><hr><h1 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h1><h2 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP/IP体系结构<strong>运输层</strong>中的两个重要协议</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。 </li></ul><p>可靠信道与不可靠信道</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571544489-image.png"></p><ul><li><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p></li><li><p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p></li><li><p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594363177-image.png"></p><p>UDP的通信是无连接的，不需要套接字（Socket）</p><p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p><h2 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h2><p>可以发送广播</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594379987-image.png"></p><p>可以向某个多播组发送多播</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594389652-image.png"></p><p>还可以发送单播</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594463753-image.png"></p><blockquote><p>UDP 支持单播、多播以及广播</p><p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p></blockquote><p>运输过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594478507-image.png"></p><blockquote><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p><p>换句话说，UDP是面向应用报文的</p></blockquote><p>UDP向上层提供无连接不可靠传输服务</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594489817-image.png"></p><p>UDP结构</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594498410-image.png"></p><h2 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h2><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594508156-image.png"></p><p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594516929-image.png"></p><blockquote><p>很显然，TCP仅支持单播，也就是一对一的通信</p></blockquote><p>运输过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594534085-image.png"></p><blockquote><p>发送方</p><ul><li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p></li><li><p>并将他们编号，并存储在自己发送缓存中</p></li><li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p></li></ul><p>接收方</p><ul><li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li><li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li><li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul><p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p><p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p></blockquote><p>TCP向上层提供面向连接的可靠传输服务</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594545712-image.png"></p><p>TCP结构</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594563129-image.png"></p><h2 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594577884-image.png"></p><hr><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><h2 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596277539-image.png"></p><p>举例</p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p><p>下图中大写的ACK是TCP报文段首部中的标志位，取值1表示这是一个TCP确认报文段，小写ack是TCP报文段首部中的确认号字段，取值201表示序号201之前的数据已全部正确接收，现在希望收到序号201及其后续数据。rwnd是TCP报文段首部中的窗口字段，取值300表示自己的接收窗口大小为300</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596290411-image.png"></p><p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596300641-image.png"></p><p>上图主机A，发送窗口内序号201 ~ 300这100个字节数据的重传计时器超时了，主机A将它们重新封装成一个TCP报文段发送出去，暂时不能发送其它数据。主机B收到该重传的TCP报文段后，对主机A发送的501号之前的数据进行累计确认。并在该累计确认中，将窗口字段的值调整为100，这是主机B对主机A进行的第二次流量控制。</p><p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中，将自己的接收窗口调整为了100，因此，主机A相应的将自己的发送窗口调整为100。</p><p>目前主机A发送窗口内的序号为501 ~ 600，也就是主机A还可以发送这100字节。主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596666730-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596360544-image.png"></p><p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p>在本例中，主机A收到零窗口通知时，就启动一个持续计时器，当持续计时器超时，主机A立刻发送一个仅携带一字节数据的零窗口探测报文段。假设主机B此时的接收窗口又为0了，主机B就在确认这个零窗口探测报文段时，给出自己现在的接收窗口值为0，主机A再次收到零窗口通知，就再次启动一个持续计时器，当持续计时器超时，主机A就立刻发送一个零窗口探测报文段，假设主机B此时的接收缓存又有了一些存储空间，于是将自己的接收窗口调整为了300，主机B就在确认这个零窗口探测报文段时，给出自己现在的接收窗口值为300，这样就打破了死锁的局面。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596388493-image.png"><br>问题：</p><p>主机A所发送的零窗口探测报文段到达主机B时，如果主机B此时的接收窗口仍然为0，那么主机B根本无法接收该报文段，又怎么会针对该报文段给主机A发回确认呢？</p><p>答：<strong>TCP规定，即使接收窗口为0，也必须接收零窗口探测报文段、确认报文段、以及携带有紧急数据的报文段。</strong></p><p>问题2：</p><p>上图如果零窗口探测报文在发送过程中如果丢失，能否打破死锁局面？</p><p>答：<strong>能，因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</strong></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640598743827-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640598801135-image.png"><br>由于主机乙在确认中，给出自己的接收窗口大小为2000字节，因此主机甲相应的将自己的发送窗口调整为2000字节。显然，主机甲还可以向主机乙发送2000 ~ 2999号字节数据，共1000个字节。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640598879935-image.png"></p><h2 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596690044-image.png"></p><hr><h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><h2 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h2><p>a<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596700235-image.png"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p><strong>拥塞控制的一般原理</strong></p><ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ul><p><strong>开环控制和闭环控制</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596711502-image.png"></p><p><strong>监测网络的拥塞</strong></p><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596724391-image.png"></p><blockquote><p>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</p></blockquote><p>下图的实例横纵坐标的意思</p><p>传输轮次：</p><ul><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ul><p>拥塞窗口：</p><ul><li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li></ul><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><h4 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h4><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul><li>1 至 2 个最大报文段 （旧标准）</li><li>2 至 4 个最大报文段 （RFC 5681）</li></ul></li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672800796-image.png"></p><blockquote><p>图中swnd是发送窗口</p><p>每经过一个传输轮次，拥塞窗口就加倍</p><p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p></blockquote><h4 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h4><ul><li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 <strong>cwnd = cwnd + 1</strong>。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672827246-image.png"></p><p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672837802-image.png"></p><p>这个时候又回到了慢开始</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672850929-image.png"></p><h4 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672860893-image.png"></p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672874679-image.png"></p><h4 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672884424-image.png"></p><h4 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672895607-image.png"></p><h4 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672905250-image.png"></p><hr><h1 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678883966-image.png"></p><blockquote><p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678900627-image.png"></p><blockquote><p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678932186-image.png"></p><p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678951370-image.png"></p><p><strong>往返时间RTT的测量比较复杂</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678967280-image.png"></p><p><strong>TCP超时重传的计算</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678990994-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678999939-image.png"></p><hr><h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640679671661-image.png"></p><p>接收方表明自己的接收窗口的尺寸为20字节，确认号字段的值为31，这表明接收方希望收到下一个数据的序号是31，而序号30为止的数据已经全部正确接收了。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640679686142-image.png"><br>向后收缩，这发生在通知方通知的窗口变小了，但TCP标准<strong>强烈不赞成这样做</strong>，因为很可能发送方在收到这个通知之前，就已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，显然就会产生错误。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640680000273-image.png"></p><p>取其中一段分析：</p><p>现在，假设又有几个数据报文段到达了接收方，它们封装有37，38以及40号数据。这些数据的序号虽然落在接收窗口内，但它们都是未按序到达的数据，只能先暂存在接收缓存中。（<strong>接收方只能对按序收到的数据中的最高序号给出确认，因此接收方发出的确认报文段中的确认序号仍然是34！</strong>），假设接收方先前发送的确认报文段到达了发送方，发送方接收后，将发送窗口向前滑动3个序号，发送窗口的尺寸保持不变，这样就有51 ~ 53落入发送窗口内（TCP的通信是全双工通信），而序号31 ~ 33移出了发送窗口，现在可将31 ~ 33号数据从发送缓存中删除了，因为已经收到了接收方针对它们的确认。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640680878218-1111%2000_00_00-00_00_30.gif"></p><p>发送方继续将发送窗口内序号42 ~ 53的数据，封装在几个不同的报文段中发送出去。现在，发送窗口内的序号已经用完了，发送方在未收到接收方发来确认的情况下，不能再发送新的数据。序号落在发送窗口内的已发送数据，如果迟迟收不到接收方的确认，则会产生超时重传。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640681334428-2222%2000_00_00-00_00_30.gif"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640683418223-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640684428298-image.png"></p><p>小结：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640680009785-image.png"></p><hr><h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><h2 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687086367-image.png"></p><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ul><h3 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687111374-image.png"></p><h3 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li></ul><p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p><p>过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687123235-image.png"></p><blockquote><p>最初两端的TCP进程都处于关闭状态</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687134793-image.png"></p><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p></blockquote><p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687152119-image.png"></p><blockquote><p>TCP客户进程也是首先创建传输控制块</p></blockquote><p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687169382-image.png"></p><blockquote><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p><p>TCP连接请求报文段首部中</p><ul><li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ul><p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687179871-image.png"></p><blockquote><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>TCP连接请求确认报文段首部中</p><ul><li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ul><p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687191428-image.png"></p><blockquote><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul><p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687299599-image.png"></p><blockquote><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p><p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p></blockquote><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p><p>下图实例是“两报文握手”</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687246401-image.png"></p><blockquote><p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。</p><p>本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p><p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p></blockquote><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640686977693-image.png"></p><blockquote><p>主机乙中seq值可以随意指定！</p></blockquote><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640686820398-image.png"></p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li></ul><h3 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><p>过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687336148-image.png"></p><blockquote><p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p><p>TCP客户进程的应用进程通知其主动关闭TCP连接</p><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p><p>TCP连接释放报文段首部中</p><ul><li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li></ul><p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687344791-image.png"></p><blockquote><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687353383-image.png"></p><blockquote><p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p><p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p><p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687362766-image.png"></p><blockquote><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p><p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p><p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687373721-image.png"></p><blockquote><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p><p>该报文段首部中</p><ul><li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687385502-image.png"></p><blockquote><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><p>该报文段首部中</p><ul><li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p></blockquote><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687399077-image.png"></p><blockquote><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p><p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p></blockquote><h3 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h3><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687414345-image.png"></p><hr><h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687441393-image.png"></p><h2 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><p>源端口和目的端口</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687457197-image.png"></p><p>序号、确认号和确认标志位</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640690654588-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687466989-image.png"></p><p>数据偏移、保留、窗口和校验和</p><blockquote><p>0101十进制值是5，而该字段以4字节为单位，因此5×4字节等于20字节</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687478348-image.png"></p><blockquote><p>发送窗口大小除了取决于窗口值（流量控制：即以接收方的接收能力来控制发送方的发送能力。），还取决于拥塞窗口的大小，也就是<strong>应从接收窗口和拥塞窗口中取小者。</strong></p></blockquote><blockquote><p>伪首部：是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而<strong>仅仅是为计算校验和。</strong><br>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640691816590-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687490468-image.png"></p><p>选项和填充</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687499235-image.png"></p><hr><hr><hr><h1 id="———应用层———"><a href="#———应用层———" class="headerlink" title="———应用层———"></a>———应用层———</h1><h1 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699621079-image.png"></p><p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699639658-image.png"></p><p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP/IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699651500-image.png"></p><p>常见的应用</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699658569-image.png"></p><p>总结</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699664707-image.png"></p><hr><h1 id="客户-服务器方式（C-S方式）和对等方式（P2P方式）"><a href="#客户-服务器方式（C-S方式）和对等方式（P2P方式）" class="headerlink" title="客户/服务器方式（C/S方式）和对等方式（P2P方式）"></a>客户/服务器方式（C/S方式）和对等方式（P2P方式）</h1><h2 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699672592-image.png"></p><h2 id="客户-服务器方式（C-S方式）"><a href="#客户-服务器方式（C-S方式）" class="headerlink" title="客户/服务器方式（C/S方式）"></a>客户/服务器方式（C/S方式）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699680239-image.png"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699688292-image.png"></p><h2 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699695101-image.png"></p><hr><h1 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h1><h2 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h2><ul><li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li></ul><h2 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h2><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699707503-image.png"></p><blockquote><p>如果主机数很多，就工作量大，容易出错</p></blockquote><p>如果我们给网络中添加一台DHCP服务器</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699717347-image.png"></p><h2 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h2><p><strong>DHCP 使用客户 - 服务器方式</strong></p><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。 </li></ul><p><strong>DHCP 工作方式</strong></p><ul><li>DHCP 使用客户-服务器方式，采用请求/应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><p><strong>DHCP交互过程</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699732169-image.png"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul><p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p><p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p><p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699811764-image.png"></p><blockquote><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息：<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul><p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p><p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699824835-image.png"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li></ul><p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p><p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699836271-image.png"></p><blockquote><p>源地址：DHCP服务器1的IP地址</p><p>目的地址：广播地址</p><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p><p><strong>在使用前还会进行ARP检测</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699848961-image.png"></p></blockquote><p>剩下流程图示</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699877833-image.png"></p><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p><blockquote><p>不能，因为该网络中的主机广播发送DHCP发现报文，但该广播报文不会被路由器转发，而是丢弃！</p><p>解决方法：给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理。</p><p>这样，该网络中的各主机，就可以通过DHCP来自动获取到网络配置信息了。当该路由器收到广播的DHCP发现报文后，会将其单播转发给DHCP服务器。DHCP客户和DHCP服务器，通过该路由器的后续交互过程不再赘述。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699897840-image.png"></p></blockquote><blockquote><p>使用DHCP中继代理，是因为我们不想给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h2 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699910122-image.png"></p><hr><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>域名相比IP地址更容易记忆</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699921876-image.png"></p><p>因特网是否可以只使用一台DNS服务器？</p><p>不行</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699951577-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699961759-image.png"></p><blockquote><p>名称相同的域名其等级未必相同</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700014041-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700029465-image.png"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700066509-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700089285-image.png"><br>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640704229813-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700100995-image.png"></p><h2 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700109350-image.png"></p><hr><h1 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h1><h2 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700118459-image.png"></p><blockquote><p>FTP常见用途：在计算机之间传输文件，尤其是用于批量传输文件。另一个用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器。</p></blockquote><h2 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h2><p>FTP采用C/S方式（客户/服务器方式）</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700136231-image.png"></p><p>FTP客户计算机也可以从FTP服务器计算机下载文件</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700154631-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700166845-image.png"></p><p>举例：<br>命令行方式：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640704656061-image.png"></p><p>第三方FTP客户工具软件：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640704725879-image.png"></p><h2 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h2><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p><p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700189620-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700199838-image.png"></p><p>下图为建立数据通道的TCP连接</p><p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700213511-image.png"></p><blockquote><p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p></blockquote><p>下图实例为被动模式</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700225311-image.png"></p><p>两种模式对比</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700266534-image.png"></p><blockquote><p>注意两种模式都是</p><p>控制连接在整个会话期间保持打开状态</p><p>数据连接传输完毕后就关闭</p></blockquote><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640705194210-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640705271912-image.png"></p><h2 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700280573-image.png"></p><hr><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700300232-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700313938-image.png"></p><h2 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700333886-image.png"></p><h2 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700344955-image.png"></p><blockquote><p>若身份无效返回：421，表示服务不可用。</p></blockquote><h2 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700368026-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700379445-image.png"></p><h2 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700395959-image.png"></p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700405739-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706320305-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706399810-image.png"></p><blockquote><p>ASCLL码就是7比特的</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706563105-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706763484-image.png"></p><h2 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700414232-image.png"></p><hr><h1 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h1><h2 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h2><p><strong>概述</strong></p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700435068-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700446004-image.png"></p><p><strong>万维网应用举例</strong></p><p>访问网页</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700456485-image.png"></p><p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700466582-image.png"></p><p><strong>万维网的文档</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700476577-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640707081713-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640707141842-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640707153020-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640707213513-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640707265073-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640707278843-image.png"></p><h2 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h2><h3 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700497598-image.png"></p><ul><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700519064-image.png"></p><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p><strong>HTTP请求报文格式</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700531789-image.png"></p><p><strong>HTTP响应报文格式</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700549219-image.png"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700560668-image.png"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700570174-image.png"></p><p>如果该请求有缓存</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700579382-image.png"></p><p>如果该请求没有缓存</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700589761-image.png"></p><blockquote><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p></blockquote><p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p><p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p><p>若未过期</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700602580-image.png"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700613260-image.png"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700633990-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640708145270-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640708222420-image.png"></p><h2 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700642747-image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;———概述———&quot;&gt;&lt;a href=&quot;#———概述———&quot; class=&quot;headerlink&quot; title=&quot;———概述———&quot;&gt;&lt;/a&gt;———概述———&lt;/h1&gt;&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-6应用层</title>
    <link href="http://example.com/2021/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-6%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-6%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-12-28T13:52:31.000Z</published>
    <updated>2021-12-28T16:18:05.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-1、应用层概述"><a href="#6-1、应用层概述" class="headerlink" title="6.1、应用层概述"></a>6.1、应用层概述</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699621079-image.png"></p><p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699639658-image.png"></p><p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP/IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699651500-image.png"></p><p>常见的应用</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699658569-image.png"></p><p>总结</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699664707-image.png"></p><hr><h1 id="6-2、客户-服务器方式（C-S方式）和对等方式（P2P方式）"><a href="#6-2、客户-服务器方式（C-S方式）和对等方式（P2P方式）" class="headerlink" title="6.2、客户/服务器方式（C/S方式）和对等方式（P2P方式）"></a>6.2、客户/服务器方式（C/S方式）和对等方式（P2P方式）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699672592-image.png"></p><h2 id="客户-服务器方式（C-S方式）"><a href="#客户-服务器方式（C-S方式）" class="headerlink" title="客户/服务器方式（C/S方式）"></a>客户/服务器方式（C/S方式）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699680239-image.png"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699688292-image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699695101-image.png"></p><hr><h1 id="6-3、动态主机配置协议DHCP"><a href="#6-3、动态主机配置协议DHCP" class="headerlink" title="6.3、动态主机配置协议DHCP"></a>6.3、动态主机配置协议DHCP</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li></ul><h2 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h2><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699707503-image.png"></p><blockquote><p>如果主机数很多，就工作量大，容易出错</p></blockquote><p>如果我们给网络中添加一台DHCP服务器</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699717347-image.png"></p><h2 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h2><p><strong>DHCP 使用客户 - 服务器方式</strong></p><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。 </li></ul><p><strong>DHCP 工作方式</strong></p><ul><li>DHCP 使用客户-服务器方式，采用请求/应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><p><strong>DHCP交互过程</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699732169-image.png"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul><p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p><p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p><p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699811764-image.png"></p><blockquote><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息：<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul><p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p><p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699824835-image.png"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li></ul><p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p><p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699836271-image.png"></p><blockquote><p>源地址：DHCP服务器1的IP地址</p><p>目的地址：广播地址</p><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p><p><strong>在使用前还会进行ARP检测</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699848961-image.png"></p></blockquote><p>剩下流程图示</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699877833-image.png"></p><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p><blockquote><p>不能，因为该网络中的主机广播发送DHCP发现报文，但该广播报文不会被路由器转发，而是丢弃！</p><p>解决方法：给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理。</p><p>这样，该网络中的各主机，就可以通过DHCP来自动获取到网络配置信息了。当该路由器收到广播的DHCP发现报文后，会将其单播转发给DHCP服务器。DHCP客户和DHCP服务器，通过该路由器的后续交互过程不再赘述。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699897840-image.png"></p></blockquote><blockquote><p>使用DHCP中继代理，是因为我们不想给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699910122-image.png"></p><hr><h1 id="6-4、域名系统DNS"><a href="#6-4、域名系统DNS" class="headerlink" title="6.4、域名系统DNS"></a>6.4、域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>域名相比IP地址更容易记忆</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699921876-image.png"></p><p>因特网是否可以只使用一台DNS服务器？</p><p>不行</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699951577-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640699961759-image.png"></p><blockquote><p>名称相同的域名其等级未必相同</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700014041-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700029465-image.png"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700066509-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700089285-image.png"><br>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640704229813-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700100995-image.png"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700109350-image.png"></p><hr><h1 id="6-5、文件传送协议FTP"><a href="#6-5、文件传送协议FTP" class="headerlink" title="6.5、文件传送协议FTP"></a>6.5、文件传送协议FTP</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700118459-image.png"></p><blockquote><p>FTP常见用途：在计算机之间传输文件，尤其是用于批量传输文件。另一个用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器。</p></blockquote><h2 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h2><p>FTP采用C/S方式（客户/服务器方式）</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700136231-image.png"></p><p>FTP客户计算机也可以从FTP服务器计算机下载文件</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700154631-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700166845-image.png"></p><p>举例：<br>命令行方式：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640704656061-image.png"></p><p>第三方FTP客户工具软件：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640704725879-image.png"></p><h2 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h2><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p><p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700189620-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700199838-image.png"></p><p>下图为建立数据通道的TCP连接</p><p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700213511-image.png"></p><blockquote><p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p></blockquote><p>下图实例为被动模式</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700225311-image.png"></p><p>两种模式对比</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700266534-image.png"></p><blockquote><p>注意两种模式都是</p><p>控制连接在整个会话期间保持打开状态</p><p>数据连接传输完毕后就关闭</p></blockquote><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640705194210-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640705271912-image.png"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700280573-image.png"></p><hr><h1 id="6-6、电子邮件"><a href="#6-6、电子邮件" class="headerlink" title="6.6、电子邮件"></a>6.6、电子邮件</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700300232-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700313938-image.png"></p><h2 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700333886-image.png"></p><h2 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700344955-image.png"></p><blockquote><p>若身份无效返回：421，表示服务不可用。</p></blockquote><h2 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700368026-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700379445-image.png"></p><h2 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700395959-image.png"></p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700405739-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706320305-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706399810-image.png"></p><blockquote><p>ASCLL码就是7比特的</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706563105-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640706763484-image.png"></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700414232-image.png"></p><hr><h1 id="6-7、万维网WWW"><a href="#6-7、万维网WWW" class="headerlink" title="6.7、万维网WWW"></a>6.7、万维网WWW</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><strong>概述</strong></p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700435068-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700446004-image.png"></p><p><strong>万维网应用举例</strong></p><p>访问网页</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700456485-image.png"></p><p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700466582-image.png"></p><p><strong>万维网的文档</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700476577-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640707081713-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640707141842-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640707153020-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640707213513-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640707265073-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640707278843-image.png"></p><h2 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h2><h3 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700497598-image.png"></p><ul><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700519064-image.png"></p><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p><strong>HTTP请求报文格式</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700531789-image.png"></p><p><strong>HTTP响应报文格式</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700549219-image.png"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700560668-image.png"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700570174-image.png"></p><p>如果该请求有缓存</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700579382-image.png"></p><p>如果该请求没有缓存</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700589761-image.png"></p><blockquote><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p></blockquote><p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p><p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p><p>若未过期</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700602580-image.png"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700613260-image.png"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700633990-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640708145270-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-29/1640708222420-image.png"></p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640700642747-image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-1、应用层概述&quot;&gt;&lt;a href=&quot;#6-1、应用层概述&quot; class=&quot;headerlink&quot; title=&quot;6.1、应用层概述&quot;&gt;&lt;/a&gt;6.1、应用层概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/r2peak/picture</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-5运输层</title>
    <link href="http://example.com/2021/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-5%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2021/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-5%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2021-12-26T13:14:31.000Z</published>
    <updated>2021-12-28T11:51:09.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>进程之间的通信</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570397495-image.png"></p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570382327-image.png"></p><p><strong>进程之间通信流程</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570412444-image.png"></p><p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p><blockquote><p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p><p>在运输层使用不同的端口，来对应不同的应用进程</p><p>然后通过网络层及其下层来传输应用层报文</p><p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570431417-image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570455190-image.png"></p><hr><h1 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h1><h2 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570698686-image.png"></p><h2 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570710106-image.png"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p></blockquote><h2 id="TCP-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP/IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570726065-image.png"></p><p><strong>在运输层不管用TCP还是UDP协议，在网络层都得用IP协议。IP数据报首部中协议字段的值，表明了IP数据报数据载荷部分，封装的是何种协议数据单元。</strong></p><h2 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h2><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570742253-image.png"></p><blockquote><p>在浏览器输入域名，回车浏览</p><p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p><p>DNS查询请求报文需要使用运输层的UDP协议</p><p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p><p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570763034-image.png"></p><blockquote><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570822635-image.png"></p><blockquote><p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p><p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p><p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570847903-image.png"></p><blockquote><p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640570859587-image.png"></p><blockquote><p>用户PC收到该数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p><p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p></blockquote><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571228264-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571247168-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571255174-image.png"></p><hr><h1 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP/IP体系结构<strong>运输层</strong>中的两个重要协议</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。 </li></ul><p>可靠信道与不可靠信道</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640571544489-image.png"></p><ul><li><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p></li><li><p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p></li><li><p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594363177-image.png"></p><p>UDP的通信是无连接的，不需要套接字（Socket）</p><p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p><h2 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h2><p>可以发送广播</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594379987-image.png"></p><p>可以向某个多播组发送多播</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594389652-image.png"></p><p>还可以发送单播</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594463753-image.png"></p><blockquote><p>UDP 支持单播、多播以及广播</p><p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p></blockquote><p>运输过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594478507-image.png"></p><blockquote><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p><p>换句话说，UDP是面向应用报文的</p></blockquote><p>UDP向上层提供无连接不可靠传输服务</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594489817-image.png"></p><p>UDP结构</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594498410-image.png"></p><h2 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h2><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594508156-image.png"></p><p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594516929-image.png"></p><blockquote><p>很显然，TCP仅支持单播，也就是一对一的通信</p></blockquote><p>运输过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594534085-image.png"></p><blockquote><p>发送方</p><ul><li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p></li><li><p>并将他们编号，并存储在自己发送缓存中</p></li><li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p></li></ul><p>接收方</p><ul><li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li><li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li><li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul><p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p><p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p></blockquote><p>TCP向上层提供面向连接的可靠传输服务</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594545712-image.png"></p><p>TCP结构</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594563129-image.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640594577884-image.png"></p><hr><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596277539-image.png"></p><p>举例</p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p><p>下图中大写的ACK是TCP报文段首部中的标志位，取值1表示这是一个TCP确认报文段，小写ack是TCP报文段首部中的确认号字段，取值201表示序号201之前的数据已全部正确接收，现在希望收到序号201及其后续数据。rwnd是TCP报文段首部中的窗口字段，取值300表示自己的接收窗口大小为300</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596290411-image.png"></p><p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596300641-image.png"></p><p>上图主机A，发送窗口内序号201 ~ 300这100个字节数据的重传计时器超时了，主机A将它们重新封装成一个TCP报文段发送出去，暂时不能发送其它数据。主机B收到该重传的TCP报文段后，对主机A发送的501号之前的数据进行累计确认。并在该累计确认中，将窗口字段的值调整为100，这是主机B对主机A进行的第二次流量控制。</p><p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中，将自己的接收窗口调整为了100，因此，主机A相应的将自己的发送窗口调整为100。</p><p>目前主机A发送窗口内的序号为501 ~ 600，也就是主机A还可以发送这100字节。主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596666730-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596360544-image.png"></p><p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p>在本例中，主机A收到零窗口通知时，就启动一个持续计时器，当持续计时器超时，主机A立刻发送一个仅携带一字节数据的零窗口探测报文段。假设主机B此时的接收窗口又为0了，主机B就在确认这个零窗口探测报文段时，给出自己现在的接收窗口值为0，主机A再次收到零窗口通知，就再次启动一个持续计时器，当持续计时器超时，主机A就立刻发送一个零窗口探测报文段，假设主机B此时的接收缓存又有了一些存储空间，于是将自己的接收窗口调整为了300，主机B就在确认这个零窗口探测报文段时，给出自己现在的接收窗口值为300，这样就打破了死锁的局面。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596388493-image.png"><br>问题：</p><p>主机A所发送的零窗口探测报文段到达主机B时，如果主机B此时的接收窗口仍然为0，那么主机B根本无法接收该报文段，又怎么会针对该报文段给主机A发回确认呢？</p><p>答：<strong>TCP规定，即使接收窗口为0，也必须接收零窗口探测报文段、确认报文段、以及携带有紧急数据的报文段。</strong></p><p>问题2：</p><p>上图如果零窗口探测报文在发送过程中如果丢失，能否打破死锁局面？</p><p>答：<strong>能，因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传。</strong></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640598743827-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640598801135-image.png"><br>由于主机乙在确认中，给出自己的接收窗口大小为2000字节，因此主机甲相应的将自己的发送窗口调整为2000字节。显然，主机甲还可以向主机乙发送2000 ~ 2999号字节数据，共1000个字节。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640598879935-image.png"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596690044-image.png"></p><hr><h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>a<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596700235-image.png"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p><strong>拥塞控制的一般原理</strong></p><ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ul><p><strong>开环控制和闭环控制</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596711502-image.png"></p><p><strong>监测网络的拥塞</strong></p><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640596724391-image.png"></p><blockquote><p>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</p></blockquote><p>下图的实例横纵坐标的意思</p><p>传输轮次：</p><ul><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ul><p>拥塞窗口：</p><ul><li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li></ul><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><h4 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h4><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul><li>1 至 2 个最大报文段 （旧标准）</li><li>2 至 4 个最大报文段 （RFC 5681）</li></ul></li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672800796-image.png"></p><blockquote><p>图中swnd是发送窗口</p><p>每经过一个传输轮次，拥塞窗口就加倍</p><p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p></blockquote><h4 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h4><ul><li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 <strong>cwnd = cwnd + 1</strong>。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672827246-image.png"></p><p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672837802-image.png"></p><p>这个时候又回到了慢开始</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672850929-image.png"></p><h4 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672860893-image.png"></p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672874679-image.png"></p><h4 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672884424-image.png"></p><h4 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672895607-image.png"></p><h4 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h4><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640672905250-image.png"></p><hr><h1 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678883966-image.png"></p><blockquote><p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678900627-image.png"></p><blockquote><p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678932186-image.png"></p><p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678951370-image.png"></p><p><strong>往返时间RTT的测量比较复杂</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678967280-image.png"></p><p><strong>TCP超时重传的计算</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678990994-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640678999939-image.png"></p><hr><h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640679671661-image.png"></p><p>接收方表明自己的接收窗口的尺寸为20字节，确认号字段的值为31，这表明接收方希望收到下一个数据的序号是31，而序号30为止的数据已经全部正确接收了。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640679686142-image.png"><br>向后收缩，这发生在通知方通知的窗口变小了，但TCP标准<strong>强烈不赞成这样做</strong>，因为很可能发送方在收到这个通知之前，就已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，显然就会产生错误。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640680000273-image.png"></p><p>取其中一段分析：</p><p>现在，假设又有几个数据报文段到达了接收方，它们封装有37，38以及40号数据。这些数据的序号虽然落在接收窗口内，但它们都是未按序到达的数据，只能先暂存在接收缓存中。（<strong>接收方只能对按序收到的数据中的最高序号给出确认，因此接收方发出的确认报文段中的确认序号仍然是34！</strong>），假设接收方先前发送的确认报文段到达了发送方，发送方接收后，将发送窗口向前滑动3个序号，发送窗口的尺寸保持不变，这样就有51 ~ 53落入发送窗口内（TCP的通信是全双工通信），而序号31 ~ 33移出了发送窗口，现在可将31 ~ 33号数据从发送缓存中删除了，因为已经收到了接收方针对它们的确认。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640680878218-1111%2000_00_00-00_00_30.gif"></p><p>发送方继续将发送窗口内序号42 ~ 53的数据，封装在几个不同的报文段中发送出去。现在，发送窗口内的序号已经用完了，发送方在未收到接收方发来确认的情况下，不能再发送新的数据。序号落在发送窗口内的已发送数据，如果迟迟收不到接收方的确认，则会产生超时重传。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640681334428-2222%2000_00_00-00_00_30.gif"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640683418223-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640684428298-image.png"></p><p>小结：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640680009785-image.png"></p><hr><h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687086367-image.png"></p><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ul><h3 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687111374-image.png"></p><h3 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li></ul><p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p><p>过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687123235-image.png"></p><blockquote><p>最初两端的TCP进程都处于关闭状态</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687134793-image.png"></p><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p></blockquote><p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687152119-image.png"></p><blockquote><p>TCP客户进程也是首先创建传输控制块</p></blockquote><p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687169382-image.png"></p><blockquote><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p><p>TCP连接请求报文段首部中</p><ul><li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ul><p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687179871-image.png"></p><blockquote><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>TCP连接请求确认报文段首部中</p><ul><li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ul><p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687191428-image.png"></p><blockquote><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul><p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687299599-image.png"></p><blockquote><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p><p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p></blockquote><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p><p>下图实例是“两报文握手”</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687246401-image.png"></p><blockquote><p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。</p><p>本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p><p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p></blockquote><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640686977693-image.png"></p><blockquote><p>主机乙中seq值可以随意指定！</p></blockquote><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640686820398-image.png"></p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li></ul><h3 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><p>过程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687336148-image.png"></p><blockquote><p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p><p>TCP客户进程的应用进程通知其主动关闭TCP连接</p><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p><p>TCP连接释放报文段首部中</p><ul><li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li></ul><p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687344791-image.png"></p><blockquote><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687353383-image.png"></p><blockquote><p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p><p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p><p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687362766-image.png"></p><blockquote><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p><p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p><p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687373721-image.png"></p><blockquote><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p><p>该报文段首部中</p><ul><li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687385502-image.png"></p><blockquote><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><p>该报文段首部中</p><ul><li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p></blockquote><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687399077-image.png"></p><blockquote><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p><p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p></blockquote><h3 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h3><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687414345-image.png"></p><hr><h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687441393-image.png"></p><h2 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><p>源端口和目的端口</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687457197-image.png"></p><p>序号、确认号和确认标志位</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640690654588-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687466989-image.png"></p><p>数据偏移、保留、窗口和校验和</p><blockquote><p>0101十进制值是5，而该字段以4字节为单位，因此5×4字节等于20字节</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687478348-image.png"></p><blockquote><p>发送窗口大小除了取决于窗口值（流量控制：即以接收方的接收能力来控制发送方的发送能力。），还取决于拥塞窗口的大小，也就是<strong>应从接收窗口和拥塞窗口中取小者。</strong></p></blockquote><blockquote><p>伪首部：是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而<strong>仅仅是为计算校验和。</strong><br>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640691816590-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687490468-image.png"></p><p>选项和填充</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-28/1640687499235-image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运输层概述&quot;&gt;&lt;a href=&quot;#运输层概述&quot; class=&quot;headerlink&quot; title=&quot;运输层概述&quot;&gt;&lt;/a&gt;运输层概述&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-4网络层</title>
    <link href="http://example.com/2021/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/12/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-12-25T13:14:31.000Z</published>
    <updated>2021-12-27T01:42:29.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442280332-image.png"></p><blockquote><p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p><p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p><p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p></blockquote><ul><li><p>要实现网络层任务，需要解决一下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li></ul><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><ul><li>网络层寻址问题</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442296825-image.png"></p><ul><li>路由选择问题</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442304389-image.png"></p><blockquote><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442319976-image.png"></p></blockquote><blockquote><p>但在实际当中，路由器是怎样知道这些路由记录？</p><ul><li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li><li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442336736-image.png"></p><blockquote><p>补充<br>：<strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640442370296-image.png"></p><hr><h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？ </li></ul><h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><p><strong>一种观点：让网络负责可靠交付</strong></p><ul><li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li><li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。 </li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479609694-image.png"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p><blockquote><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li><li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li></ul></blockquote><h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><p><strong>另一种观点：网络提供数据报服务</strong></p><ul><li>互联网的先驱者提出了一种崭新的网络设计思路。</li><li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-27/1640569294416-image.png"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p><blockquote><p><strong>尽最大努力交付</strong></p><ul><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li><li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li><li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul></blockquote><h2 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h2><table><thead><tr><th><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td><strong>思路</strong></td><td><strong>可靠通信应当由网络来保证</strong></td><td><strong>可靠通信应当由用户主机来保证</strong></td></tr><tr><td><strong>连接的建立</strong></td><td><strong>必须有</strong></td><td><strong>不需要</strong></td></tr><tr><td><strong>终点地址</strong></td><td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td><td><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td><strong>分组的转发</strong></td><td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td><td><strong>每个分组独立选择路由进行转发</strong></td></tr><tr><td><strong>当结点出故障时</strong></td><td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td><td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td><strong>分组的顺序</strong></td><td><strong>总是按发送顺序到达终点</strong></td><td><strong>到达终点时不一定按发送顺序</strong></td></tr><tr><td><strong>端到端的差错处理和流量控制</strong></td><td><strong>可以由网络负责，也可以由用户主机负责</strong></td><td><strong>由用户主机负责</strong></td></tr></tbody></table><hr><h1 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479875281-image.png"></p><blockquote><p>记住各位对应的权值，用看情况加/减法。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640480224801-image.png"></p><h2 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479892376-image.png"></p><ul><li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li></ul><p><strong>A类地址</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479942073-image.png"></p><p><strong>B类地址</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479955722-image.png"></p><p><strong>C类地址</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479969946-image.png"></p><p><strong>练习</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640479984452-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640481813330-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640482140908-image.png"></p><p>俩路由器之间，无主机，只有俩路由器接口，需要可分配的IP地址数量为2，给该网络分配一个A类、B类、C类网络号都可以，本着节约IP地址的原则，给该网络分配一个C类网络号。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640482187843-image.png"><br>综上：<br>橙色A类，蓝色B类，绿色C类，红色C类。</p><blockquote><p>A类地址每个网络中可分配IP地址数量为：2^24 - 2（去除主机号全0的网络地址，和全1的广播地址） = 1677,7214</p><p>B类为：2^16 - 2 = 65534</p><p>C类为：2^8 - 2 = 254</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640482981898-image.png"></p><p><strong>IP 地址的一些重要特点</strong></p><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><ul><li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。 </li></ul><p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。 </li></ul><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p><p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><h3 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h3><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ul><li>IP 地址空间的利用率有时很低。 </li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li><li>两级的 IP 地址不够灵活。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483385676-image.png"></p><p>如果想要将原来的网络划分成三个独立的网路</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483394592-image.png"></p><p>所以是否可以从主机号部分借用一部分作为子网号</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483401882-image.png"></p><blockquote><p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p><p>所以就有了划分子网的工具：<strong>子网掩码</strong></p><ul><li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li><li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li><li>划分子网已成为互联网的正式标准协议。 </li></ul></blockquote><h3 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h3><p>基本思路</p><ul><li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li><li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483412983-image.png"></p><ul><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li><li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul><p>划分为三个子网后对外仍是一个网络</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483420624-image.png"></p><blockquote><ul><li><strong>优点</strong><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol></li><li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li></ul></blockquote><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483430472-image.png"></p><blockquote><p><strong>(IP 地址) AND (子网掩码) = 网络地址</strong> 重要，下面很多相关知识都会用到</p></blockquote><p>举例</p><p>例子1</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483438980-image.png"></p><blockquote><p>下题中，给的子网掩码255.255.255.128中的128表明从主机号部分借用一个比特作为子网号，也就是<strong>将该C类网均分为两个子网，其子网号分别为0和1</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483455297-image.png"></p><blockquote><p>上图可看出，子网掩码255.255.255.128可将C类网218.75.230.0均分为两个子网</p></blockquote><p>例子2</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483468060-image.png"></p><blockquote><p>主要是看子网号有几位，1位就可划分出2^1个子网，2位就可划分出2^2个子网。</p><p>子网号怎么看？</p><p>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号</p><p>解释：先看是A、B、C哪类网，从而确定网络、主机号有几位，子网掩码主机号部分如255.255.255.192这个是C类网，它的主机号是后8位，192写成八位二进制：11000000，前两位11，表示它子网号就有2^2个。即：00、01、10、11</p><p>梦回计组嗷~</p></blockquote><p>考研题：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485297681-image.png"></p><blockquote><p>思路如下：</p></blockquote><blockquote><p>1、180开头是B类网，网络号16位，主机号16位。将IP地址的主机号部分转换成二进制形式，将子网掩码中，连续的6个比特1所对应的主机号部分作为子网号。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485503303-image.png"></p><blockquote><p>2、将网络号和子网号保持不变，而将主机号的10个比特全部取0，就可以得到该主机所在子网的网络地址。</p><p>写成点分十进制为：180.80.76.0<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485588635-image.png"><br>3、将网络号和子网号保持不变，而将主机号的10个比特全部取1，就可以得到该主机所在子网的广播地址</p><p>写成点分十进制为：180.80.79.255<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640485684854-image.png"></p></blockquote><blockquote><p>在这俩区间中（180.80.76.0 ~ 180.80.79.255），可以找到答案。</p></blockquote><p><strong>默认子网掩码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483486944-image.png"></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640483495990-image.png"></p><blockquote><ul><li>子网掩码是一个网络或一个子网的重要属性。</li><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><h3 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h3><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。 </p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486841507-image.png"></p><blockquote><p><strong>CIDR 最主要的特点</strong></p><ul><li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。 </li></ul></blockquote><h3 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486863329-image.png"></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486871657-image.png"></p><h3 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h3><p>存在意义？</p><blockquote><p>路由器R1与五个网络以及路由器R2直接相连，路由器R1和R2互为相邻路由器，它们周期性地通告自己所知道的路由信息给对方。</p><p>若R1将自己直连的这五个网络的路由记录都通告给R2，则R2的路由表会增加5条路由记录。</p><p>为了减少路有记录对路由表的占用，采用路由聚合（构造超网）（即找它们共同前缀）的方式。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486879241-image.png"></p></blockquote><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640487955743-image.png"></p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640486886563-image.png"></p><h2 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h2><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489579592-image.png"></p><h3 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488402926-image.png"></p><p><strong>划分子网的IPv4就是定长的子网掩码</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488851899-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488863501-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640488877218-image.png"></p><blockquote><p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的网络N1</del>N5</p><p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p><p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p><p>例如：图中N5只需要4个网络地址，但我们只能给它分配32个。</p></blockquote><h3 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489022597-image.png"></p><p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489040146-image.png"><br>在地址块中给左图所示的网络N1~N5分配子块，分配原则是<strong>每个子块的起点位置不能随意选取，只能选取块大小整数倍的地址作为起点</strong>。建议<strong>先给大的子块分配</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640489051371-image.png"></p><hr><h1 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497932862-image.png"></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497956222-image.png"></p><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497973189-image.png"></p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li></ul></blockquote><p>主机C如何知道路由器R的存在？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497984707-image.png"></p><blockquote><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p><p>例如。路由器的接口0的IP地址192.168.0.128作为左边网络的默认网关</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640497997542-image.png"></p><blockquote><p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p></blockquote><p>路由器收到IP数据报后如何转发？</p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的下一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ul><p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498035998-image.png"></p><p>接下来路由器对该IP数据报进行查表转发</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498046281-image.png"></p><blockquote><p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一跳指示，图中所示的也就是接口1转发该IP数据报</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498056843-image.png"></p><p>路由器是隔离广播域的</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498134626-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498157727-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498227451-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498367352-image.png"></p><p>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498391300-image.png"></p><hr><h1 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498448485-image.png"></p><h2 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h2><p> <strong>静态路由配置</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498462419-image.png"></p><p><strong>默认路由</strong></p><p>举例</p><p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640498473675-image.png"></p><p><strong>特定主机路由</strong></p><p>举例</p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p><p>一般用于网络管理人员对网络的管理和测试</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501073543-image.png"></p><blockquote><p>多条路由可选，匹配路由最具体的，也就是最长前缀匹配，找不到时，匹配默认路由。</p></blockquote><p><strong>静态路由配置错误导致路由环路</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501438058-image.png"></p><p>假设将R2的路由表中第三条目录配置错了下一跳</p><p>这导致R2和R3之间产生了路由环路</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501448219-image.png"></p><p><strong>聚合了不存在的网络而导致路由环路</strong></p><p>举例</p><p>正常情况</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501459117-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501539138-image.png"></p><p>错误情况</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501549689-image.png"></p><p>解决方法</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501561471-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501571088-image.png"></p><blockquote><p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p></blockquote><p><strong>网络故障而导致路由环路</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501580517-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501589454-image.png"></p><p>解决方法</p><p>在R1的路由表中，添加针对该直连网络的黑洞路由。</p><p>这样，当R2要转发IP数据报到该网络时，进行查表转发，找到匹配的路由条目，下一跳转发给R1的接口1。R1收到该IP数据报后，进行查表转发，找到匹配的路由条目，为一条黑洞路由，下一跳为虚拟接口null0，因此该IP数据报会进入这个黑洞。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501600545-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501614509-image.png"></p><p>假设，一段时间后故障网络恢复了</p><p>则R1又自动地得出了其接口0的直连网络的路由条目</p><p>并将我们之前人工配置的，针对该直连网络的黑洞路由条目设置为失效状态。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501668021-image.png"></p><p>假设R1再次检测到其接口0所直连的网络，出现了故障而不可达，则会自动在其路由表中删除该直连网络的路由条目。</p><p>并将我们之前人工配置的，针对该直连网络的黑洞路由条目，设置为生效状态。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501679622-image.png"></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640501692517-image.png"></p><hr><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504176232-image.png"></p><p><strong>因特网所采用的路由选择协议的主要特点</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504194636-image.png"></p><p><strong>因特网采用分层次的路由选择协议</strong></p><ul><li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504209365-image.png"></p><blockquote><p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504290247-image.png"></p><blockquote><p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p><p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p><p>使用”网关“这个名词，是因为因特网早期的RFC文档中，没有使用”路由器“。现在新的RFC文档中，又改用”路由器“这一名词。</p><p>故：<br>外部网关协议EGP可称为：外部路由协议ERP<br>内部网关协议IGP可称为：内部路由协议IRP</p></blockquote><p><strong>常见的路由选择协议</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640504311934-image.png"></p><p><strong>路由器的基本结构</strong></p><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506060598-image.png"></p><p>路由器结构可划分为两大部分：</p><p>1、<strong>分组转发部分</strong></p><p> 由三部分构成</p><ul><li><p>交换结构</p></li><li><p>一组输入端口：</p><p>信号从某个输入端口进入路由器</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506076797-image.png"></p><p>   物理层将信号转换成比特流，送交数据链路层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506086068-image.png"></p><p>   数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506099124-image.png"></p><p>  如果送交网络层的分组是普通待转发的数据分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506122179-image.png"></p><p>  则根据分组首部中的目的地址进行查表转发</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506157190-image.png"></p><p>   若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p><ul><li><p>一组输出端口</p><p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506240762-image.png"></p><p>   数据链路层将数据分组封装成帧，交给物理层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506247348-image.png"></p><p>   物理层将帧看成比特流将其变换成相应的电信号进行发送</p><blockquote><p>路由器的各端口还会有输入缓冲区和输出缓冲区</p><ul><li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p></li><li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506272010-image.png"></p><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分别给出了输入端口和输出端口是为了更好地演示路由基本工作过程</p></blockquote><p> 2、<strong>路由选择部分</strong></p><ul><li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506315904-image.png"></p><p>   路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640505957126-image.png"></p><p>   路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506373840-image.png"></p><h2 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506648635-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506674809-image.png"></p><p><strong>RIP的基本工作过程</strong></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506690642-image.png"></p><p><strong>RIP的路由条目的更新规则</strong></p><p>举例1</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506701216-image.png"></p><blockquote><p>路由器C的表到达各目的网络的下一跳都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506712548-image.png"></p><blockquote><p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是路由器D现在可以根据改造好的路由表，来更新自己先前的路由表了。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506721860-image.png"></p><p>对于上图中的N2，因为原本下一跳是到C，而C的拓扑结构改变了（原来的那条路可能没了），现在到C不能再那么短的距离了，所以需要更新。</p><p>举例2：请给出路由器B更新后的路由表</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506729743-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509033465-image.png"></p><p><strong>RIP存在“坏消息传播得慢”的问题</strong></p><p>假设R2的更新周期先到时，也就是R2的这条路由信息先到达R1。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506747735-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506757581-image.png"></p><p>解决方法</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506768455-image.png"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><p>练习：</p><p>题目中的”检测“意为第一个探测到，而不是说更新路由表后发现不可达。</p><p>根据题目所给“R3检测到网络201.1.2.0/25不可达”可知，R3与该网络是直连的。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509134152-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509280549-image.png"><br>当R3检测到该故障时，将自己到达该网络的路由条目中的距离修改为16，表示该网络不可达，并向R2发送关于这条路由条目的通告。R2收到后，更新自己相应的路由条目，将距离修改为16</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509791007-image.png"></p><p>最后，根据题目”则R2更新后“这句话可知，R1给R2发送了关于该路由条目的RIP更新报文（R1到了周期性传送时间了）。而R2听信了该谣言，误认为到达该目的网络可以通过R1的转发，距离为3</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640509836232-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640506779271-image.png"></p><blockquote><p>RIP 协议的优缺点</p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p></li></ol></blockquote><h2 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h2><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p><p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p><strong>概念</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511652453-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511665934-image.png"></p><p><strong>问候（Hello）分组</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511677729-image.png"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511688239-image.png"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511702036-image.png"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511719730-image.png"></p><p><strong>OSPF五种分组类型</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511727824-image.png"></p><p><strong>OSPF的基本工作过程</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511737787-image.png"></p><p>相邻路由器之间周期性发送问候分组，以便建立和维护邻居关系，建立邻居关系后，给邻居路由器发送数据库描述分组。也就是将自己链路状态数据库中的所有链路状态项目的摘要信息，发送给邻居路由器。</p><p>例如，R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组。</p><p>R2收到后，将R1缺少的链路状态项目的详细信息，封装在链路状态更新分组中发送给R1，R1收到后，将这些所缺少的链路状态项目的详细信息，添加到自己的链路状态数据库中，并给R2发送链路状态确认分组。</p><p>需要说明的是，R2也可以向R1请求自己缺少的链路状态项目的详细信息，这里不再赘述。</p><p>最终，R1和R2的链路状态数据库将达到一致，也就是链路状态数据库达到同步。</p><p>每三十分钟或链路状态发生变化时，路由器都会发送链路状态更新分组。收到该分组的其他路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组。这又称为新情况下的链路状态数据库同步。</p><p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p><p>如果不采用其他机制，将会产生大量的多播分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511750144-image.png"></p><blockquote><p>若DR出现问题，则由BDR顶替DR</p></blockquote><p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p><ul><li><p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p></li><li><p>每个区域都有一个32比特的区域标识符</p></li><li><p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p></li><li><p>其他区域的区域标识符不能为0且不相同</p></li><li><p>每个区域一般不应包含路由器超过200个</p></li><li><p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511761048-image.png"></p><p>如果路由器的所有接口都在同一个区域内，则该路由器称为<strong>区域内路由器IR：R1、R2、R8、R9</strong></p><p><strong>区域边界路由器ABR</strong>，它的一个接口用于连接自身所在区域，另一个接口用于连接主干区域：<strong>R3、R4、R7</strong></p><p>主干区域内的路由器，称为<strong>主干路由器BB：R3、R4、R5、R6、R7</strong></p><p>在主干区域内还要有一个路由器，专门和本自治系统外的其他自治系统交换路由信息，其称为<strong>自治系统边界路由器：R6</strong></p><p>在本例中：</p><p>区域边界路由器R3，向主干区域发送自己所在区域1的链路状态通告；向自己所在区域发送区域0，2，3的链路状态通告LSA。</p><p>区域边界路由器R4，向主干区域发送自己所在区域2的链路状态通告；向自己所在区域发送区域0，1，3的链路状态通告。</p><p>区域边界路由器R7，向主干区域发送自己所在区域3的链路状态通告；向自己所在区域发送区域0，1，2的链路状态通告。</p><p><strong>采用分层次划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做，却能使每一个区域内部，交换路由信息的通信量大大减小。因而使OSPF协议能够用于规模很大的自治系统中。</strong></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640511771635-image.png"></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516140680-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516301863-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516316977-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516444076-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516347988-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516359608-image.png"><br><strong>在BGP协议刚刚运行时，BGP的邻站交换整个BGP路由表，但以后只需要在发生变化时更新有变化的部，这样做对节省网络带宽和减少路由器的处理开销都有好处。</strong></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640517216782-image.png"></p><h2 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640517254310-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640516369655-image.png"></p><hr><h1 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h1><h2 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h2><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521549803-image.png"></p><p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521627493-image.png"></p><blockquote><p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p><p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521890173-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521903229-image.png"></p><p><strong>对IPv4数据报进行分片</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521917328-image.png"><br>其中，片偏移字段中0/8除以8的原因是：片偏移字段以8字节为单位。</p><pre><code>    现在假定分片2的IP数据报经过某个网络时还需要进行分片</code></pre><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640521990714-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522001939-image.png"></p><p>当首部中，协议字段的取值为1时，表明数据部分时ICMP报文，也就是用ICMP协议封装的协议数据单元。</p><p>当首部中，协议字段的取值为6时，表明数据部分时TCP报文，也就是用TCP协议封装的协议数据单元。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522022596-image.png"></p><p><code>因特网检验和</code>的检错能力不强，好处是简单，处理起来快。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522035712-image.png"></p><p>练习：</p><p>第一题：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523407016-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523446972-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523505333-image.png"></p><p>第二题：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523680370-image.png"><br>IP分组要封装成以太网帧才能发送，在IP分组头中，目的IP地址字段前还有16个字节的内容；在以太网帧中，数据载荷前还有14字节的内容。因此可知，在以太网帧中，从第31个字节开始的4个字节，实际上就是目的IP的内容。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640523961116-image.png"><br>从图中可知，主机的默认网关就是路由器R，主机会将Web请求发送给默认网关，由默认网关将Web请求转发到因特网。</p><p>因此，以太网帧头中的目的MAC地址字段，封装的就是默认网关的MAC地址</p><p>如下图所示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640525620901-image.png"><br>（4）</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526159936-image.png"></p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640522056482-image.png"></p><hr><h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>架构IP网络时需要特别注意两点：</p><ul><li>确认网络是否正常工作</li><li>遇到异常时进行问题诊断</li></ul><p><strong>而ICMP就是实现这些问题的协议</strong></p><p>ICMP的主要功能包括：</p><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526315889-image.png"></p><p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p><p>ICMP 报文的格式</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526560581-image.png"></p><h2 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h2><h3 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526364150-image.png"></p><h3 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526386633-image.png"></p><h3 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526398387-image.png"></p><h3 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526414096-image.png"></p><h3 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526463991-image.png"></p><h3 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526475285-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526763689-image.png"></p><h2 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h2><h3 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526487871-image.png"></p><h3 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526841031-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526852962-image.png"></p><p><strong>tracert命令的实现原理</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526867591-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526876348-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526887428-image.png"></p><p>以最后一个为例，H1发送一个封装有ICMP回送请求报文的IP数据报</p><p>其首部中生存时间字段TTL的值被设置为3，经过R1和R2的转发后，该数据报到达主机H2，其生存时间减少为1</p><p>H2解析该数据报，发现其内部封装的是ICMP回送请求报文，于是就给H1发送封装有ICMP回送请求回答报文的IP数据报。</p><p>这样，H1就知道已经跟踪到路径的最后一站，也就是目的主机H2</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640526897832-image.png"></p><hr><h1 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h2><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640527798349-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640527945294-image.png"></p><blockquote><p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p><p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528399297-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528486471-image.png"></p><blockquote><p><strong>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</strong></p><p><strong>私有地址只能用作本地地址而不能用作全球地址</strong></p><p><strong>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</strong></p><p><strong>本地地址与全球地址</strong></p><ul><li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </li><li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li></ul></blockquote><p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528126382-image.png"></p><p>部门A向部门B发送数据流程</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528119910-image.png"></p><blockquote><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528150396-image.png"></p><p>因此也被称为IP隧道技术</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528176255-image.png"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528186360-image.png"></p><p>举例</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528197820-image.png"></p><blockquote><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528206978-image.png"></p><blockquote><p>专有NAT软件的路由器叫做NAT路由器</p><p>它至少有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p></blockquote><p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528216603-image.png"></p><p>因特网上的这台主机给源主机发回数据报</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528225820-image.png"></p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528238068-image.png"></p><p>这种基本转换存在一个问题</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528248721-image.png"></p><p>解决方法</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528257897-image.png"></p><blockquote><p>我们现在用的很多家用路由器都是这种NART路由器</p></blockquote><p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p><p>否定</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528273908-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528285816-image.png"></p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-26/1640528306532-image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络层概述&quot;&gt;&lt;a href=&quot;#网络层概述&quot; class=&quot;headerlink&quot; title=&quot;网络层概述&quot;&gt;&lt;/a&gt;网络层概述&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>2022年全国研究生入学考试第一天</title>
    <link href="http://example.com/2021/12/25/2022%E5%B9%B4%E5%85%A8%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://example.com/2021/12/25/2022%E5%B9%B4%E5%85%A8%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E7%AC%AC%E4%B8%80%E5%A4%A9/</id>
    <published>2021-12-25T00:08:26.000Z</published>
    <updated>2021-12-25T00:34:43.554Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚跟老姨聊了聊，更加坚定了我上软工的决心。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640391897566-7704ea80c4a0ac99a81d395c7809fd9.jpg"></p><p>今天是考研的第一天，刚刚去吃了个牛肉面暖暖身子，去体验一下紧张的氛围，零下-7度，手都伸不出来，带个针织帽耳朵都冷，8点路上遇到个姐姐，校外的，问我食堂在哪，我指了个方向，怕她找不着，我就一路小跑跟在她后面，想想应该没有卡，就想着帮她刷，俩包子，一豆浆，4.5。我转身跟她说了句“加油”，她莞尔一笑，一看手机到账6.6，那就祝姐姐今天考场发挥得666。</p><p>希望彼时彼刻！</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640391922523-b67cc1104ef5fae006a9d26f363295e.jpg"></p><p>分享温暖，peace and love。</p><p>渡过九劫万重关，明年东大等我来！</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640391951999-f048c315bba48267ff22d8bc4955a6a.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨晚跟老姨聊了聊，更加坚定了我上软工的决心。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640391897566-7704ea80c4a0ac99a81d395c7809</summary>
      
    
    
    
    <category term="随笔录" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94%E5%BD%95/"/>
    
    
    <category term="随感" scheme="http://example.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-3数据链路层</title>
    <link href="http://example.com/2021/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2021/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-12-24T01:04:31.000Z</published>
    <updated>2021-12-27T02:42:34.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312728522-image.png"></p><p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312777033-image.png"></p><p><strong>从层次上来看数据的流动</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312791879-image.png"></p><p><strong>仅从数据链路层观察帧的流动</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312811205-image.png"></p><blockquote><p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p><p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p></blockquote><p><strong>数据链路层使用的信道</strong></p><p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p><ul><li>点对点信道</li><li>广播信道</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640312837624-image.png"></p><blockquote><p><strong>局域网属于数据链路层</strong></p><p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p></blockquote><h2 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong></p><p><strong>封装成帧</strong></p><ul><li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li></ul><p>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640314041498-sj%2000_00_00-00_00_30.gif"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313333856-image.png"></p><p><strong>差错控制</strong></p><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313367315-image.png"></p><p><strong>可靠传输</strong></p><p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p><p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p><p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313500264-image.png"></p><blockquote><p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p></blockquote><p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p><p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313394267-image.png"></p><p>可以用编址（地址）的来解决</p><p>将帧的目的地址添加在帧中一起传输</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313406046-image.png"></p><p>还有数据碰撞问题</p><p>当总线上多台主机同时使用总线来传输帧时，传输信号就会产生碰撞，这是采用广播信道的共享式局域网不可避免的。</p><p>以太网采用的协调方法是，使用一种特殊的协议CSMA/CD，也就是载波监听多点接入/碰撞检测。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640313456595-image.png"><br>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640319180335-pz%2000_00_00-00_00_30.gif"></p><blockquote><p>随着技术的发展，交换技术的成熟，</p><p>在 有线（局域网）领域，使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p></blockquote><blockquote><p>由于无线信道的广播天性，在无线局域网中仍然使用的是共享信道技术<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640319597874-image.png"></p></blockquote><hr><h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><p><strong>帧头和帧尾中包含有重要的控制信息</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640319932420-image.png"></p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p><p>答：需要帧头和帧尾来做<strong>帧定界</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324243929-image.png"></p><p>但并不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324270462-image.png"></p><blockquote><p>前导码</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li></ul></blockquote><p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324288162-image.png"></p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><blockquote><p><strong>透明</strong></p><p>指某一个实际存在的事物看起来却好像不存在一样。</p></blockquote><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p><p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324303083-image.png"></p><blockquote><p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p></blockquote><p><strong>解决透明传输问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324314803-image.png"></p><ul><li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li><li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </li></ul><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324744629-image.png"></p><p><strong>帧的数据部分长度</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324332901-image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324350602-image.png"></p><hr><h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324982632-image.png"></p><blockquote><p>FCS：帧检验序列（Frame Check Sequence）</p></blockquote><blockquote><p>在以太网V2的MAC帧格式的帧尾中，包含了一个长度为4字节的FCS字段。其作用就是让接收方的数据链路层，检查帧在传输过程中是否产生了误码。</p></blockquote><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640324994961-image.png"></p><h2 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325046940-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325063159-image.png"></p><p><strong>例题</strong></p><p>例1：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325078192-image.png"></p><p>动图步骤分解：</p><blockquote><p>1、构造被除数<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640326756646-11%2000_00_00-00_00_30.gif"></p></blockquote><blockquote><p>2、构造除数<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640326950205-2%2000_00_00-00_00_30.gif"></p></blockquote><blockquote><p>3、做除法<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327169619-34%2000_00_00-00_00_30.gif"><br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327428849-33%2000_00_00-00_00_30.gif"></p></blockquote><blockquote><p>4、检查余数<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327550182-44%2000_00_00-00_00_30.gif"></p></blockquote><p>例2：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640327686674-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640325102006-image.png"></p><blockquote><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p></blockquote><hr><h1 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>下面是比特差错</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328428971-image.png"></p><p><strong>其他传输差错</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328449618-image.png"></p><ul><li>分组丢失</li></ul><p>路由器输入队列快满了，主动丢弃收到的分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640329002352-fz1%2000_00_00-00_00_30.gif"></p><ul><li>分组失序</li></ul><p>数据并未按照发送顺序依次到达接收端</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328905281-fz%2000_00_00-00_00_30.gif"></p><ul><li>分组重复</li></ul><p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640329132983-fz2%2000_00_00-00_00_30.gif"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640328488142-image.png"></p><h2 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h2><ul><li>停止-等待协议SW</li><li>回退N帧协议GBN</li><li>选择重传协议SR</li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h2 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h2><h3 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h3><p><strong>确认与否认</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333062021-image.png"><br>NAK：否认分组（Negative Acknowledgment， 没有应答）</p><p>小结：<br>发送方每发完一个数据分组后，并不能立即将该数据分组从缓存中删除，只有在收到针对该数据分组的确认分组后，才能将其从缓存中删除。</p><p><strong>超时重传</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333467075-image.png"></p><p><strong>确认丢失</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333489799-image.png"></p><p>一个比特编号，也就是说用0和1即可。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333499360-image.png"></p><blockquote><p>既然数据分组需要编号，确认分组是否需要编号？</p><p>要。如下图所示</p></blockquote><p><strong>确认迟到</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640333999427-image.png"></p><blockquote><p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p></blockquote><p><strong>注意事项</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334338739-image.png"></p><h3 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h3><p>假设收发双方之间是一条直通的信道<br>（图中忽略了接收方对数据分组的处理时延，以及发送方对确认分组的处理时延。）</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li></ul><p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334570881-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334584200-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334596096-image.png"></p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><p>练习:</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640334889057-image.png"></p><h2 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h2><h3 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h3><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339102277-image.png"></p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339121422-image.png"></p><h3 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h3><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339135060-image.png"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339147119-image.png"></p><p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339159243-image.png"></p><h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640339171897-image.png"><br>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345196566-js%2000_00_00-00_00_30.gif"></p><blockquote><p>累计确认</p><p>优点:</p><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>减小接收方的开销</li><li>减小对网络资源的占用</li></ul><p>缺点：</p><ul><li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li></ul></blockquote><h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h3><p>例如</p><p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345351261-image.png"></p><p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345365334-image.png"></p><p>接收同样也不能接收它们，将它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345382029-image.png"></p><p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345886543-image.png"></p><p> 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640345989625-image.png"></p><p>若WT超过取值范围，例如WT=8，会出现什么情况？</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346010310-image.png"></p><p>习题</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346024469-image.png"><br>动图演示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346984847-cc.gif"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640346036210-image.png"></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为<strong>滑动窗口协议</strong></li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h2 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h2><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27">视频链接</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640349282523-image.png"></p><p>例子：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350054565-image.png"></p><p>一般情况下接收窗口大小与发送窗口相同。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350340840-image.png"><br>发送方将序号落在发送窗口内的这4个数据分组依次连续发送出去。它们经过互联网的传输陆续到达接收方，但其中的2号数据分组丢失了。</p><p>只要序号落入接收窗口内且无误码的数据分组，接收方都会接收。接收方接收0号和1号数据分组，并发送0号和1号确认分组。接收窗口向前滑动两个位置，这样就有4和5这两个新的序号落入接收窗口。接收方接收3号数据分组，并发送3号确认分组，但接收窗口不能向前滑动，因为3号数据分组是未按序到达的数据分组。</p><p>这些确认分组经过互联网的传输陆续到达发送方，发送方每按序收到一个确认分组，发送窗口就向前滑动一个位置。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350607273-111%2000_00_00-00_00_30.gif"></p><p>发送方接收0号和1号确认分组，发送窗口向前滑动两个位置，这样就有4和5这两个新的序号落入发送窗口，发送方将序号落入发送窗口的4号和5号数据分组发送出去。发送方现在可以将已经收到确认的0号和1号数据分组，从发送缓存中删除了，而接收方可择机将已按序接收的0号和1号数据分组交付上层处理。</p><p>发送方接收3号确认分组，但发送窗口不能向前滑动，因为这是一个未按序到达的确认分组，发送方还未收到它之前的2号确认分组。不过，需要记录3号数据分组已收到确认，这样该数据分组就不会超时重发。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640350793690-222%2000_00_00-00_00_30.gif"></p><p>4号和5号数据分组到达接收方，接收方接收之，并发送4号和5号确认分组，但接收窗口不能向前滑动，因为它们是未按序到达的数据分组。接收方还未收到它们之前的2号数据分组。</p><p>假设在4号和5号确认分组的传输过程中，发送方针对2号数据分组的重传计时器超时了，发送方重传2号数据分组，4号和5号确认分组陆续到达发送方。发送方接收它们，但发送窗口不能向前滑动，因为它们是未按序到达的确认分组，发送方还未收到它们之前的2号确认分组。不过，需要记录4号和5号数据分组已收到确认，这样它们就不会超时重发。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640357684970-333%2000_00_00-00_00_30.gif"></p><p>发送方之前重传的2号数据分组到达接收方，接收方接受之，并发送2号确认分组，接收窗口现在可以向前滑动4个位置，这样就有6，7，0，1这四个新的序号落入接收窗口。</p><p>2号确认分组经过互联网的传输到达发送方，发送方接收之，发送窗口现在可以向前滑动4个位置，这样就有6，7，0，1这四个新的序号落入发送窗口。发送方现在就可以继续将这四个序号的数据分组依次发送出去了。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640358254939-444%2000_00_00-00_00_30.gif"></p><p><strong>习题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640359443665-image.png"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640359428492-image.png"></p><hr><h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li><li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li><li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640393867274-image.png"></p><ul><li>PPPoE 是为宽带上网的主机使用的链路层协议</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640393885344-image.png"></p><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>必须规定特殊的字符作为帧定界符</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394003308-image.png"></p><h2 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h2><p> 必须保证数据传输的透明性</p><p>实现透明传输的方法</p><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394023009-image.png"></p><ul><li>面向比特的同步链路：比特填充法（插入“比特0”）</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394036499-image.png"></p><h2 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h2><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394465493-image.png"></p><h2 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h2><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机，分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ul><p>动图演示：</p><p>part1<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394843164-11%2000_00_00-00_00_30.gif"></p><p>part2<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394957939-22%2000_00_00-00_00_30.gif"></p><p>all<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640394982228-image.png"></p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><hr><h1 id="媒体接入控制（介质访问控制）——广播信道"><a href="#媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="媒体接入控制（介质访问控制）——广播信道"></a>媒体接入控制（介质访问控制）——广播信道</h1><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p><blockquote><p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p></blockquote><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。 </li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395841573-image.png"></p><p><strong>数据链路层的两个子层</strong></p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395858471-image.png"></p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>为什么要媒体接入控制（介质访问控制）？</p><p><strong>共享信道带来的问题</strong></p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395874504-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640395900951-image.png"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>信道复用</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396063251-image.png"></p><p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p><ul><li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p></li><li><p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396761121-image.png"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396776295-image.png"></p><p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640396787361-image.png"></p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><p><strong>码分复用 CDM  (Code Division Multiplexing)</strong> </p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397157215-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397193171-image.png"></p><p>练习：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397672121-image.png"></p><p>喵喵喵啊：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640397993357-image.png"></p><p>以B站为例：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398082956-image.png"></p><p>真题：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398214903-image.png"></p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><p>受控接入</p><p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p><p><strong>随机接入</strong></p><p><strong>重点</strong></p><h2 id="随机接入（CSMA-CD协议）"><a href="#随机接入（CSMA-CD协议）" class="headerlink" title="随机接入（CSMA/CD协议）"></a>随机接入（CSMA/CD协议）</h2><p><strong>总线局域网使用协议：CSMA/CD</strong></p><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><blockquote><p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398741307-image.png"></p><h3 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h3><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398753790-image.png"></p><h3 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h3><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398761665-image.png"><br>动图演示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399184478-jt%2000_00_00-00_00_30.gif"></p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h3 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h3><ul><li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398830799-image.png"><br>动图演示：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399290142-pz%2000_00_00-00_00_30.gif"></p><blockquote><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398848314-image.png"></p><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p></blockquote><h3 id="CSMA-CD-协议工作流程"><a href="#CSMA-CD-协议工作流程" class="headerlink" title="CSMA/CD 协议工作流程"></a>CSMA/CD 协议工作流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640398871828-image.png"></p><h3 id="CSMA-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA/CD 协议工作——争用期（碰撞窗口）"></a>CSMA/CD 协议工作——争用期（碰撞窗口）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399593948-image.png"></p><h3 id="CSMA-CD-协议工作——最小帧长"><a href="#CSMA-CD-协议工作——最小帧长" class="headerlink" title="CSMA/CD 协议工作——最小帧长"></a>CSMA/CD 协议工作——最小帧长</h3><blockquote><p>帧长一点也就是多说一会，同样的也就能多听一会，这样就可以检测到是否发生了碰撞</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640399933493-image.png"></p><h3 id="CSMA-CD-协议工作——最大帧长"><a href="#CSMA-CD-协议工作——最大帧长" class="headerlink" title="CSMA/CD 协议工作——最大帧长"></a>CSMA/CD 协议工作——最大帧长</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400058682-image.png"></p><h3 id="CSMA-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA/CD 协议工作——截断二进制指数退避算法"></a>CSMA/CD 协议工作——截断二进制指数退避算法</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400146477-image.png"></p><h3 id="CSMA-CD-协议工作——信道利用率"><a href="#CSMA-CD-协议工作——信道利用率" class="headerlink" title="CSMA/CD 协议工作——信道利用率"></a>CSMA/CD 协议工作——信道利用率</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400400766-image.png"></p><h3 id="CSMA-CD-协议工作——帧发送流程"><a href="#CSMA-CD-协议工作——帧发送流程" class="headerlink" title="CSMA/CD 协议工作——帧发送流程"></a>CSMA/CD 协议工作——帧发送流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400531547-image.png"></p><h3 id="CSMA-CD-协议工作——帧接收流程"><a href="#CSMA-CD-协议工作——帧接收流程" class="headerlink" title="CSMA/CD 协议工作——帧接收流程"></a>CSMA/CD 协议工作——帧接收流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400612564-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400716027-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400788405-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400881649-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640400997888-image.png"></p><h3 id="CSMA-CD-协议的重要特性"><a href="#CSMA-CD-协议的重要特性" class="headerlink" title="CSMA/CD 协议的重要特性"></a>CSMA/CD 协议的重要特性</h3><ul><li>使用 CSMA/CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。 </li></ul><blockquote><p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议</strong></p></blockquote><h2 id="随机接入（CSMA-CA协议）"><a href="#随机接入（CSMA-CA协议）" class="headerlink" title="随机接入（CSMA/CA协议）"></a>随机接入（CSMA/CA协议）</h2><p><strong>无线局域网使用的协议：CSMA/CA</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401187558-image.png"></p><h3 id="为什么无线局域网要使用CSMA-CA协议"><a href="#为什么无线局域网要使用CSMA-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA/CA协议"></a>为什么无线局域网要使用CSMA/CA协议</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401219306-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401356996-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401485998-image.png"></p><h3 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401505224-image.png"></p><h3 id="CSMA-CA协议的工作原理"><a href="#CSMA-CA协议的工作原理" class="headerlink" title="CSMA/CA协议的工作原理"></a>CSMA/CA协议的工作原理</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401514952-image.png"></p><blockquote><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401542707-image.png"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640401559283-image.png"></p><h3 id="CSMA-CA协议的退避算法"><a href="#CSMA-CA协议的退避算法" class="headerlink" title="CSMA/CA协议的退避算法"></a>CSMA/CA协议的退避算法</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403445410-image.png"></p><p><strong>退避算法的示例</strong></p><p>如图，A、B、C、D、E是5个无线站点，横坐标为时间。</p><p>假设A正在占用无线信道发送帧，在A的发送过程中，B、C、D也要发送帧，用向上的箭头来表示，于是进行载波监听，<code>发现信道忙，需要退避，根据退避算法选择出一个随机的退避时间，并在每个时隙对信道进行一次检测，当检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器开始倒计时</code>。</p><p>假设C的退避时间最短，当C的退避计时器到时后，C立即开始发送帧，此时信道由空闲状态转换为忙状态，当B和D检测到信道忙后，就冻结各自剩余的退避时间。</p><p>假设在C占用无线信道发送帧的过程中，E也要发送帧，于是进行载波监听，<code>发现信道忙，需要退避。根据退避算法选择出一个随机的退避时间，并在每个时隙对信道进行一次检测，当检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器开始倒计时。</code><br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640404465937-pp1%2000_00_00-00_00_30.gif"><br>末态：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405159240-image.png"></p><p>当B和D检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。</p><p>D的退避计时器会首先到时，D立即开始发送帧。此时信道由空闲状态转换为忙状态，当B和E检测到信道忙后，就冻结各自剩余的退避时间，当D发送完帧后，信道将转为空闲状态，当B和E测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405275746-pp2%2000_00_00-00_00_30.gif"><br>末态：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405691112-image.png"></p><p>E的退避计时器会首先到时，E立即开始发送帧。此时信道由空闲状态转换为忙状态，当B检测到信道忙后，就冻结自己剩余的退避时间，当E发送完帧后，信道将转为空闲状态，当B测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。</p><p>当B的退避计时器到时后，B立即开始发送帧。若B发送完这一帧后还有帧要发送，则在检测到信道空闲，且经过帧间间隔DIFS后，还必须再退避一段随机时间后，才能发送。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640405864895-pp3%2000_00_00-00_00_30.gif"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403456513-image.png"></p><h3 id="CSMA-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA/CA协议的信道预约和虚拟载波监听"></a>CSMA/CA协议的信道预约和虚拟载波监听</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403473723-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640403487264-image.png"></p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640406934465-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640406945870-image.png"></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407085368-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407168594-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407229677-image.png"></p><p>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407279137-image.png"></p><hr><h1 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640406966759-image.png"></p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407480075-image.png"></p><h3 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407532795-image.png"></p><blockquote><p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h3 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640407795768-image.png"></p><blockquote><p>说白了前面一半(OUI)是标识网卡的厂商，后一半(EUI)是厂商定义的网卡序号用于标识同一厂商的不同网卡的MAC地址。</p></blockquote><p><a href="https://mac.bmcx.com/">查询MAC地址对应的设备厂商信息</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408411167-image.png"></p><blockquote><p><strong>组织唯一标识符OUI</strong></p><ul><li><p>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408271647-image.png"><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408300333-image.png"></p></li><li><p><em>网络接口标识符</em>*    </p></li><li><p>由获得OUI的厂商自行随意分配</p></li></ul><p><strong>EUI-48</strong></p><ul><li>48是这个MAC地址的位数</li></ul></blockquote><blockquote><p>全球管理：表示是全球唯一的</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408825601-image.png"></p><blockquote><p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p></blockquote><p><strong>关于无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li></ul><blockquote><p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong> </p></blockquote><h3 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408907878-image.png"></p><h3 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408916792-image.png"></p><blockquote><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408926630-image.png"></p><blockquote><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p><p>并将该帧交给其上层处理</p></blockquote><h3 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408937232-image.png"></p><blockquote><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408947809-image.png"></p><blockquote><p>主机B将该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p></blockquote><h3 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408958590-image.png"></p><blockquote><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408983911-image.png"></p><blockquote><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640408998943-image.png"></p><blockquote><p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640409009648-image.png"></p><blockquote><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p></blockquote><blockquote><p>注意：给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址，具体可点<a href="https://standards.ieee.org/products-services/regauth/grpmac/public.html">这里</a>进行查询</p></blockquote><p>结果如下图所示：<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640409633741-image.png"><br>……</p><h3 id="随机MAC地址"><a href="#随机MAC地址" class="headerlink" title="随机MAC地址"></a>随机MAC地址</h3><p>由于斯诺登披露，美国国家安全局有一套系统，通过监视电子设备的MAC地址，来跟踪城市里每个人的行动。因此苹果率先在IOS系列设备，扫描网络设备时，采用随机MAC地址技术，随后……<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640409784123-image.png"></p><p>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640410062094-image.png"></p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p><p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418572750-image.png"></p><h3 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418607589-image.png"></p><h3 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h3><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418625421-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418640294-image.png"></p><blockquote><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP协议</p></blockquote><p>习题：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640418684938-image.png"><br>小结：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640419696130-image.png"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP（地址解析协议）</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420598772-image.png"></p><p>ARP高速缓存表</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420609104-image.png"></p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420620751-image.png"></p><blockquote><p>ARP请求报文有具体的格式，上图的只是简单描述</p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420639053-image.png"></p><blockquote><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420669650-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420684239-image.png"></p><p>动态与静态的区别</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420693092-image.png"></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420705052-image.png"></p><blockquote><p>ARP协议的使用是逐段链路进行的</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420718261-image.png"></p><hr><h1 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h1><h2 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420842093-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420854878-image.png"></p><blockquote><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li><li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li><li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li></ul></blockquote><h3 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h3><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420876689-image.png"></p><blockquote><ul><li><strong>优点</strong><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol></li><li><strong>缺点</strong><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。 </li></ol></li></ul></blockquote><p><strong>碰撞域</strong></p><ul><li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高。</li></ul><h2 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>扩展以太网更常用的方法是在数据链路层进行。</li><li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420893674-image.png"></p><blockquote><p><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。 </li></ul><p><strong>交换机</strong></p><ul><li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul></blockquote><h3 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h3><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640420907593-image.png"></p><blockquote><p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p><p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422545336-image.png"></p><blockquote><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li><li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>对比集线器和交换机</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422573402-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422662539-image.png"></p><blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><strong>单播</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422703146-image.png"></p><p><strong>广播</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422712697-image.png"></p><p><strong>多个单播</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422728116-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422736198-image.png"></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640422751710-image.png"></p><blockquote><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p></blockquote><hr><h1 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640423943535-image.png"></p><h2 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h2><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><p><strong>A -&gt; B</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640423958445-image.png"></p><blockquote><ol><li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li><li>交换机向除接口 1 以外的所有的接口广播这个帧</li><li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 2 写入（图中右边）交换表中</li><li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li><li>主机B发现是给自己的帧，接受该帧</li></ol></blockquote><p><strong>B -&gt; A</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424159451-image.png"></p><blockquote><ol><li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>主机 A 发现目的地址是它，就接受该帧</li><li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li></ol></blockquote><p><strong>E -&gt; A</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424268106-image.png"></p><blockquote><ol><li>E 向 A发送一帧</li><li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li><li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li><li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li><li>主机 A 发现目的地址是它，就接受该帧</li></ol></blockquote><p><strong>G -&gt; A（丢弃帧的情况）</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424427233-image.png"></p><blockquote><p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p><ol><li>主机 G 发送给 主机 A 一个帧</li><li>主机 A 和 交换机接口 1都能接收到</li><li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li><li>交换机 1收到该帧后，首先进行登记工作</li><li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li><li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li></ol></blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424585887-image.png"></p><blockquote><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p></blockquote><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>交换机自学习和转发帧的步骤归纳</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424685215-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424695103-image.png"></p><p>习题：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424649494-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640424909239-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640425039518-image.png"><br>1、左侧主机给右侧主机发送数据帧，该帧从交换机的接口1进入交换机，交换机首先进行登记工作，将该帧的源MAC地址记录到自己的帧交换表中，将该帧进入自己的接口的接口号，相应的也记录到帧交换表中。</p><p>之后，交换机对该帧进行转发，在帧交换表中查找该帧的目的MAC地址（00-e1-d5-00-23-c1），找不到，就进行盲目转发，因此<code>数据帧的转发端口为2和3</code></p><p>2、登记源MAC地址，将该帧进入自己的接口的接口号，相应的也记录到帧交换表中。之后，交换机对该帧进行转发，在帧交换表中查找该帧的目的MAC地址，可以找到，于是按照MAC地址对应的接口号1，从接口1明确转发该帧。因此，<code>交换机转发确认帧的端口为1</code></p><hr><h1 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h1><h2 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427323256-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427339637-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427350556-image.png"></p><h2 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427363775-image.png"><br>当某段链路出现故障，相关交换机检测到该故障后，重新计算生成树。决定将自己之前阻塞的接口恢复为正常状态，这样就会生成一个新的逻辑上没有环路的网络。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640428248268-hh%2000_00_00-00_00_30.gif"></p><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><hr><h1 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h1><h2 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h2><p><strong>广播风暴</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427491648-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427504705-image.png"></p><p><strong>分割广播域的方法</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427521001-image.png"></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427529435-image.png"></p><blockquote><ul><li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li></ul></blockquote><h2 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h2><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427559776-image.png"></p><p><strong>Access端口</strong></p><p>交换机与用户计算机之间的互连</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427594140-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427602837-image.png"></p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><strong>Truck端口</strong></p><p>交换机之间或交换机与路由器之间的互连</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427615006-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640430470688-image.png"></p><p><strong>连接主机的交换机端口应设置为Access类型，交换机之间互连的端口应设置为Trunk类型！</strong></p><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427631948-image.png"></p><p><strong>华为交换机私有的Hybrid端口类型</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427645960-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427654552-image.png"></p><p>主机B给A发送的普通以太网MAC帧，主机A收到的却是802.1Q帧，无法识别而丢弃。</p><p><code>利用用户主机无法识别802.1Q帧的手段，来实现通信隔离。</code></p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-25/1640427665700-image.png"></p><blockquote><p><strong>虚拟局域网优点</strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性 </li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据链路层概述&quot;&gt;&lt;a href=&quot;#数据链路层概述&quot; class=&quot;headerlink&quot; title=&quot;数据链路层概述&quot;&gt;&lt;/a&gt;数据链路层概述&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>瑞斯拜豆芽哥！</title>
    <link href="http://example.com/2021/12/23/%E7%91%9E%E6%96%AF%E6%8B%9C%E8%B1%86%E8%8A%BD%E5%93%A5%EF%BC%81/"/>
    <id>http://example.com/2021/12/23/%E7%91%9E%E6%96%AF%E6%8B%9C%E8%B1%86%E8%8A%BD%E5%93%A5%EF%BC%81/</id>
    <published>2021-12-23T14:38:26.000Z</published>
    <updated>2022-01-15T08:14:25.904Z</updated>
    
    <content type="html"><![CDATA[<p>  今天嵌入式课设第一天，B站还是牛，愁了一两个星期的问题，用<code>APK编辑器</code>+<code>云注入</code>，实现了DIY+开局弹窗。</p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640272324524-image.png" style="zoom:45%;" /><p>  我们学校有国二，还没有国一的，三四个月的时间，没问题的。</p><p>  在这偶尔情绪会泛滥的夜，瑞斯拜豆芽哥！</p><blockquote><p>《不用去猜》 Jony J</p></blockquote><p>灯，不会在</p><p>任何时候为我开，是好是坏</p><p>该不该，还没来的不想猜</p><p>有谁能真的看得清楚，要怎么组未来的拼图</p><p>不会为了限量款排队，我都是天亮了才睡</p><p><strong>时间比LV还贵，人生总苦短又怎么能白费</strong></p><p><strong>没兴趣在乎我在别人眼中的定位，普通或另类</strong></p><p><strong>讨厌或敬佩，不需要多余的应对</strong></p><p><strong>只想跟懂我的说一声幸会，因为</strong></p><p><strong>别的都不屑，快乐是自己的没人可以借</strong></p><p><strong>忘记了恨谁，有谁忘了谢</strong></p><p><strong>偶尔在情绪会泛滥的夜，没有人会帮你把你变得更好</strong></p><p><strong>错过只能怪你没有趁早，每天都要保持前进</strong></p><p><strong>我势必要有强劲的实力，再跟全新的自己问好</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640271516795-image.png"></p><p>昨天已经过去明天还没来，今天的一切就算突然我也不奇怪</p><p>我不再预测未来因为总在意料外，该在的都会在</p><p>不管这世界变得多么快，从没想过买个彩票可以让我中奖</p><p><strong>也不需要不实在的面子，我也早就不跟别人谈论什么梦想</strong></p><p><strong>悄悄把梦想都变成现实，不管我是试试看</strong></p><p><strong>还是扑了空，直接做到而不是挂在嘴边</strong></p><p>是个穷光蛋，还是大富翁</p><p>我都尽力的过好我的每天，因为灯</p><p>不会在，任何时候为我开</p><p>是好是坏，该不该</p><p>还没来的不想猜，有谁能真的看得清楚</p><p>(哪里是归宿)，要怎么组未来的拼图</p><p>(先走好每一步)，我知道灯</p><p>不会在，任何时候为我开</p><p>是好是坏，该不该</p><p>还没来的不想猜，有谁能真的看得清楚</p><p>(哪里是归宿)，要怎么组未来的拼图</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640272022557-image.png"></p><p><strong>不浪费时间去猜测我未来会碰到的麻烦或惊喜，虽然也常会有问号跟感叹号出现但不让它留在我心里</strong></p><p>曾经我为了去武装我自己，很快就学会了冷漠和脏话</p><p><strong>现在我不想再装，我只想更爽快想悠然的活在这当下</strong></p><p><strong>时间又不会为我赖着不走，干嘛停下来为了选择头疼</strong></p><p><strong>我的新目标就在下个路口，现在要做的就是加点油门</strong></p><p><strong>当我穿过拥挤的人群，穿过低谷时被冲洗的人情</strong></p><p><strong>感谢所有为我亮起的灯在我丧气的时候，总是仗义的过来按我门铃</strong></p><p>因为灯，不会在</p><p>任何时候为我开，是好是坏</p><p>该不该，还没来的不想猜</p><p>有谁能真的看得清楚，(哪里是归宿)</p><p>要怎么组未来的拼图，(先走好每一步)</p><p>我知道灯，不会在</p><p>任何时候为我开，是好是坏</p><p>该不该，还没来的不想猜</p><p><strong>有谁能真的看得清楚，(哪里是归宿)</strong></p><p><strong>要怎么组未来的拼图，(先走好每一步)</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  今天嵌入式课设第一天，B站还是牛，愁了一两个星期的问题，用&lt;code&gt;APK编辑器&lt;/code&gt;+&lt;code&gt;云注入&lt;/code&gt;，实现了DIY+开局弹窗。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/r2peak/picture/raw/maste</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="随感" scheme="http://example.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-2物理层</title>
    <link href="http://example.com/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://example.com/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2021-12-23T11:34:31.000Z</published>
    <updated>2021-12-26T04:19:18.312Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640308533240-image.png"></p><h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259223415-image.png"></p><hr><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259604351-image.png"></p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p><p><strong>同轴电缆</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259540435-image.png"></p><p><strong>双绞线</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259806097-image.png"></p><p><strong>光纤</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640259966233-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260067975-image.png"></p><blockquote><p><strong>多模光纤</strong></p><ul><li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li></ul><p><strong>单模光纤</strong></p><ul><li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260185225-image.png"></p><p><strong>电力线</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260291823-image.png"></p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><p>非导引型传输媒体是指自由空间。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260368722-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260394180-image.png"></p><p><strong>无线电波</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260452471-image.png"></p><p><strong>微波</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260587933-image.png"></p><p><strong>红外线</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260617724-image.png"></p><p><strong>可见光</strong></p><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260751497-image.png"></p><hr><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260914464-image.png"></p><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640260971554-image.png"></p><blockquote><p><strong>串行传输</strong>：</p><ul><li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li></ul><p><strong>并行传输</strong>：</p><ul><li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p></li><li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p></li></ul><p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p></blockquote><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261108573-image.png"></p><blockquote><p><strong>同步传输</strong>：</p><ul><li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li></ul><p>所以要使收发双发时钟保持同步</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261212383-image.png"></p><blockquote><p><strong>异步传输</strong>：</p><ul><li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul></blockquote><h2 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h2><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><p><strong>单向通信</strong>：</p><p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261264213-image.png"></p><p><strong>双向交替通信</strong>：</p><p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261300994-image.png"></p><p><strong>双向同时通信</strong>：</p><p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261336625-image.png"></p><blockquote><p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p><p><strong>双向同时通信</strong>的传输效率最高</p></blockquote><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261776448-image.png"></p><blockquote><p><strong>常用术语</strong></p><ul><li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p></li><li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </p></li><li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </p></li><li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </p></li><li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p></li><li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p></li><li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。 </p></li></ul></blockquote><p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261880083-image.png"></p><h2 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h2><blockquote><p><strong>信道的几个基本概念</strong></p><ul><li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li><li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。 </li></ul></blockquote><p>严格来说，传输媒体不能和信道划等号</p><p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261952688-image.png"></p><p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640261962121-image.png"></p><blockquote><p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p></blockquote><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><p><strong>不归零编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640263170240-image.png"></p><blockquote><ul><li><p>正电平表示比特1/0</p></li><li><p>负电平表示比特0/1</p></li></ul><p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640263155180-image.png"></p><blockquote><p>这需要发送方的发送与接收方的接收做到严格的同步</p><ul><li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li><li><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</li></ul><p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p></blockquote><p><strong>归零编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265622989-image.png"></p><blockquote><p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p></blockquote><p><strong>曼彻斯特编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265727495-image.png"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发生跳变</p><ul><li>负跳变表示比特1/0</li><li>正跳变表示比特0/1</li><li>码元中间时刻的跳变即表示时钟，又表示数据</li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>传统以太网使用的就是曼切斯特编码</p></blockquote><p><strong>差分曼彻斯特编码</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265711075-image.png"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li><strong>跳变仅表示时钟</strong></li><li><strong>码元开始处电平是否变换表示数据</strong><ul><li>变化表示比特1/0</li><li>不变化表示比特0/1</li></ul></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p></blockquote><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265881275-image.png"><br><strong>练习</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640265989291-image.png"></p><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK/直接序列扩频DSSS/正交频分复用OFDM等<strong>调制</strong>方式。</p><p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p><p><strong>基本调制方法</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266143531-image.png"></p><blockquote><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li></ul><p>但是使用基本调制方法，1个码元只能包含1个比特信息</p></blockquote><p><strong>混合调制</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266190433-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266225459-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266448474-image.png"></p><blockquote><p>下图中一个绿点是一个码元（在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。）</p></blockquote><blockquote><p>每个码元对应4个bit原因：由于QAM可以调制出16种波形，每个波形对应1个码元，所以1个码元需要包含4个bit</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266460203-image.png"></p><blockquote><p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640266483834-image.png"></p><blockquote><p>用<a href="https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858?fr=aladdin">格雷码</a>（在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code））的原因是可以降低出错个数，原先最多错四个，用格雷码最多错1个</p></blockquote><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267500705-image.png"></p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267528943-image.png"></p><blockquote><p>三种基本调制方法，它们属于二元调制，只能产生两种不同的码元，也就是两种不同的基本波形，因此每个码元只能携带1比特的信息量<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267784141-image.png"></p></blockquote><blockquote><p>混合调制，属于多元调制，例如QAM16可以调制出16种不同的码元，因此每个码元可以携带4比特的信息量<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267999915-image.png"></p></blockquote><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267544466-image.png"></p><p>奈氏准则和香农公式对比：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640267558877-image.png"></p><hr><p>练习：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640268507728-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640268670854-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640268784941-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269048914-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269228282-image.png"></p><h1 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h1><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p><h2 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h2><p>复用 (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269303651-image.png"></p><p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 </li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269318712-image.png"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong> </p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269333875-image.png"></p><ul><li><strong>时分复用可能会造成线路资源的浪费</strong><ul><li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269348614-image.png"></p><p><strong>统计时分复用 STDM  (Statistic TDM)</strong> </p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269364876-image.png"></p><h2 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h2><p>波分复用 WDM(Wavelength Division Multiplexing)</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640269377651-image.png"></p><h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用 CDM  (Code Division Multiplexing)</p><ul><li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640308533240-image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;物理层的基本概念&quot;&gt;&lt;a href=&quot;#物理层的基本概念&quot; clas</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络习题课</title>
    <link href="http://example.com/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98%E8%AF%BE/"/>
    <id>http://example.com/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98%E8%AF%BE/</id>
    <published>2021-12-22T22:54:31.000Z</published>
    <updated>2021-12-24T02:19:19.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="体系结构题目"><a href="#体系结构题目" class="headerlink" title="体系结构题目"></a>体系结构题目</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640215933942-image.png"><br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640244709012-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640215952327-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640215967702-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640215978191-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640215986428-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640215996997-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216004320-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216013410-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216023493-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216032329-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216042986-image.png"></p><h2 id="时延相关题目"><a href="#时延相关题目" class="headerlink" title="时延相关题目"></a>时延相关题目</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640248095604-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216167364-image.png"><br>发送时延：又称为传输时延，是指结点在发送数据时使数据块从结点进入到传输媒体所需的时间，也就是<strong>从数据块的第一个比特开始发送算起，到最后一个比特发送完毕所需的时间。</strong><br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640250041507-QQ%E5%BD%95%E5%B1%8F20211223165023%2000_00_00-00_00_30.gif"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216191837-image.png"></p><p><strong>如下图，将报文划分成若干个更小的分组进行分组交换，路由器可以一边接收新到达的分组，一边转发先前已接收到的分组。</strong><br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216207767-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640251927324-image.png"></p><p><strong>p/b是1个分组的发送时延，x/p是分组的数量；</strong></p><p><strong>k是链路数量，那么(k-l)就是转发次数；</strong></p><p><strong>kd是k段链路的传播时延。</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640251981702-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640252221159-image.png"></p><p><strong>由于本题规定忽略传播时延，故传播时延kd不计入总时延D。</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216269364-image.png"></p><p><strong>题目特意指明信息量单位Mb中的M为10的6次，目的是为了方便我们将它与传输速率单位中的M直接约掉。但在未指明的情况下，我们一般应将信息量单位中的M取值为2的20次。</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216282384-image.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216347601-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216373321-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640310769886-image.png"><br>(详细解答见物理层笔记)</p><blockquote><p>低通：（Low-passfilter）是容许低于截止频率的信号通过，但高于截止频率的信号不能通过的电子滤波装置</p></blockquote><blockquote><p>带通：是指能通过某一频率范围内（给出信道频率上下限）的频率分量、但将其他范围的频率分量衰减到极低水平的滤波器</p></blockquote><p>若题目没有指出信道是带通信道，则信道属于低通信道。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640311017432-image.png"></p><p><strong>调制速率，也就是<code>码元传输速率</code></strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-24/1640311244399-image.png"></p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216420480-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216440108-image.png"></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216479443-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216495838-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216509706-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216516204-image.png"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216560608-image.png"></p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216578627-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216585544-image.png"></p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216601148-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216663565-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216676982-image.png"></p><h2 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216700610-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216709645-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216724239-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216735220-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216742413-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216759591-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216768747-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216780265-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216788902-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216802700-image.png"></p><h2 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216822509-image.png"></p><h2 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216846288-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216860008-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216872059-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216881004-image.png"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216951206-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216963689-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216974533-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216983072-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640216991468-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217000227-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217008221-image.png"></p><h2 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217026674-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217035576-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217046813-image.png"></p><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217062083-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217068315-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217081579-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217095789-image.png"></p><h2 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217119687-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217130128-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217140227-image.png"></p><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217158588-image.png"></p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217192375-image.png"></p><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217208276-image.png"></p><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217225615-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217232538-image.png"></p><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217250882-image.png"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217283895-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217296026-image.png"></p><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217314381-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217321413-image.png"></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217340337-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217350696-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217359205-image.png"></p><h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217377986-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-23/1640217385946-image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;体系结构题目&quot;&gt;&lt;a href=&quot;#体系结构题目&quot; class=&quot;headerlink&quot; title=&quot;体系结构题目&quot;&gt;&lt;/a&gt;体</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>马拉松！</title>
    <link href="http://example.com/2021/12/22/%E9%A9%AC%E6%8B%89%E6%9D%BE%EF%BC%81/"/>
    <id>http://example.com/2021/12/22/%E9%A9%AC%E6%8B%89%E6%9D%BE%EF%BC%81/</id>
    <published>2021-12-22T08:00:26.000Z</published>
    <updated>2021-12-22T08:23:11.669Z</updated>
    
    <content type="html"><![CDATA[<p>今天马拉松，9KM全校第16名，阿伟15名。有五十块奖金，还不错。<br><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640160251585-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640160555609-image.png"></p><p>38分钟，跑5公里的时候肚子疼得不行，还是坚持下来了，瑞斯拜一波自己。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640161343872-91612DF8B90372316B02D4C901D91A8D.png"></p><p>奖牌真好看。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640160459936-image.png"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640160475039-image.png"></p><p>这是路线图：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640160527207-image.png"></p><p>进了七瓶水，送小邹及其小伙伴们共四瓶，阿袁一瓶，回来又跟阿伟，阿超各自要了一瓶，爽歪歪。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640161309160-80C98668D12446340EC4F70A9407EEB0.png"></p><p>这几天好好学计网，明天开始嵌入式课设，加油干！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天马拉松，9KM全校第16名，阿伟15名。有五十块奖金，还不错。&lt;br&gt;&lt;img src=&quot;https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640160251585-image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="随感" scheme="http://example.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-1概述</title>
    <link href="http://example.com/2021/12/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/12/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1%E6%A6%82%E8%BF%B0/</id>
    <published>2021-12-22T01:54:31.000Z</published>
    <updated>2021-12-23T00:07:33.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640181013096-image.png"></p><h2 id="图示说明"><a href="#图示说明" class="headerlink" title="图示说明"></a>图示说明</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640140187772-image.png" alt="img"></p><h1 id="1-1、计算机网络在信息时代的作用"><a href="#1-1、计算机网络在信息时代的作用" class="headerlink" title="1.1、计算机网络在信息时代的作用"></a>1.1、计算机网络在信息时代的作用</h1><ul><li>计算机网络已由一种<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></li><li>计算机网络已经像水，电，煤气这些基础设施一样，成为我们<strong>生活中不可或缺</strong>的一部分</li></ul><h2 id="我国互联网发展状况"><a href="#我国互联网发展状况" class="headerlink" title="我国互联网发展状况"></a>我国互联网发展状况</h2><p><a href="http://www.cnnic.net.cn/">中国互联网络信息中心 CNNIC</a></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141190161-image.png" alt="图1"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141215545-image.png" alt="图2"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141229008-image.png" alt="图3"></p><p>&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;</p><h1 id="1-2、因特网概述"><a href="#1-2、因特网概述" class="headerlink" title="1.2、因特网概述"></a>1.2、因特网概述</h1><h2 id="1、网络、互连网（互联网）和因特网"><a href="#1、网络、互连网（互联网）和因特网" class="headerlink" title="1、网络、互连网（互联网）和因特网"></a>1、网络、互连网（互联网）和因特网</h2><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141514917-image.png" alt="img"></p><p>互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141566006-image.png" alt="img"></p><p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141600956-image.png" alt="img"></p><blockquote><p><strong>internet 与 Internet 的区别</strong></p><ul><li>**internet(互联网或互连网)**是一个通用名词，它泛指**多个计算机网络互连而成的网络**。在这些网络之间的通信协议可以是任意的。</li><li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用 TCP/IP 协议族作为通信的规则，其前身是美国的 ARPANET。</li></ul><p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141714937-image.png" alt="img"></p><h2 id="2、因特网发展的三个阶段"><a href="#2、因特网发展的三个阶段" class="headerlink" title="2、因特网发展的三个阶段"></a>2、因特网发展的三个阶段</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141753427-image.png" alt="img"></p><p><strong>因特网服务提供者<code>ISP</code>(<code>I</code>nternet <code>S</code>ervice <code>P</code>rovider)</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141782854-image.png" alt="img"></p><blockquote><p>普通用户是如何接入到因特网的呢？</p><p>答：<strong>通过 ISP 接入因特网</strong></p><p>ISP 可以从因特网管理机构申请到成块的 IP 地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP 的得到所需要的 IP 地址</strong>。</p><p><strong>因为因特网上的主机都必须有 IP 地址才能进行通信，这样就可以通过该 ISP 接入到因特网</strong></p></blockquote><p><strong>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141910497-image.png" alt="img"></p><p><strong>基于 ISP 的三层结构的因特网</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141947834-image.png" alt="img"></p><blockquote><p>一旦某个用户能够接入到因特网，那么他也可以成为一个 ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p></blockquote><h2 id="3、因特网的标准化工作"><a href="#3、因特网的标准化工作" class="headerlink" title="3、因特网的标准化工作"></a>3、因特网的标准化工作</h2><ul><li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li><li>因特网在指定其标准上的一个很大的特点是<strong>面向公众。</strong><ul><li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><strong>因特网协会 ISOC</strong>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。<ul><li>因特网体系结构委员会 IAB，负责管理因特网有关协议的开发；</li><li>因特网工程部 IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li><li>因特网研究部 IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640141976391-image.png" alt="img"></p><ul><li><p>制订因特网的正式标准要经过一下<strong>4 个阶段</strong>：</p><p>1、因特网草案（在这个阶段还不是 RFC 文档）</p><p>2、建议标准（从这个阶段开始就成为 RFC 文档）</p><p>3、草案标准</p><p>4、因特网标准</p></li></ul><h2 id="4、因特网的组成"><a href="#4、因特网的组成" class="headerlink" title="4、因特网的组成"></a>4、因特网的组成</h2><ul><li><p>边缘部分</p><p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p></li><li><p>核心部分</p><p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142067589-image.png" alt="img"></p><blockquote><p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p><p><strong>端系统在功能上可能有很大的差别：</strong></p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP。</li></ol></blockquote><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p><strong>端系统之间通信的含义</strong></p><p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p><p>端系统之间的通信方式通常可划分为两大类：</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142092193-image.png" alt="img"></p><p><strong>客户-服务器方式：</strong></p><ul><li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li><li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务的请求方，服务器是服务的提供方。</li></ul><blockquote><p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p></blockquote><p><strong>对等连接方式：</strong></p><ul><li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li><li>双方都可以下载对方已经存储在硬盘中的共享文档。</li></ul><hr><h1 id="1-3-三种交换方式"><a href="#1-3-三种交换方式" class="headerlink" title="1.3 三种交换方式"></a>1.3 三种交换方式</h1><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p><p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p><h2 id="1、电路交换（Circuit-Switching）"><a href="#1、电路交换（Circuit-Switching）" class="headerlink" title="1、电路交换（Circuit Switching）"></a>1、电路交换（Circuit Switching）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142116823-image.png" alt="img"></p><blockquote><p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p><p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142131861-image.png" alt="img"></p><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p></li><li><p>电路交换的三个步骤：</p><p>1、建立连接（分配通信资源）</p><p>2、通话（一直占用通信资源）</p><p>3、释放连接（归还通信资源）</p></li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142172494-image.png" alt="img"></p><blockquote><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><p>这是因为计算机数据是突发式地出现在传输线路上的。</p><p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p></blockquote><h2 id="2、分组交换（Packet-Switching）"><a href="#2、分组交换（Packet-Switching）" class="headerlink" title="2、分组交换（Packet Switching）"></a>2、分组交换（Packet Switching）</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142187700-image.png" alt="img"></p><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器</p><ul><li>缓存分组</li><li>转发分组</li><li>简称为“分组转发”</li></ul><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><ol><li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li><li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口<strong>转发</strong>出去。</li></ol></blockquote><p>接收方</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="3、报文交换（Message-Switching）"><a href="#3、报文交换（Message-Switching）" class="headerlink" title="3、报文交换（Message Switching）"></a>3、报文交换（Message Switching）</h2><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><blockquote><p>假设 A，B，C，D 是分组传输路径所要经过的 4 个结点交换机，纵坐标为时间</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142205748-image.png" alt="img"></p><p>分析：</p><p>电路交换：</p><ul><li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li><li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li></ul><p>报文交换：</p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><p>分组交换：</p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142227189-image.png" alt="img"></p><hr><h1 id="1-4-计算机网络的定义和分类"><a href="#1-4-计算机网络的定义和分类" class="headerlink" title="1.4 计算机网络的定义和分类"></a>1.4 计算机网络的定义和分类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>计算机网络的精确定义并未统一</li><li>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。<ul><li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li><li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li><li>集合：是指至少需要两台计算机；</li></ul></li><li>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机 CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ul></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li>公用网</li><li>专用网</li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网 WAN（Wide Area Network）</li></ul><p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p><ul><li>城域网 MAN</li></ul><p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p><ul><li>局域网 LAN</li></ul><p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右）</p><ul><li>个域网 PAN</li></ul><p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p><p><strong>按拓扑结构分类：</strong></p><ul><li>总线型网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142269206-image.png" alt="img"></p><ul><li>星型网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142276589-image.png" alt="img"></p><ul><li>环形网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142284505-image.png" alt="img"></p><ul><li>网状型网络</li></ul><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142292234-image.png" alt="img"></p><hr><h1 id="1-5-计算机网络的性能指标"><a href="#1-5-计算机网络的性能指标" class="headerlink" title="1.5 计算机网络的性能指标"></a>1.5 计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142311959-image.png" alt="img"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142327572-image.png" alt="img"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142343767-image.png" alt="img"></p><blockquote><p>带宽 1 Gb/s 的以太网，代表其额定速率是 1 Gb/s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽 1 Gb/s 的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低。</p><p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p></blockquote><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li>发送时延</li></ul><p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><ul><li>传播时延</li></ul><p>电磁波在信道中传播一定的距离需要花费的时间。</p><ul><li>处理时延</li></ul><p>主机或路由器在收到分组时要花费一定时间进行处理</p><ul><li>排队时延</li></ul><p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><blockquote><p>有时会把排队时延看成<strong>处理时延 一部分</strong></p><p>总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142380749-image.png" alt="img"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142399039-image.png" alt="img"></p><blockquote><p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p></blockquote><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 = 传播时延 * 带宽</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142413686-image.png" alt="img"></p><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142425942-image.png" alt="img"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142439263-image.png" alt="img"></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142449337-image.png" alt="img"></p><hr><h1 id="1-6-计算机网络体系结构"><a href="#1-6-计算机网络体系结构" class="headerlink" title="1.6 计算机网络体系结构"></a>1.6 计算机网络体系结构</h1><h2 id="1、常见的计算机网络体系结构"><a href="#1、常见的计算机网络体系结构" class="headerlink" title="1、常见的计算机网络体系结构"></a>1、常见的计算机网络体系结构</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142464891-image.png" alt="img"></p><blockquote><p>如今用的最多的是 TCP/IP 体系结构，现今规模最大的、覆盖全球的、基于 TCP/IP 的互联网并未使用 OSI 标准。</p><p>TCP/IP 体系结构相当于将 OSI 体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>TCP/IP 在网络层使用的协议是 IP 协议，IP 协议的意思是网际协议，因此<strong>TCP/IP 体系结构的网络层称为网际层</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142477688-image.png" alt="img"></p><blockquote><p>在用户主机的操作系统中，通常都带有符合 TCP/IP 体系结构标准的 TCP/IP 协议族。</p><p>而用于网络互连的路由器中，也带有符合 TCP/IP 体系结构标准的 TCP/IP 协议族。</p><p>只不过路由器一般只包含网络接口层和网际层。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142621853-image.png" alt="img"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的 WIFI 接口等。</p><p><strong>网际层</strong>：它的核心协议是 IP 协议。</p><p><strong>运输层</strong>：TCP 和 UDP 是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p></blockquote><blockquote><p><strong>IP 协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP 协议和 UDP 协议（运输层）</strong>提供网络互连服务</p><p>而<strong>TCP 协议</strong>在享受 IP 协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p><p><strong>UDP 协议</strong>在享受 IP 协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p></blockquote><blockquote><p>TCP/IP 体系结构中最重要的是<strong>IP 协议</strong>和<strong>TCP 协议</strong>，因此用 TCP 和 IP 来表示整个协议大家族。</p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142685463-image.png" alt="img"></p><blockquote><p>教学时把 TCP/IP 体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p></blockquote><h2 id="2、计算机网络体系结构分层的必要性"><a href="#2、计算机网络体系结构分层的必要性" class="headerlink" title="2、计算机网络体系结构分层的必要性"></a>2、计算机网络体系结构分层的必要性</h2><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142719723-image.png" alt="img"></p><p><strong>物理层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142735117-image.png" alt="img"></p><blockquote><p>这图说明</p><ul><li>第一，严格来说，传输媒体并不属于物理层</li><li>计算机传输的信号，并不是图示的方波信号</li></ul><p>这样举例只是让初学者容易理解</p></blockquote><p><strong>数据链路层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142771978-image.png" alt="img"></p><p><strong>网络层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142823123-image.png" alt="img"></p><p><strong>运输层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142861590-image.png" alt="img"></p><blockquote><p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是 QQ 进程</p></blockquote><p><strong>应用层问题</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142871692-image.png" alt="img"></p><blockquote><p>应用层该用什么方法（应用层协议）去解析数据</p></blockquote><p><strong>总结</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142894542-image.png" alt="img"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142938911-image.png" alt="img"></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142947701-image.png" alt="img"></p><h2 id="3、计算机网络体系结构分层思想举例"><a href="#3、计算机网络体系结构分层思想举例" class="headerlink" title="3、计算机网络体系结构分层思想举例"></a>3、计算机网络体系结构分层思想举例</h2><p>例子：主机的浏览器如何与 Web 服务器进行通信</p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640142999599-image.png" alt="img"></p><p><strong>解析：</strong></p><p>主机和 Web 服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与 Web 服务器中的<strong>Web 服务器应用进程</strong>之间基于<strong>网络的通信</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143034227-image.png" alt="img"></p><p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p><p><strong>1、发送方发送</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143045601-image.png" alt="img"></p><blockquote><p>第一步：</p><ul><li><strong>应用层</strong>按照 HTTP 协议的规定构建一个<strong>HTTP 请求报文</strong></li><li>应用层将<strong>HTTP 请求报文</strong>交付给<strong>运输层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143058037-image.png" alt="img"></p><blockquote><p>第二步：</p><ul><li><strong>运输层</strong>给<strong>HTTP 请求报文</strong>添加一个<strong>TCP 首部</strong>，使之成为<strong>TCP 报文段</strong></li><li><strong>TCP 报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</li><li><strong>运输层</strong>将 T<strong>CP 报文段</strong>交付给<strong>网络层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143069985-image.png" alt="img"></p><blockquote><p>第三步：</p><ul><li><strong>网络层</strong>给<strong>TCP 报文段</strong>添加一个<strong>IP 首部</strong>，使之成为<strong>IP 数据报</strong></li><li><strong>IP 数据报的首部格式</strong>作用是使<strong>IP 数据报</strong>可以在互联网传输，也就是被路由器转发</li><li><strong>网络层</strong>将<strong>IP 数据报</strong>交付给<strong>数据链路层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143087179-image.png" alt="img"></p><blockquote><p>第四步：</p><ul><li><strong>数据链路层</strong>给<strong>IP 数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</li><li>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</li><li>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</li><li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143112339-image.png" alt="img"></p><blockquote><p>第五步：</p><ul><li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络 N1 假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li><li><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143120335-image.png" alt="img"></p><blockquote><p>第六步：</p><ul><li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li></ul></blockquote><p><strong>2、路由器转发</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143139107-image.png" alt="img"></p><blockquote><p>在路由器中</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP 数据报</strong></li><li><strong>网络层</strong>解析<strong>IP 数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></li></ul></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143194532-image.png" alt="img"></p><blockquote><p>在路由器中</p><ul><li>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</li><li><strong>网络层</strong>将<strong>IP 数据报</strong>交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>给<strong>IP 数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></li><li><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></li><li><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络 N2 假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web 服务器</strong></li></ul></blockquote><p><strong>3、接收方接收</strong></p><blockquote><p>和发送方（主机）发送过程的封装正好是反着来</p><p>在 Web 服务器上</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP 数据报</strong>，将其交付给<strong>网络层</strong></li><li><strong>网络层</strong>将<strong>IP 数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP 报文段</strong>，将其交付给<strong>运输层</strong></li><li><strong>运输层</strong>将<strong>TCP 报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP 请求报文</strong>，将其交付给<strong>应用层</strong></li><li><strong>应用层</strong>对<strong>HTTP 请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li></ul><p><strong>发回响应报文的步骤和之前过程类似</strong></p></blockquote><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143241911-image.png" alt="img"></p><h2 id="4、计算机网络体系结构中的专用术语"><a href="#4、计算机网络体系结构中的专用术语" class="headerlink" title="4、计算机网络体系结构中的专用术语"></a>4、计算机网络体系结构中的专用术语</h2><p>以下介绍的专用术语来源于 OSI 的七层协议体系结构，但也适用于 TCP/IP 的四层体系结构和五层协议体系结构</p><p><strong>实体</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143250955-image.png" alt="img"></p><p><strong>协议</strong></p><p><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143267151-image.png" alt="img"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><p>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><strong>服务</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143284271-image.png" alt="img"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143297199-image.png" alt="img"></h2><img src="https://gitee.com/r2peak/picture/raw/master/2021-12-22/1640143304707-image.png" alt="img" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink&quot; title=&quot;思维导图&quot;&gt;&lt;/a&gt;思维导图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/r2peak/picture/raw/master/2021-12-</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
