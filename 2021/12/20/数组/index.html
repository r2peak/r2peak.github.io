<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数组 | Road To Peak</title><meta name="keywords" content="leetcode,算法"><meta name="author" content="马厚煜"><meta name="copyright" content="马厚煜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、理论数组是存放在连续内存空间上的相同类型数据的集合。    内存地址： 0x00 0x01 0x02 0x03    字符数组： A B C D   下标： 0 1 2 3   注意：  数组下标都是从0开始的 数组元素无法删除，只能覆盖 数组内存空间的地址是连续的  由于数组在内存空间中的地址连续，故在增删元素时，难免要移动其他元素的地址。 ２、二分查找传送门 给定一个 n 个元素有序的（升">
<meta property="og:type" content="article">
<meta property="og:title" content="数组">
<meta property="og:url" content="http://example.com/2021/12/20/%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="Road To Peak">
<meta property="og:description" content="1、理论数组是存放在连续内存空间上的相同类型数据的集合。    内存地址： 0x00 0x01 0x02 0x03    字符数组： A B C D   下标： 0 1 2 3   注意：  数组下标都是从0开始的 数组元素无法删除，只能覆盖 数组内存空间的地址是连续的  由于数组在内存空间中的地址连续，故在增删元素时，难免要移动其他元素的地址。 ２、二分查找传送门 给定一个 n 个元素有序的（升">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/xx.jpg">
<meta property="article:published_time" content="2021-12-20T02:54:31.000Z">
<meta property="article:modified_time" content="2022-01-15T08:13:28.672Z">
<meta property="article:author" content="马厚煜">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/xx.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2021/12/20/%E6%95%B0%E7%BB%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数组',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-15 16:13:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Road To Peak" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/xx.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Road To Peak</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数组</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-20T02:54:31.000Z" title="发表于 2021-12-20 10:54:31">2021-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-15T08:13:28.672Z" title="更新于 2022-01-15 16:13:28">2022-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数组"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、理论"><a href="#1、理论" class="headerlink" title="1、理论"></a>1、理论</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p>
<table>
<thead>
<tr>
<th align="center">内存地址：</th>
<th align="center">0x00</th>
<th align="center">0x01</th>
<th align="center">0x02</th>
<th align="center">0x03</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字符数组：</strong></td>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center"><strong>下标：</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li><strong>数组下标都是从0开始的</strong></li>
<li><strong>数组元素无法删除，只能覆盖</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p>由于数组在内存空间中的地址连续，故在增删元素时，难免要移动其他元素的地址。</p>
<h2 id="２、二分查找"><a href="#２、二分查找" class="headerlink" title="２、二分查找"></a>２、二分查找</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">传送门</a></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>关键词：升序、不重复  =&gt; 二分查找</p>
<p>二分思路：将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2]，则找到x，算法中止；如果x&lt;a[n/2]，则只要在数组a的左半部分继续搜索x，如果x&gt;a[n/2]，则只要在数组a的右半部搜索x。</p>
<p>时间复杂度即是while循环的次数。</p>
<p>代码：找左右两个边界量left、right，在循环中更新中间值middle，下面两种写法，差别在于右边界的开闭。先想一想程序的判断逻辑，再想一想程序执行的步骤，就能把代码写出来了。</p>
<p>思路一：左闭右闭区间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>亮点：middle = left + ((right - left) / 2);</p>
<p>这种写法起到了防止溢出的作用，等同于(left + right)/2</p>
<p>思路二：左闭右开区间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>亮点：middle = left + ((right - left) &gt;&gt; 1)</p>
<p>位运算的速度更快！</p>
<p>总结：二分的查找效率很高，时间复杂度O(log2n)。</p>
<p>推导一下，2^k = n 可以推出 k = log2n（k是循环的次数，n是元素个数）</p>
<h2 id="3、移除元素"><a href="#3、移除元素" class="headerlink" title="3、移除元素"></a>3、移除元素</h2><p>27.移除元素<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">传送门</a></p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>思路一：暴力（两层for）</p>
<p>略</p>
<p>思路二：快慢指针（一层for）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历数组，更新nums数组</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) &#123; <span class="comment">// 找到不等于val的数</span></span><br><span class="line">                nums[a++] = nums[i]; <span class="comment">// 将找到的数字，从数组头依次向后放置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>亮点：将a++合到一行里面</p>
<p>相关题目：</p>
<p>26.删除有序数组中的重复项</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">传送门</a></p>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line"></span><br><span class="line">为什么返回数值是整数，但输出的答案是数组呢?</span><br><span class="line"></span><br><span class="line">请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</span><br><span class="line"></span><br><span class="line">你可以想象内部操作如下:</span><br><span class="line"></span><br><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;= nums.length &lt;= 3 * 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums 已按升序排列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思路一：快慢指针法</p>
<p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-12/1641993917378-2%2000_00_00-00_00_30.gif"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反思：</p>
<ul>
<li>数组长度为0情况没考虑，没想到用while</li>
<li>若写成：nums[fast] != nums[–fast]会报超时</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/">题解</a></p>
<p>以下相关例题，后期复习再完善。<br>283.移动零<br>844.比较含退格的字符串<br>977.有序数组的平方</p>
<h2 id="4、有序数组的平方"><a href="#4、有序数组的平方" class="headerlink" title="4、有序数组的平方"></a>4、有序数组的平方</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">题目链接</a></p>
<p>思路一：直接法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num * num); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




<p><strong>复杂度分析:</strong></p>
<p>时间复杂度：O(n log n)，其中 n 是数组 nums 的长度。</p>
<p>空间复杂度：O(log n)。除了存储答案的数组以外，我们需要 O(log n)的栈空间进行排序。</p>
<p><strong>反思：</strong></p>
<ul>
<li>一开始想复杂了，想通过集合排序平方后的数，再存入数组。</li>
<li>最直接的方法就是先平方再sort()</li>
</ul>
<p><strong>关于sort()底层</strong></p>
<blockquote>
<p>STL的sort算法，数据量大时采用QuickSort快排算法，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用Insertion Sort插入排序。如果递归层次过深，还会改用HeapSort堆排序。<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-11/1641902212227-image.png"></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44918090/article/details/120386879">原文链接</a></p>
<p>思路二：双指针法</p>
<p>&emsp;&emsp;给的是 非递减顺序 排序的整数数组，类似这种：[-4,-1,0,3,10]，则最大值出现在数组的两端，通过两个指针i，j分别从两端进行比较，在比较后根据结果决定将 i 后移/ j 前移。比较两端数字绝对值（因为平方）的大小，用一个指针k指向新数组ans最右端，在比较出一个最大值后赋值给ans[k]，每一次赋值后，将k前移。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">ans</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>); <span class="comment">// 元素个数为nums.size(),值均为0 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = k; i &lt;= j;) &#123;<span class="comment">// 右端更大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;</span><br><span class="line">                ans[k--] = nums[j] * nums[j]; <span class="comment">// 最大值依次从右端开始放</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 左端更大</span></span><br><span class="line">                ans[k--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析:</strong><br>此时的时间复杂度为O( n )，相对于暴力排序的解法O(n log n)提升不少。</p>
<p><em>完整手撸代码：</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">	nums.<span class="built_in">push_back</span>(<span class="number">-4</span>); </span><br><span class="line">	nums.<span class="built_in">push_back</span>(<span class="number">-1</span>); </span><br><span class="line">	nums.<span class="built_in">push_back</span>(<span class="number">10</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">ans</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>); <span class="comment">// 元素个数为nums.size(),值均为0 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = k; i &lt;= j;) &#123;<span class="comment">// 右端更大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;</span><br><span class="line">                ans[k--] = nums[j] * nums[j]; <span class="comment">// 最大值依次从右端开始放</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 左端更大</span></span><br><span class="line">                ans[k--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    <span class="comment">//访问方式一：数组方式    </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//访问方式二：使用迭代器将容器中数据输出 </span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = ans.<span class="built_in">begin</span>(); it != ans.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><code>1 16 100</code></p>
<p><code>1 16 100</code></p>
<blockquote>
<p>不必太在意leetcode上执行用时，打败多少多少用户，这个就是一个玩具，非常不准确。</p>
<p>做题的时候自己能分析出来时间复杂度就可以了，至于leetcode上执行用时，大概看一下就行，只要达到最优的时间复杂度就可以了，</p>
<p>一样的代码多提交几次可能就击败百分之百了…..</p>
</blockquote>
<h2 id="5、长度最小的子数组"><a href="#5、长度最小的子数组" class="headerlink" title="5、长度最小的子数组"></a>5、长度最小的子数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">传送门</a></p>
<p>&emsp;&emsp;给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<p><strong>思路一：暴力法</strong></p>
<p>&emsp;&emsp;枚举数组nums中的每个下标作为子数组的开始下标，对于每个开始下标 i 需要找到 &gt;= i 的最小下标 j ， 使得从nums[i] 到 nums[j] 的元素和大于或等于给定的target，并更新子数组的最小长度（j - i + 1），此处更新操作用到了<code>min()</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX; <span class="comment">// INT_MAX = 2^32 - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans , j - i + <span class="number">1</span>); <span class="comment">// 更新最短的len，太妙了这里</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n^2)，其中 n 是数组的长度。需要遍历每个下标作为子数组的开始下标，对于每个开始下标，需要遍历其后面的下标得到长度最小的子数组。</p>
<p>空间复杂度：O(1)。</p>
<p><strong>思路二：滑动窗口</strong></p>
<p>&emsp;&emsp;所谓滑动窗口，就是不断的调节子数组的起始位置和终止位置，从而得出我们要想的结果。在思路一中，需要每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高。为了降低时间复杂度，可采用本方法。<br>&emsp;&emsp;</p>
<p>&emsp;&emsp;定义俩指针start,end 分别表示子数组（滑动窗口）的开始、结束位置，sum存储子数组中的元素和（下标从start到end）。初始状态下，start、end都指向下标0，sum为0.</p>
<p>&emsp;&emsp;每一轮迭代，将nums[end]加到sum中，若sum &gt;= s ，则更新子数组的最小长度（end - start + 1），然后将nums[start]从sum中减去并将start右移，直到sum &lt; target，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将end右移。</p>
<p>&emsp;&emsp;下面，动图理解 “ 滑动 ” 过程：<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-12/1641985841040-1%2000_00_00-00_00_30.gif"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="comment">// 滑动窗口</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = INT_MAX; <span class="comment">// 记录最短字串长度</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; n) &#123;</span><br><span class="line">             sum += nums[end]; <span class="comment">//向后推进end，不断累加</span></span><br><span class="line">             <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                 len = <span class="built_in">min</span>(len, end - start + <span class="number">1</span>); <span class="comment">// 更新最短子串长度</span></span><br><span class="line">                 sum -= nums[start]; <span class="comment">// 将start值从sum中减去</span></span><br><span class="line">                 start++; <span class="comment">// 后移start指针</span></span><br><span class="line">             &#125;</span><br><span class="line">             end++; <span class="comment">// 若不满足sum &gt;= target 就将end后移，继续加到sum里头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == INT_MAX ? <span class="number">0</span> : len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 是数组的长度。指针 start 和 end 最多各移动 n 次。</p>
<p>空间复杂度：O(1)。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/chang-du-zui-xiao-de-zi-shu-zu-by-leetcode-solutio/">题解传送门</a></p>
<h2 id="6、螺旋矩阵II"><a href="#6、螺旋矩阵II" class="headerlink" title="6、螺旋矩阵II"></a>6、螺旋矩阵II</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">传送门</a></p>
<p>给定一个正整数 n，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>示例:</p>
<p>输入: 3 输出:</p>
<p>[[ 1, 2, 3 ], </p>
<p> [ 8, 9, 4 ], </p>
<p> [ 7, 6, 5 ] ]</p>
<hr>
<p> 下图是坐标系：<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642036090183-image.png"></p>
<hr>
<p>用vector创建二维数组：<br><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642037730591-image.png"></p>
<p><strong>思路一：模拟螺旋</strong></p>
<p>模拟螺旋形, 依次填入。</p>
<p>定义x, y为当前应填入数字的位置, d标志该位置前进的方向。</p>
<p>坐标轴x向下、y向右为正方向。初始x, y在左上角, 即第一个位置, d标志右方。</p>
<p>每填入一个数字, 根据方向移动(x, y), 如果移动后的位置超过了边界或者已经被填过, 则转弯</p>
<p>d转弯的顺序依次是: 右下左上. 直到填入了n*n个数字为止即可</p>
<hr>
<p>下面，欣赏思维之美：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//          右 下 左  上</span></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">res</span> (n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// n行n列赋初值0</span></span><br><span class="line">        <span class="comment">// 0 1 2 3 访问dx,dy数组来控制移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>; i &lt;= n * n; i++, x += dx[d] , y += dy[d]) &#123;</span><br><span class="line">            res[x][y] = i; <span class="comment">// 将 i 赋值给元素</span></span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[d], ny = y + dy[d]; <span class="comment">//探路变量，若发生越界，立即控制d转向，不会影响到x和y的值</span></span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= n || res[nx][ny]) &#123; <span class="comment">// 越界控制</span></span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 控制d只能取到 0 1 2 3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思考：</p>
<ul>
<li>for 循环内，实际发生移动的变量是 x 和 y，可称之为位移变量。</li>
<li>为了在越界时，不影响 x 和 y 的值，在此处定义了探路变量：nx 和 ny 用来看看前面的路是什么情况？是继续按原来方向走呢，还是转向。要是 nx 或 ny 发生越界了，立马执行 if 内部的转向代码，控制转移方向。在本次循环体执行完后，改变实际的位移变量的 x 和 y ，来进行螺旋赋值。</li>
</ul>
<p> 完整代码：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//          右 下 左 上</span></span><br><span class="line">    <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">res</span> (<span class="number">5</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>)); <span class="comment">// n行n列赋初值0</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>; <span class="comment">// 0 1 2 3 访问dx,dy数组来控制移动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>; i &lt;= <span class="number">5</span> * <span class="number">5</span>; i++, x += dx[d], y += dy[d]) &#123;     	</span><br><span class="line">        res[x][y] = i; <span class="comment">// 将 i 赋值给元素   </span></span><br><span class="line">        <span class="keyword">int</span> nx = x + dx[d] , ny = y + dy[d]; </span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= <span class="number">5</span> || nx &lt; <span class="number">0</span> || ny &gt;= <span class="number">5</span> || ny &lt; <span class="number">0</span> || res[nx][ny])</span><br><span class="line">        d = (d + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 控制d只能取到 0 1 2 3</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">			cout&lt;&lt;res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">6</span></span><br><span class="line"><span class="number">15</span> <span class="number">24</span> <span class="number">25</span> <span class="number">20</span> <span class="number">7</span></span><br><span class="line"><span class="number">14</span> <span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">8</span></span><br><span class="line"><span class="number">13</span> <span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>数组作为非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力,也就是说，想法很简单，但实现起来hhh</p>
<p>首先要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题</p>
<ul>
<li><p>数组是存放在连续内存空间上的相同类型数据的集合。</p>
</li>
<li><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p>
</li>
<li><p>数组下标都是从0开始的。</p>
</li>
<li><p>数组内存空间的地址是连续的</p>
</li>
<li><p>数组的元素是不能删的，只能覆盖。</p>
</li>
</ul>
<p>正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</p>
<p>如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p>
<p>对于二维数组：</p>
<p><img src="https://gitee.com/r2peak/picture/raw/master/2022-1-13/1642045782028-image.png"></p>
<hr>
<p><font color=#0099ff size=7 face="黑体">数组的经典题目</font></p>
<p><font color =green size=5> 1、二分法</p>
<blockquote>
<p>数组：每次遇到二分法，都是一看就会，一写就废</p>
<p>二分法是算法面试中的常考题，通过这道题目，锻炼自己手撕二分的能力。</p>
<p>这题考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。</p>
<p>可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目</p>
<p>暴力解法时间复杂度：O(n) </p>
<p>二分法时间复杂度：O(log n)</p>
<p>在这道题目中用到了循环不变量原则，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。</p>
</blockquote>
<p><font color =green size=5>2、双指针法</p>
<blockquote>
<p>数组：就移除个元素很难么？</p>
<p>双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</p>
<p>暴力解法时间复杂度：O(n^2)<br>双指针时间复杂度：O(n)<br>这道题目迷惑了不少同学，纠结于数组中的元素为什么不能删除，主要是因为以下两点：</p>
<p>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。<br>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。<br>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组和链表操作的面试题，都使用双指针法。</p>
</blockquote>
<p><font color =green size=5>3、滑动窗口</p>
<blockquote>
<p>数组：滑动窗口拯救了你</p>
<p>本题介绍了数组操作中的另一个重要思想：滑动窗口。<br>暴力解法时间复杂度：O(n^2)<br>滑动窗口时间复杂度：O(n)</p>
<p>本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。</p>
<p>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。<br>如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。</p>
</blockquote>
<p><font color =green size=5>4、模拟行为</p>
<blockquote>
<p>数组：这个循环可以转懵很多人！</p>
<p>相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，踩了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的，大家可以在这道题目中体会到这一点。</p>
</blockquote>
<p>这里第一次学到了，<strong>探路变量</strong>和<strong>位移变量</strong>的组合使用，探路变量每次循环都会更新，保证了在当前位置，若检测到越界，立即转向的作用。把位移变量放在for循环中的步长处，在每次循环体执行完后，根据更新/未更新的方向改变其位置，就挺妙的嗷！</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/xx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/20/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"><img class="prev-cover" src="/img/mn3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Markdown常用语法</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/19/%E6%97%A0%E8%BF%B9%E6%97%A0%E5%9E%A0/"><img class="next-cover" src="/img/by.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">无迹无垠</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/13/%E9%93%BE%E8%A1%A8/" title="链表"><img class="cover" src="/img/hm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">链表</div></div></a></div><div><a href="/2022/01/14/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2/" title="递归三部曲"><img class="cover" src="/img/kuko.gif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-14</div><div class="title">递归三部曲</div></div></a></div><div><a href="/2022/01/15/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表"><img class="cover" src="/img/xxjzt.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-15</div><div class="title">哈希表</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">马厚煜</div><div class="author-info__description">为者常成，行者常至</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/r2peak"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/r2peak" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Start it from the bottom</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%90%86%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1、理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%92%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.</span> <span class="toc-text">２、二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">3.</span> <span class="toc-text">3、移除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">4.</span> <span class="toc-text">4、有序数组的平方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">5、长度最小的子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="toc-number">6.</span> <span class="toc-text">6、螺旋矩阵II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">7、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/" title="C++中的STL"><img src="/img/zj.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++中的STL"/></a><div class="content"><a class="title" href="/2022/01/18/C++%E4%B8%AD%E7%9A%84STL/" title="C++中的STL">C++中的STL</a><time datetime="2022-01-18T04:27:31.000Z" title="发表于 2022-01-18 12:27:31">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2021%E7%9C%81%E8%B5%9B/" title="蓝桥杯2021省赛"><img src="/img/fh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="蓝桥杯2021省赛"/></a><div class="content"><a class="title" href="/2022/01/17/%E8%93%9D%E6%A1%A5%E6%9D%AF2021%E7%9C%81%E8%B5%9B/" title="蓝桥杯2021省赛">蓝桥杯2021省赛</a><time datetime="2022-01-17T06:27:31.000Z" title="发表于 2022-01-17 14:27:31">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表"><img src="/img/xxjzt.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="哈希表"/></a><div class="content"><a class="title" href="/2022/01/15/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表">哈希表</a><time datetime="2022-01-15T03:27:31.000Z" title="发表于 2022-01-15 11:27:31">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2/" title="递归三部曲"><img src="/img/kuko.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="递归三部曲"/></a><div class="content"><a class="title" href="/2022/01/14/%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2/" title="递归三部曲">递归三部曲</a><time datetime="2022-01-13T23:58:31.000Z" title="发表于 2022-01-14 07:58:31">2022-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/%E9%93%BE%E8%A1%A8/" title="链表"><img src="/img/hm.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表"/></a><div class="content"><a class="title" href="/2022/01/13/%E9%93%BE%E8%A1%A8/" title="链表">链表</a><time datetime="2022-01-13T01:58:31.000Z" title="发表于 2022-01-13 09:58:31">2022-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 马厚煜</div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>